{"ast":null,"code":"\"use strict\";var rankUtil=require(\"./util\");var longestPath=rankUtil.longestPath;var feasibleTree=require(\"./feasible-tree\");var networkSimplex=require(\"./network-simplex\");module.exports=rank;/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */function rank(g){switch(g.graph().ranker){case\"network-simplex\":networkSimplexRanker(g);break;case\"tight-tree\":tightTreeRanker(g);break;case\"longest-path\":longestPathRanker(g);break;default:networkSimplexRanker(g);}}// A fast and simple ranker, but results are far from optimal.\nvar longestPathRanker=longestPath;function tightTreeRanker(g){longestPath(g);feasibleTree(g);}function networkSimplexRanker(g){networkSimplex(g);}","map":null,"metadata":{},"sourceType":"module"}