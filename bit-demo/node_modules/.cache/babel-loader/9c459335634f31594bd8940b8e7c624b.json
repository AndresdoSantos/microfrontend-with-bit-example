{"ast":null,"code":"import{isAsyncIterable}from'iterall';import inspect from'../jsutils/inspect';import{addPath,pathToArray}from'../jsutils/Path';import{GraphQLError}from'../error/GraphQLError';import{locatedError}from'../error/locatedError';import{assertValidExecutionArguments,buildExecutionContext,buildResolveInfo,collectFields,execute,getFieldDef,resolveFieldValueOrError}from'../execution/execute';import{getOperationRootType}from'../utilities/getOperationRootType';import mapAsyncIterator from'./mapAsyncIterator';export function subscribe(argsOrSchema,document,rootValue,contextValue,variableValues,operationName,fieldResolver,subscribeFieldResolver){/* eslint-enable no-redeclare */ // Extract arguments from object args if provided.\nreturn arguments.length===1?subscribeImpl(argsOrSchema):subscribeImpl({schema:argsOrSchema,document:document,rootValue:rootValue,contextValue:contextValue,variableValues:variableValues,operationName:operationName,fieldResolver:fieldResolver,subscribeFieldResolver:subscribeFieldResolver});}/**\n * This function checks if the error is a GraphQLError. If it is, report it as\n * an ExecutionResult, containing only errors and no data. Otherwise treat the\n * error as a system-class error and re-throw it.\n */function reportGraphQLError(error){if(error instanceof GraphQLError){return{errors:[error]};}throw error;}function subscribeImpl(args){var schema=args.schema,document=args.document,rootValue=args.rootValue,contextValue=args.contextValue,variableValues=args.variableValues,operationName=args.operationName,fieldResolver=args.fieldResolver,subscribeFieldResolver=args.subscribeFieldResolver;var sourcePromise=createSourceEventStream(schema,document,rootValue,contextValue,variableValues,operationName,subscribeFieldResolver);// For each payload yielded from a subscription, map it over the normal\n// GraphQL `execute` function, with `payload` as the rootValue.\n// This implements the \"MapSourceToResponseEvent\" algorithm described in\n// the GraphQL specification. The `execute` function provides the\n// \"ExecuteSubscriptionEvent\" algorithm, as it is nearly identical to the\n// \"ExecuteQuery\" algorithm, for which `execute` is also used.\nvar mapSourceToResponse=function mapSourceToResponse(payload){return execute(schema,document,payload,contextValue,variableValues,operationName,fieldResolver);};// Resolve the Source Stream, then map every source value to a\n// ExecutionResult value as described above.\nreturn sourcePromise.then(function(resultOrStream){return(// Note: Flow can't refine isAsyncIterable, so explicit casts are used.\nisAsyncIterable(resultOrStream)?mapAsyncIterator(resultOrStream,mapSourceToResponse,reportGraphQLError):resultOrStream);});}/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */export function createSourceEventStream(schema,document,rootValue,contextValue,variableValues,operationName,fieldResolver){// If arguments are missing or incorrectly typed, this is an internal\n// developer mistake which should throw an early error.\nassertValidExecutionArguments(schema,document,variableValues);try{// If a valid context cannot be created due to incorrect arguments,\n// this will throw an error.\nvar exeContext=buildExecutionContext(schema,document,rootValue,contextValue,variableValues,operationName,fieldResolver);// Return early errors if execution context failed.\nif(Array.isArray(exeContext)){return Promise.resolve({errors:exeContext});}var type=getOperationRootType(schema,exeContext.operation);var fields=collectFields(exeContext,type,exeContext.operation.selectionSet,Object.create(null),Object.create(null));var responseNames=Object.keys(fields);var responseName=responseNames[0];var fieldNodes=fields[responseName];var fieldNode=fieldNodes[0];var fieldName=fieldNode.name.value;var fieldDef=getFieldDef(schema,type,fieldName);if(!fieldDef){throw new GraphQLError(\"The subscription field \\\"\".concat(fieldName,\"\\\" is not defined.\"),fieldNodes);}// Call the `subscribe()` resolver or the default resolver to produce an\n// AsyncIterable yielding raw payloads.\nvar resolveFn=fieldDef.subscribe||exeContext.fieldResolver;var path=addPath(undefined,responseName);var info=buildResolveInfo(exeContext,fieldDef,fieldNodes,type,path);// resolveFieldValueOrError implements the \"ResolveFieldEventStream\"\n// algorithm from GraphQL specification. It differs from\n// \"ResolveFieldValue\" due to providing a different `resolveFn`.\nvar result=resolveFieldValueOrError(exeContext,fieldDef,fieldNodes,resolveFn,rootValue,info);// Coerce to Promise for easier error handling and consistent return type.\nreturn Promise.resolve(result).then(function(eventStream){// If eventStream is an Error, rethrow a located error.\nif(eventStream instanceof Error){return{errors:[locatedError(eventStream,fieldNodes,pathToArray(path))]};}// Assert field returned an event stream, otherwise yield an error.\nif(isAsyncIterable(eventStream)){// Note: isAsyncIterable above ensures this will be correct.\nreturn eventStream;}throw new Error('Subscription field must return Async Iterable. Received: '+inspect(eventStream));});}catch(error){// As with reportGraphQLError above, if the error is a GraphQLError, report\n// it as an ExecutionResult; otherwise treat it as a system-class error and\n// re-throw it.\nreturn error instanceof GraphQLError?Promise.resolve({errors:[error]}):Promise.reject(error);}}","map":null,"metadata":{},"sourceType":"module"}