{"ast":null,"code":"import find from'../polyfills/find';import keyMap from'../jsutils/keyMap';import inspect from'../jsutils/inspect';import printPathArray from'../jsutils/printPathArray';import{GraphQLError}from'../error/GraphQLError';import{Kind}from'../language/kinds';import{print}from'../language/printer';import{isInputType,isNonNullType}from'../type/definition';import{typeFromAST}from'../utilities/typeFromAST';import{valueFromAST}from'../utilities/valueFromAST';import{coerceInputValue}from'../utilities/coerceInputValue';/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */export function getVariableValues(schema,varDefNodes,inputs,options){var maxErrors=options&&options.maxErrors;var errors=[];try{var coerced=coerceVariableValues(schema,varDefNodes,inputs,function(error){if(maxErrors!=null&&errors.length>=maxErrors){throw new GraphQLError('Too many errors processing variables, error limit reached. Execution aborted.');}errors.push(error);});if(errors.length===0){return{coerced:coerced};}}catch(error){errors.push(error);}return{errors:errors};}function coerceVariableValues(schema,varDefNodes,inputs,onError){var coercedValues={};var _loop=function _loop(_i2){var varDefNode=varDefNodes[_i2];var varName=varDefNode.variable.name.value;var varType=typeFromAST(schema,varDefNode.type);if(!isInputType(varType)){// Must use input types for variables. This should be caught during\n// validation, however is checked again here for safety.\nvar varTypeStr=print(varDefNode.type);onError(new GraphQLError(\"Variable \\\"$\".concat(varName,\"\\\" expected value of type \\\"\").concat(varTypeStr,\"\\\" which cannot be used as an input type.\"),varDefNode.type));return\"continue\";}if(!hasOwnProperty(inputs,varName)){if(varDefNode.defaultValue){coercedValues[varName]=valueFromAST(varDefNode.defaultValue,varType);}else if(isNonNullType(varType)){var _varTypeStr=inspect(varType);onError(new GraphQLError(\"Variable \\\"$\".concat(varName,\"\\\" of required type \\\"\").concat(_varTypeStr,\"\\\" was not provided.\"),varDefNode));}return\"continue\";}var value=inputs[varName];if(value===null&&isNonNullType(varType)){var _varTypeStr2=inspect(varType);onError(new GraphQLError(\"Variable \\\"$\".concat(varName,\"\\\" of non-null type \\\"\").concat(_varTypeStr2,\"\\\" must not be null.\"),varDefNode));return\"continue\";}coercedValues[varName]=coerceInputValue(value,varType,function(path,invalidValue,error){var prefix=\"Variable \\\"$\".concat(varName,\"\\\" got invalid value \")+inspect(invalidValue);if(path.length>0){prefix+=\" at \\\"\".concat(varName).concat(printPathArray(path),\"\\\"\");}onError(new GraphQLError(prefix+'; '+error.message,varDefNode,undefined,undefined,undefined,error.originalError));});};for(var _i2=0;_i2<varDefNodes.length;_i2++){var _ret=_loop(_i2);if(_ret===\"continue\")continue;}return coercedValues;}/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */export function getArgumentValues(def,node,variableValues){var coercedValues={};var argNodeMap=keyMap(node.arguments||[],function(arg){return arg.name.value;});for(var _i4=0,_def$args2=def.args;_i4<_def$args2.length;_i4++){var argDef=_def$args2[_i4];var name=argDef.name;var argType=argDef.type;var argumentNode=argNodeMap[name];if(!argumentNode){if(argDef.defaultValue!==undefined){coercedValues[name]=argDef.defaultValue;}else if(isNonNullType(argType)){throw new GraphQLError(\"Argument \\\"\".concat(name,\"\\\" of required type \\\"\").concat(inspect(argType),\"\\\" \")+'was not provided.',node);}continue;}var valueNode=argumentNode.value;var isNull=valueNode.kind===Kind.NULL;if(valueNode.kind===Kind.VARIABLE){var variableName=valueNode.name.value;if(variableValues==null||!hasOwnProperty(variableValues,variableName)){if(argDef.defaultValue!==undefined){coercedValues[name]=argDef.defaultValue;}else if(isNonNullType(argType)){throw new GraphQLError(\"Argument \\\"\".concat(name,\"\\\" of required type \\\"\").concat(inspect(argType),\"\\\" \")+\"was provided the variable \\\"$\".concat(variableName,\"\\\" which was not provided a runtime value.\"),valueNode);}continue;}isNull=variableValues[variableName]==null;}if(isNull&&isNonNullType(argType)){throw new GraphQLError(\"Argument \\\"\".concat(name,\"\\\" of non-null type \\\"\").concat(inspect(argType),\"\\\" \")+'must not be null.',valueNode);}var coercedValue=valueFromAST(valueNode,argType,variableValues);if(coercedValue===undefined){// Note: ValuesOfCorrectType validation should catch this before\n// execution. This is a runtime check to ensure execution does not\n// continue with an invalid argument value.\nthrow new GraphQLError(\"Argument \\\"\".concat(name,\"\\\" has invalid value \").concat(print(valueNode),\".\"),valueNode);}coercedValues[name]=coercedValue;}return coercedValues;}/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */export function getDirectiveValues(directiveDef,node,variableValues){var directiveNode=node.directives&&find(node.directives,function(directive){return directive.name.value===directiveDef.name;});if(directiveNode){return getArgumentValues(directiveDef,directiveNode,variableValues);}}function hasOwnProperty(obj,prop){return Object.prototype.hasOwnProperty.call(obj,prop);}","map":null,"metadata":{},"sourceType":"module"}