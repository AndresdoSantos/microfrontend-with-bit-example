{"ast":null,"code":"\"use strict\";require(\"core-js/modules/es.array.iterator.js\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.TagMap=void 0;function _semverHelper(){const data=require(\"@teambit/legacy/dist/utils/semver-helper\");_semverHelper=function(){return data;};return data;}function _semver(){const data=require(\"semver\");_semver=function(){return data;};return data;}function _exceptions(){const data=require(\"./exceptions\");_exceptions=function(){return data;};return data;}class TagMap extends Map{/**\n   * get snap by hash.\n   */byHash(hash){const tag=Array.from(this.values()).find(currTag=>currTag.hash===hash);return tag;}/**\n   * e.g.\n   * {\n   *   alpha: '1.0.0-alpha.5',\n   *   dev: '2.2.4-dev.37\n   * }\n   */getPreReleaseLatestTags(){const preReleaseTagsWithAllVersions=this.toArray().reduce((acc,current)=>{var _preReleases$;const preReleases=current.version.prerelease;if(!preReleases.length)return acc;if(preReleases.length!==2){// it could be length 1, e.g. 1.0.0-0, we ignore it.\n// it could also be length > 2, e.g. 1.0.0-dev.1.alpha.1, we don't support it for now.\nreturn acc;}if(typeof preReleases[0]!=='string')return acc;(acc[_preReleases$=preReleases[0]]||(acc[_preReleases$]=[])).push(current.version.raw);return acc;},{});return Object.keys(preReleaseTagsWithAllVersions).reduce((acc,current)=>{acc[current]=(0,_semver().maxSatisfying)(preReleaseTagsWithAllVersions[current],'*',{includePrerelease:true});return acc;},{});}/**\n   * Get a map that map snap hash to tag\n   */getHashMap(){const res=new Map();this.forEach(tag=>{res.set(tag.hash,tag);});return res;}/**\n   * get the latest semver from the tag map.\n   */getLatest(){const versions=this.toArray().map(tag=>tag.version.raw);if(this.isEmpty())throw new(_exceptions().CouldNotFindLatest)(versions);return(0,_semverHelper().getLatestVersion)(versions);}isEmpty(){return this.size===0;}/**\n   * get an array of all tags.\n   */toArray(){return Array.from(this.values());}byVersion(version){const versions=this.toArray().map(tag=>tag);return versions.find(tag=>tag.version.raw===version);}static fromArray(tags){const tuples=tags.map(tag=>[tag.version,tag]);return new TagMap(tuples);}static empty(){return new TagMap();}}exports.TagMap=TagMap;","map":null,"metadata":{},"sourceType":"module"}