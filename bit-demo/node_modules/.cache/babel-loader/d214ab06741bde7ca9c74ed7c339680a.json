{"ast":null,"code":"'use strict';Object.defineProperty(exports,\"__esModule\",{value:true});/*!\n * XRegExp.build 4.0.0\n * <xregexp.com>\n * Steven Levithan (c) 2012-2017 MIT License\n */exports.default=function(XRegExp){var REGEX_DATA='xregexp';var subParts=/(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;var parts=XRegExp.union([/\\({{([\\w$]+)}}\\)|{{([\\w$]+)}}/,subParts],'g',{conjunction:'or'});/**\n     * Strips a leading `^` and trailing unescaped `$`, if both are present.\n     *\n     * @private\n     * @param {String} pattern Pattern to process.\n     * @returns {String} Pattern with edge anchors removed.\n     */function deanchor(pattern){// Allow any number of empty noncapturing groups before/after anchors, because regexes\n// built/generated by XRegExp sometimes include them\nvar leadingAnchor=/^(?:\\(\\?:\\))*\\^/;var trailingAnchor=/\\$(?:\\(\\?:\\))*$/;if(leadingAnchor.test(pattern)&&trailingAnchor.test(pattern)&&// Ensure that the trailing `$` isn't escaped\ntrailingAnchor.test(pattern.replace(/\\\\[\\s\\S]/g,''))){return pattern.replace(leadingAnchor,'').replace(trailingAnchor,'');}return pattern;}/**\n     * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.\n     *\n     * @private\n     * @param {String|RegExp} value Value to convert.\n     * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not\n     *   already a regex generated by XRegExp\n     * @returns {RegExp} XRegExp object with XRegExp syntax applied.\n     */function asXRegExp(value,addFlagX){var flags=addFlagX?'x':'';return XRegExp.isRegExp(value)?value[REGEX_DATA]&&value[REGEX_DATA].captureNames?// Don't recompile, to preserve capture names\nvalue:// Recompile as XRegExp\nXRegExp(value.source,flags):// Compile string as XRegExp\nXRegExp(value,flags);}function interpolate(substitution){return substitution instanceof RegExp?substitution:XRegExp.escape(substitution);}function reduceToSubpatternsObject(subpatterns,interpolated,subpatternIndex){subpatterns['subpattern'+subpatternIndex]=interpolated;return subpatterns;}function embedSubpatternAfter(raw,subpatternIndex,rawLiterals){var hasSubpattern=subpatternIndex<rawLiterals.length-1;return raw+(hasSubpattern?'{{subpattern'+subpatternIndex+'}}':'');}/**\n     * Provides tagged template literals that create regexes with XRegExp syntax and flags. The\n     * provided pattern is handled as a raw string, so backslashes don't need to be escaped.\n     *\n     * Interpolation of strings and regexes shares the features of `XRegExp.build`. Interpolated\n     * patterns are treated as atomic units when quantified, interpolated strings have their special\n     * characters escaped, a leading `^` and trailing unescaped `$` are stripped from interpolated\n     * regexes if both are present, and any backreferences within an interpolated regex are\n     * rewritten to work within the overall pattern.\n     *\n     * @memberOf XRegExp\n     * @param {String} [flags] Any combination of XRegExp flags.\n     * @returns {Function} Handler for template literals that construct regexes with XRegExp syntax.\n     * @example\n     *\n     * const h12 = /1[0-2]|0?[1-9]/;\n     * const h24 = /2[0-3]|[01][0-9]/;\n     * const hours = XRegExp.tag('x')`${h12} : | ${h24}`;\n     * const minutes = /^[0-5][0-9]$/;\n     * // Note that explicitly naming the 'minutes' group is required for named backreferences\n     * const time = XRegExp.tag('x')`^ ${hours} (?<minutes>${minutes}) $`;\n     * time.test('10:59'); // -> true\n     * XRegExp.exec('10:59', time).minutes; // -> '59'\n     */XRegExp.tag=function(flags){return function(literals){for(var _len=arguments.length,substitutions=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){substitutions[_key-1]=arguments[_key];}var subpatterns=substitutions.map(interpolate).reduce(reduceToSubpatternsObject,{});var pattern=literals.raw.map(embedSubpatternAfter).join('');return XRegExp.build(pattern,subpatterns,flags);};};/**\n     * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in\n     * the outer pattern and provided subpatterns are automatically renumbered to work correctly.\n     * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.\n     *\n     * @memberOf XRegExp\n     * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows\n     *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within\n     *   character classes.\n     * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A\n     *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.\n     * @param {String} [flags] Any combination of XRegExp flags.\n     * @returns {RegExp} Regex with interpolated subpatterns.\n     * @example\n     *\n     * const time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {\n     *   hours: XRegExp.build('{{h12}} : | {{h24}}', {\n     *     h12: /1[0-2]|0?[1-9]/,\n     *     h24: /2[0-3]|[01][0-9]/\n     *   }, 'x'),\n     *   minutes: /^[0-5][0-9]$/\n     * });\n     * time.test('10:59'); // -> true\n     * XRegExp.exec('10:59', time).minutes; // -> '59'\n     */XRegExp.build=function(pattern,subs,flags){flags=flags||'';// Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how\n// some browsers convert `RegExp('\\n')` to a regex that contains the literal characters `\\`\n// and `n`. See more details at <https://github.com/slevithan/xregexp/pull/163>.\nvar addFlagX=flags.indexOf('x')!==-1;var inlineFlags=/^\\(\\?([\\w$]+)\\)/.exec(pattern);// Add flags within a leading mode modifier to the overall pattern's flags\nif(inlineFlags){flags=XRegExp._clipDuplicates(flags+inlineFlags[1]);}var data={};for(var p in subs){if(subs.hasOwnProperty(p)){// Passing to XRegExp enables extended syntax and ensures independent validity,\n// lest an unescaped `(`, `)`, `[`, or trailing `\\` breaks the `(?:)` wrapper. For\n// subpatterns provided as native regexes, it dies on octals and adds the property\n// used to hold extended regex instance data, for simplicity.\nvar sub=asXRegExp(subs[p],addFlagX);data[p]={// Deanchoring allows embedding independently useful anchored regexes. If you\n// really need to keep your anchors, double them (i.e., `^^...$$`).\npattern:deanchor(sub.source),names:sub[REGEX_DATA].captureNames||[]};}}// Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;\n// helps keep this simple. Named captures will be put back.\nvar patternAsRegex=asXRegExp(pattern,addFlagX);// 'Caps' is short for 'captures'\nvar numCaps=0;var numPriorCaps=void 0;var numOuterCaps=0;var outerCapsMap=[0];var outerCapNames=patternAsRegex[REGEX_DATA].captureNames||[];var output=patternAsRegex.source.replace(parts,function($0,$1,$2,$3,$4){var subName=$1||$2;var capName=void 0;var intro=void 0;var localCapIndex=void 0;// Named subpattern\nif(subName){if(!data.hasOwnProperty(subName)){throw new ReferenceError('Undefined property '+$0);}// Named subpattern was wrapped in a capturing group\nif($1){capName=outerCapNames[numOuterCaps];outerCapsMap[++numOuterCaps]=++numCaps;// If it's a named group, preserve the name. Otherwise, use the subpattern name\n// as the capture name\nintro='(?<'+(capName||subName)+'>';}else{intro='(?:';}numPriorCaps=numCaps;var rewrittenSubpattern=data[subName].pattern.replace(subParts,function(match,paren,backref){// Capturing group\nif(paren){capName=data[subName].names[numCaps-numPriorCaps];++numCaps;// If the current capture has a name, preserve the name\nif(capName){return'(?<'+capName+'>';}// Backreference\n}else if(backref){localCapIndex=+backref-1;// Rewrite the backreference\nreturn data[subName].names[localCapIndex]?// Need to preserve the backreference name in case using flag `n`\n'\\\\k<'+data[subName].names[localCapIndex]+'>':'\\\\'+(+backref+numPriorCaps);}return match;});return''+intro+rewrittenSubpattern+')';}// Capturing group\nif($3){capName=outerCapNames[numOuterCaps];outerCapsMap[++numOuterCaps]=++numCaps;// If the current capture has a name, preserve the name\nif(capName){return'(?<'+capName+'>';}// Backreference\n}else if($4){localCapIndex=+$4-1;// Rewrite the backreference\nreturn outerCapNames[localCapIndex]?// Need to preserve the backreference name in case using flag `n`\n'\\\\k<'+outerCapNames[localCapIndex]+'>':'\\\\'+outerCapsMap[+$4];}return $0;});return XRegExp(output,flags);};};module.exports=exports['default'];","map":null,"metadata":{},"sourceType":"module"}