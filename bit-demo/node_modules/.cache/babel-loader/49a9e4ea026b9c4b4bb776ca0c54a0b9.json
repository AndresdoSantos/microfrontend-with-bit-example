{"ast":null,"code":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:true});exports.State=void 0;function _componentIssues(){const data=require(\"@teambit/component-issues\");_componentIssues=function(){return data;};return data;}function _componentId(){const data=require(\"@teambit/component-id\");_componentId=function(){return data;};return data;}function _exceptions(){const data=require(\"./exceptions\");_exceptions=function(){return data;};return data;}class State{constructor(/**\n   * component configuration which is later generated to a component `package.json` and `bit.json`.\n   * @deprecated please use `aspects` instead.\n   */config,/**\n   * list of aspects configured on the component.\n   */_aspects,/**\n   * in-memory representation of the component current filesystem.\n   */filesystem,/**\n   * dependency graph of the component current. ideally package dependencies would be also placed here.\n   */ // readonly dependencies: Dependencies\ndependencies,/**\n   * instance of legacy consumer component.\n   */_consumer){this.config=config;this._aspects=_aspects;this.filesystem=filesystem;this.dependencies=dependencies;this._consumer=_consumer;}/**\n   * get the main file of the component.\n   */get mainFile(){const file=this.filesystem.files.find(componentFile=>{return componentFile.relative===this._consumer.mainFile;});if(!file)throw new(_exceptions().MainFileNotFound)(_componentId().ComponentID.fromLegacy(this._consumer.id),this._consumer.mainFile);return file;}/**\n   * calculate the hash of this state\n   */get hash(){return'';}get issues(){var _this$_consumer;return(_this$_consumer=this._consumer).issues||(_this$_consumer.issues=new(_componentIssues().IssuesList)());}/**\n   * @deprecated please use `component.isModified`.\n   * the way it's implemented here is unreliable and will only work if in the legacy the \"isModified\" was calculated.\n   */get isModified(){return this._consumer._isModified;}get aspects(){return this._aspects;}set aspects(aspects){this._aspects=aspects;}// static fromLegacy(consumerComponent: ConsumerComponent) {\n//   return new State(\n//     new Config(consumerComponent.mainFile, consumerComponent.extensions),\n//     consumerComponent.version || 'new',\n//     ComponentFS.fromVinyls(consumerComponent.files),\n//     Store.fromArray([]),\n//     consumerComponent.dependencies,\n//     consumerComponent\n//   );\n// }\n}exports.State=State;","map":null,"metadata":{},"sourceType":"module"}