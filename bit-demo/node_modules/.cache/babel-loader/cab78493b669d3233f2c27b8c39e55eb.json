{"ast":null,"code":"function _typeof(obj){if(typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};}return _typeof(obj);}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}import RelativeTimeFormat from'relative-time-format';import Cache from'./cache';import grade from'./grade';import chooseLocale from'./locale';import{twitterStyle,timeStyle,defaultStyle}from'./style';import{addLocaleData,getLocaleData as _getLocaleData}from'./LocaleDataStore';// const EXTRA_STYLES = [\n// \t'long-convenient',\n// \t'long-time',\n// \t'short-convenient',\n// \t'short-time',\n// \t'tiny'\n// ]\n// Valid time units.\nvar UNITS=['now',// The rest are the same as in `Intl.RelativeTimeFormat`.\n'second','minute','hour','day','week','month','quarter','year'];var JavascriptTimeAgo=/*#__PURE__*/function(){/**\r\n   * @param {(string|string[])} locales=[] - Preferred locales (or locale).\r\n   */function JavascriptTimeAgo(){var locales=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];_classCallCheck(this,JavascriptTimeAgo);// Convert `locales` to an array.\nif(typeof locales==='string'){locales=[locales];}// Choose the most appropriate locale\n// (one of the previously added ones)\n// based on the list of preferred `locales` supplied by the user.\nthis.locale=chooseLocale(locales.concat(RelativeTimeFormat.getDefaultLocale()),_getLocaleData);// Use `Intl.NumberFormat` for formatting numbers (when available).\nif(typeof Intl!=='undefined'&&Intl.NumberFormat){this.numberFormat=new Intl.NumberFormat(this.locale);}// Cache `Intl.RelativeTimeFormat` instance.\nthis.relativeTimeFormatCache=new Cache();}// Formats the relative date/time.\n//\n// @return {string} Returns the formatted relative date/time.\n//\n// @param {(Object|string)} [style] - Relative date/time formatting style.\n//\n// @param {string[]} [style.units] - A list of allowed time units\n//                                  (e.g. ['second', 'minute', 'hour', …])\n//\n// @param {Function} [style.custom] - `function ({ elapsed, time, date, now })`.\n//                                    If this function returns a value, then\n//                                    the `.format()` call will return that value.\n//                                    Otherwise it has no effect.\n//\n// @param {string} [style.flavour] - e.g. \"long\", \"short\", \"tiny\", etc.\n//\n// @param {Object[]} [style.gradation] - Time scale gradation steps.\n//\n// @param {string} style.gradation[].unit - Time interval measurement unit.\n//                                          (e.g. ['second', 'minute', 'hour', …])\n//\n// @param {Number} style.gradation[].factor - Time interval measurement unit factor.\n//                                            (e.g. `60` for 'minute')\n//\n// @param {Number} [style.gradation[].granularity] - A step for the unit's \"amount\" value.\n//                                                   (e.g. `5` for '0 minutes', '5 minutes', etc)\n//\n// @param {Number} [style.gradation[].threshold] - Time interval measurement unit threshold.\n//                                                 (e.g. `45` seconds for 'minute').\n//                                                 There can also be specific `threshold_[unit]`\n//                                                 thresholds for fine-tuning.\n//\n_createClass(JavascriptTimeAgo,[{key:\"format\",value:function format(input){var style=arguments.length>1&&arguments[1]!==undefined?arguments[1]:defaultStyle;if(typeof style==='string'){switch(style){case'twitter':style=twitterStyle;break;case'time':style=timeStyle;break;default:style=defaultStyle;}}var _getDateAndTimeBeingF=getDateAndTimeBeingFormatted(input),date=_getDateAndTimeBeingF.date,time=_getDateAndTimeBeingF.time;// Get locale messages for this formatting flavour\nvar _this$getLocaleData=this.getLocaleData(style.flavour),flavour=_this$getLocaleData.flavour,localeData=_this$getLocaleData.localeData;// Can pass a custom `now`, e.g. for testing purposes.\n// Technically it doesn't belong to `style`\n// but since this is an undocumented internal feature,\n// taking it from the `style` argument will do (for now).\nvar now=style.now||Date.now();// how much time elapsed (in seconds)\nvar elapsed=(now-time)/1000;// in seconds\n// `custom` – A function of `{ elapsed, time, date, now, locale }`.\n// If this function returns a value, then the `.format()` call will return that value.\n// Otherwise the relative date/time is formatted as usual.\n// This feature is currently not used anywhere and is here\n// just for providing the ultimate customization point\n// in case anyone would ever need that. Prefer using\n// `gradation[step].format(value, locale)` instead.\n//\n// I guess `custom` is deprecated and will be removed\n// in some future major version release.\n//\nif(style.custom){var custom=style.custom({now:now,date:date,time:time,elapsed:elapsed,locale:this.locale});if(custom!==undefined){return custom;}}// Available time interval measurement units.\nvar units=getTimeIntervalMeasurementUnits(localeData,style.units);// If no available time unit is suitable, just output an empty string.\nif(units.length===0){console.error(\"Units \\\"\".concat(units.join(', '),\"\\\" were not found in locale data for \\\"\").concat(this.locale,\"\\\".\"));return'';}// Choose the appropriate time measurement unit\n// and get the corresponding rounded time amount.\nvar step=grade(elapsed,now,units,style.gradation);// If no time unit is suitable, just output an empty string.\n// E.g. when \"now\" unit is not available\n// and \"second\" has a threshold of `0.5`\n// (e.g. the \"canonical\" grading scale).\nif(!step){return'';}if(step.format){return step.format(date||time,this.locale);}var unit=step.unit,factor=step.factor,granularity=step.granularity;var amount=Math.abs(elapsed)/factor;// Apply granularity to the time amount\n// (and fallback to the previous step\n//  if the first level of granularity\n//  isn't met by this amount)\nif(granularity){// Recalculate the elapsed time amount based on granularity\namount=Math.round(amount/granularity)*granularity;}// `Intl.RelativeTimeFormat` doesn't operate in \"now\" units.\nif(unit==='now'){return getNowMessage(localeData,-1*Math.sign(elapsed));}switch(flavour){case'long':case'short':case'narrow':// Format `value` using `Intl.RelativeTimeFormat`.\nreturn this.getFormatter(flavour).format(-1*Math.sign(elapsed)*Math.round(amount),unit);default:// Format `value`.\n// (mimicks `Intl.RelativeTimeFormat` with the addition of extra styles)\nreturn this.formatValue(-1*Math.sign(elapsed)*Math.round(amount),unit,localeData);}}/**\r\n     * Mimicks what `Intl.RelativeTimeFormat` does for additional locale styles.\r\n     * @param  {number} value\r\n     * @param  {string} unit\r\n     * @param  {object} localeData — Relative time messages for the flavor.\r\n     * @return {string}\r\n     */},{key:\"formatValue\",value:function formatValue(value,unit,localeData){return this.getRule(value,unit,localeData).replace('{0}',this.formatNumber(Math.abs(value)));}/**\r\n     * Returns formatting rule for `value` in `units` (either in past or in future).\r\n     * @param {number} value - Time interval value.\r\n     * @param {string} unit - Time interval measurement unit.\r\n     * @param  {object} localeData — Relative time messages for the flavor.\r\n     * @return {string}\r\n     * @example\r\n     * // Returns \"{0} days ago\"\r\n     * getRule(-2, \"day\")\r\n     */},{key:\"getRule\",value:function getRule(value,unit,localeData){var unitRules=localeData[unit];// Bundle size optimization technique.\nif(typeof unitRules==='string'){return unitRules;}// Choose either \"past\" or \"future\" based on time `value` sign.\n// If \"past\" is same as \"future\" then they're stored as \"other\".\n// If there's only \"other\" then it's being collapsed.\nvar quantifierRules=unitRules[value<=0?'past':'future']||unitRules;// Bundle size optimization technique.\nif(typeof quantifierRules==='string'){return quantifierRules;}// Quantify `value`.\nvar quantify=_getLocaleData(this.locale).quantify;var quantifier=quantify&&quantify(Math.abs(value));// There seems to be no such locale in CLDR\n// for which `quantify` is missing\n// and still `past` and `future` messages\n// contain something other than \"other\".\n/* istanbul ignore next */quantifier=quantifier||'other';// \"other\" rule is supposed to always be present.\n// If only \"other\" rule is present then \"rules\" is not an object and is a string.\nreturn quantifierRules[quantifier]||quantifierRules.other;}/**\r\n     * Formats a number into a string.\r\n     * Uses `Intl.NumberFormat` when available.\r\n     * @param  {number} number\r\n     * @return {string}\r\n     */},{key:\"formatNumber\",value:function formatNumber(number){return this.numberFormat?this.numberFormat.format(number):String(number);}/**\r\n     * Returns an `Intl.RelativeTimeFormat` for a given `flavor`.\r\n     * @param {string} flavor\r\n     * @return {object} `Intl.RelativeTimeFormat` instance\r\n     */},{key:\"getFormatter\",value:function getFormatter(flavor){// `Intl.RelativeTimeFormat` instance creation is assumed a\n// lengthy operation so the instances are cached and reused.\nreturn this.relativeTimeFormatCache.get(this.locale,flavor)||this.relativeTimeFormatCache.put(this.locale,flavor,new RelativeTimeFormat(this.locale,{style:flavor}));}/**\r\n     * Gets locale messages for this formatting flavour\r\n     *\r\n     * @param {(string|string[])} flavour - Relative date/time formatting flavour.\r\n     *                                      If it's an array then all flavours are tried in order.\r\n     *\r\n     * @returns {Object} Returns an object of shape { flavour, localeData }\r\n     */},{key:\"getLocaleData\",value:function getLocaleData(){var flavour=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];// Get relative time formatting rules for this locale\nvar localeData=_getLocaleData(this.locale);// Convert `flavour` to an array.\nif(typeof flavour==='string'){flavour=[flavour];}// \"long\" flavour is the default one.\n// (it's always present)\nflavour=flavour.concat('long');// Find a suitable flavour.\nfor(var _iterator=flavour,_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var _=_ref;if(localeData[_]){return{flavour:_,localeData:localeData[_]};}}// Can't happen - \"long\" flavour is always present.\n// throw new Error(`None of the flavours - ${flavour.join(', ')} - was found for locale \"${this.locale}\".`)\n}}]);return JavascriptTimeAgo;}();/**\r\n * Gets default locale.\r\n * @return  {string} locale\r\n */export{JavascriptTimeAgo as default};JavascriptTimeAgo.getDefaultLocale=RelativeTimeFormat.getDefaultLocale;/**\r\n * Sets default locale.\r\n * @param  {string} locale\r\n */JavascriptTimeAgo.setDefaultLocale=RelativeTimeFormat.setDefaultLocale;/**\r\n * Adds locale data for a specific locale.\r\n * @param {Object} localeData\r\n */JavascriptTimeAgo.addLocale=function(localeData){addLocaleData(localeData);RelativeTimeFormat.addLocale(localeData);};/**\r\n * (legacy alias)\r\n * Adds locale data for a specific locale.\r\n * @param {Object} localeData\r\n * @deprecated\r\n */JavascriptTimeAgo.locale=JavascriptTimeAgo.addLocale;// Normalizes `.format()` `time` argument.\nfunction getDateAndTimeBeingFormatted(input){if(input.constructor===Date||isMockedDate(input)){return{date:input,time:input.getTime()};}if(typeof input==='number'){return{time:input// `date` is not required for formatting\n// relative times unless \"twitter\" preset is used.\n// date : new Date(input)\n};}// For some weird reason istanbul doesn't see this `throw` covered.\n/* istanbul ignore next */throw new Error(\"Unsupported relative time formatter input: \".concat(_typeof(input),\", \").concat(input));}// During testing via some testing libraries `Date`s aren't actually `Date`s.\n// https://github.com/catamphetamine/javascript-time-ago/issues/22\nfunction isMockedDate(object){return _typeof(object)==='object'&&typeof object.getTime==='function';}// Get available time interval measurement units.\nfunction getTimeIntervalMeasurementUnits(localeData,restrictedSetOfUnits){// All available time interval measurement units.\nvar units=Object.keys(localeData);// If only a specific set of available\n// time measurement units can be used.\nif(restrictedSetOfUnits){// Reduce available time interval measurement units\n// based on user's preferences.\nunits=restrictedSetOfUnits.filter(function(_){return units.indexOf(_)>=0;});}// Stock `Intl.RelativeTimeFormat` locale data doesn't have \"now\" units.\n// So either \"now\" is present in extended locale data\n// or it's taken from \".second.current\".\nif((!restrictedSetOfUnits||restrictedSetOfUnits.indexOf('now')>=0)&&units.indexOf('now')<0){if(localeData.second.current){units.unshift('now');}}return units;}function getNowMessage(localeData,value){// Specific \"now\" message form extended locale data (if present).\nif(localeData.now){// Bundle size optimization technique.\nif(typeof localeData.now==='string'){return localeData.now;}// Not handling `value === 0` as `localeData.now.current` here\n// because it wouldn't make sense: \"now\" is a moment,\n// so one can't possibly differentiate between a\n// \"previous\" moment, a \"current\" moment and a \"next moment\".\n// It can only be differentiated between \"past\" and \"future\".\nif(value<=0){return localeData.now.past;}else{return localeData.now.future;}}// Use \".second.current\" as \"now\" message.\nreturn localeData.second.current;// If this function was called then\n// it means that either \"now\" unit messages are\n// available or \".second.current\" message is present.\n}","map":null,"metadata":{},"sourceType":"module"}