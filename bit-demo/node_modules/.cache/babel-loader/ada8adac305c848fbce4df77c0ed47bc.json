{"ast":null,"code":"import find from'../polyfills/find';import objectValues from'../polyfills/objectValues';import inspect from'../jsutils/inspect';import toObjMap from'../jsutils/toObjMap';import devAssert from'../jsutils/devAssert';import instanceOf from'../jsutils/instanceOf';import isObjectLike from'../jsutils/isObjectLike';import defineToStringTag from'../jsutils/defineToStringTag';import{__Schema}from'./introspection';import{GraphQLDirective,isDirective,specifiedDirectives}from'./directives';import{isObjectType,isInterfaceType,isUnionType,isInputObjectType,getNamedType}from'./definition';/**\n * Test if the given value is a GraphQL schema.\n */ // eslint-disable-next-line no-redeclare\nexport function isSchema(schema){return instanceOf(schema,GraphQLSchema);}export function assertSchema(schema){if(!isSchema(schema)){throw new Error(\"Expected \".concat(inspect(schema),\" to be a GraphQL schema.\"));}return schema;}/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n *     const characterInterface = new GraphQLInterfaceType({\n *       name: 'Character',\n *       ...\n *     });\n *\n *     const humanType = new GraphQLObjectType({\n *       name: 'Human',\n *       interfaces: [characterInterface],\n *       ...\n *     });\n *\n *     const droidType = new GraphQLObjectType({\n *       name: 'Droid',\n *       interfaces: [characterInterface],\n *       ...\n *     });\n *\n *     const schema = new GraphQLSchema({\n *       query: new GraphQLObjectType({\n *         name: 'Query',\n *         fields: {\n *           hero: { type: characterInterface, ... },\n *         }\n *       }),\n *       ...\n *       // Since this schema references only the `Character` interface it's\n *       // necessary to explicitly list the types that implement it if\n *       // you want them to be included in the final schema.\n *       types: [humanType, droidType],\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */export var GraphQLSchema=/*#__PURE__*/function(){// Used as a cache for validateSchema().\n// Referenced by validateSchema().\nfunction GraphQLSchema(config){// If this schema was built from a source known to be valid, then it may be\n// marked with assumeValid to avoid an additional type system validation.\nif(config&&config.assumeValid){this.__validationErrors=[];}else{this.__validationErrors=undefined;// Otherwise check for common mistakes during construction to produce\n// clear and early error messages.\nisObjectLike(config)||devAssert(0,'Must provide configuration object.');!config.types||Array.isArray(config.types)||devAssert(0,\"\\\"types\\\" must be Array if provided but got: \".concat(inspect(config.types),\".\"));!config.directives||Array.isArray(config.directives)||devAssert(0,'\"directives\" must be Array if provided but got: '+\"\".concat(inspect(config.directives),\".\"));!config.allowedLegacyNames||Array.isArray(config.allowedLegacyNames)||devAssert(0,'\"allowedLegacyNames\" must be Array if provided but got: '+\"\".concat(inspect(config.allowedLegacyNames),\".\"));}this.extensions=config.extensions&&toObjMap(config.extensions);this.astNode=config.astNode;this.extensionASTNodes=config.extensionASTNodes;this.__allowedLegacyNames=config.allowedLegacyNames||[];this._queryType=config.query;this._mutationType=config.mutation;this._subscriptionType=config.subscription;// Provide specified directives (e.g. @include and @skip) by default.\nthis._directives=config.directives||specifiedDirectives;// Build type map now to detect any errors within this schema.\nvar initialTypes=[this._queryType,this._mutationType,this._subscriptionType,__Schema].concat(config.types);// Keep track of all types referenced within the schema.\nvar typeMap=Object.create(null);// First by deeply visiting all initial types.\ntypeMap=initialTypes.reduce(typeMapReducer,typeMap);// Then by deeply visiting all directive types.\ntypeMap=this._directives.reduce(typeMapDirectiveReducer,typeMap);// Storing the resulting map for reference by the schema.\nthis._typeMap=typeMap;this._possibleTypeMap=Object.create(null);// Keep track of all implementations by interface name.\nthis._implementations=Object.create(null);for(var _i2=0,_objectValues2=objectValues(this._typeMap);_i2<_objectValues2.length;_i2++){var type=_objectValues2[_i2];if(isObjectType(type)){for(var _i4=0,_type$getInterfaces2=type.getInterfaces();_i4<_type$getInterfaces2.length;_i4++){var iface=_type$getInterfaces2[_i4];if(isInterfaceType(iface)){var impls=this._implementations[iface.name];if(impls){impls.push(type);}else{this._implementations[iface.name]=[type];}}}}}}var _proto=GraphQLSchema.prototype;_proto.getQueryType=function getQueryType(){return this._queryType;};_proto.getMutationType=function getMutationType(){return this._mutationType;};_proto.getSubscriptionType=function getSubscriptionType(){return this._subscriptionType;};_proto.getTypeMap=function getTypeMap(){return this._typeMap;};_proto.getType=function getType(name){return this.getTypeMap()[name];};_proto.getPossibleTypes=function getPossibleTypes(abstractType){if(isUnionType(abstractType)){return abstractType.getTypes();}return this._implementations[abstractType.name]||[];};_proto.isPossibleType=function isPossibleType(abstractType,possibleType){if(this._possibleTypeMap[abstractType.name]==null){var map=Object.create(null);for(var _i6=0,_this$getPossibleType2=this.getPossibleTypes(abstractType);_i6<_this$getPossibleType2.length;_i6++){var type=_this$getPossibleType2[_i6];map[type.name]=true;}this._possibleTypeMap[abstractType.name]=map;}return Boolean(this._possibleTypeMap[abstractType.name][possibleType.name]);};_proto.getDirectives=function getDirectives(){return this._directives;};_proto.getDirective=function getDirective(name){return find(this.getDirectives(),function(directive){return directive.name===name;});};_proto.toConfig=function toConfig(){return{query:this.getQueryType(),mutation:this.getMutationType(),subscription:this.getSubscriptionType(),types:objectValues(this.getTypeMap()),directives:this.getDirectives().slice(),extensions:this.extensions,astNode:this.astNode,extensionASTNodes:this.extensionASTNodes||[],assumeValid:this.__validationErrors!==undefined,allowedLegacyNames:this.__allowedLegacyNames};};return GraphQLSchema;}();// Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\ndefineToStringTag(GraphQLSchema);function typeMapReducer(map,type){if(!type){return map;}var namedType=getNamedType(type);var seenType=map[namedType.name];if(seenType){if(seenType!==namedType){throw new Error(\"Schema must contain uniquely named types but contains multiple types named \\\"\".concat(namedType.name,\"\\\".\"));}return map;}map[namedType.name]=namedType;var reducedMap=map;if(isUnionType(namedType)){reducedMap=namedType.getTypes().reduce(typeMapReducer,reducedMap);}if(isObjectType(namedType)){reducedMap=namedType.getInterfaces().reduce(typeMapReducer,reducedMap);}if(isObjectType(namedType)||isInterfaceType(namedType)){for(var _i8=0,_objectValues4=objectValues(namedType.getFields());_i8<_objectValues4.length;_i8++){var field=_objectValues4[_i8];var fieldArgTypes=field.args.map(function(arg){return arg.type;});reducedMap=fieldArgTypes.reduce(typeMapReducer,reducedMap);reducedMap=typeMapReducer(reducedMap,field.type);}}if(isInputObjectType(namedType)){for(var _i10=0,_objectValues6=objectValues(namedType.getFields());_i10<_objectValues6.length;_i10++){var _field=_objectValues6[_i10];reducedMap=typeMapReducer(reducedMap,_field.type);}}return reducedMap;}function typeMapDirectiveReducer(map,directive){// Directives are not validated until validateSchema() is called.\nif(!isDirective(directive)){return map;}return directive.args.reduce(function(_map,arg){return typeMapReducer(_map,arg.type);},map);}","map":null,"metadata":{},"sourceType":"module"}