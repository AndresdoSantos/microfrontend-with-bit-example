{"ast":null,"code":"'use strict';Object.defineProperty(exports,\"__esModule\",{value:true});/*!\n * XRegExp 4.0.0\n * <xregexp.com>\n * Steven Levithan (c) 2007-2017 MIT License\n */ /**\n * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and\n * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to\n * make your client-side grepping simpler and more powerful, while freeing you from related\n * cross-browser inconsistencies.\n */ // ==--------------------------==\n// Private stuff\n// ==--------------------------==\n// Property name used for extended regex instance data\nvar REGEX_DATA='xregexp';// Optional features that can be installed and uninstalled\nvar features={astral:false};// Native methods to use and restore ('native' is an ES3 reserved keyword)\nvar nativ={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split};// Storage for fixed/extended native methods\nvar fixed={};// Storage for regexes cached by `XRegExp.cache`\nvar regexCache={};// Storage for pattern details cached by the `XRegExp` constructor\nvar patternCache={};// Storage for regex syntax tokens added internally or by `XRegExp.addToken`\nvar tokens=[];// Token scopes\nvar defaultScope='default';var classScope='class';// Regexes that match native regex syntax, including octals\nvar nativeTokens={// Any native multicharacter token in default scope, or any single character\n'default':/\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|\\(\\?(?:[:=!]|<[=!])|[?*+]\\?|{\\d+(?:,\\d*)?}\\??|[\\s\\S]/,// Any native multicharacter token in character class scope, or any single character\n'class':/\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|[\\s\\S]/};// Any backreference or dollar-prefixed character in replacement strings\nvar replacementToken=/\\$(?:{([\\w$]+)}|<([\\w$]+)>|(\\d\\d?|[\\s\\S]))/g;// Check for correct `exec` handling of nonparticipating capturing groups\nvar correctExecNpcg=nativ.exec.call(/()??/,'')[1]===undefined;// Check for ES6 `flags` prop support\nvar hasFlagsProp=/x/.flags!==undefined;// Shortcut to `Object.prototype.toString`\nvar toString={}.toString;function hasNativeFlag(flag){// Can't check based on the presence of properties/getters since browsers might support such\n// properties even when they don't support the corresponding flag in regex construction (tested\n// in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`\n// throws an error)\nvar isSupported=true;try{// Can't use regex literals for testing even in a `try` because regex literals with\n// unsupported flags cause a compilation error in IE\nnew RegExp('',flag);}catch(exception){isSupported=false;}return isSupported;}// Check for ES6 `u` flag support\nvar hasNativeU=hasNativeFlag('u');// Check for ES6 `y` flag support\nvar hasNativeY=hasNativeFlag('y');// Tracker for known flags, including addon flags\nvar registeredFlags={g:true,i:true,m:true,u:hasNativeU,y:hasNativeY};/**\n * Attaches extended data and `XRegExp.prototype` properties to a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to augment.\n * @param {Array} captureNames Array with capture names, or `null`.\n * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.\n * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.\n * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal\n *   operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *   skipping some operations like attaching `XRegExp.prototype` properties.\n * @returns {RegExp} Augmented regex.\n */function augment(regex,captureNames,xSource,xFlags,isInternalOnly){var p=void 0;regex[REGEX_DATA]={captureNames:captureNames};if(isInternalOnly){return regex;}// Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value\nif(regex.__proto__){regex.__proto__=XRegExp.prototype;}else{for(p in XRegExp.prototype){// An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this\n// is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`\n// extensions exist on `regex.prototype` anyway\nregex[p]=XRegExp.prototype[p];}}regex[REGEX_DATA].source=xSource;// Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order\nregex[REGEX_DATA].flags=xFlags?xFlags.split('').sort().join(''):xFlags;return regex;}/**\n * Removes any duplicate characters from the provided string.\n *\n * @private\n * @param {String} str String to remove duplicate characters from.\n * @returns {String} String with any duplicate characters removed.\n */function clipDuplicates(str){return nativ.replace.call(str,/([\\s\\S])(?=[\\s\\S]*\\1)/g,'');}/**\n * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`\n * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing\n * flags g and y while copying the regex.\n *\n * @private\n * @param {RegExp} regex Regex to copy.\n * @param {Object} [options] Options object with optional properties:\n *   - `addG` {Boolean} Add flag g while copying the regex.\n *   - `addY` {Boolean} Add flag y while copying the regex.\n *   - `removeG` {Boolean} Remove flag g while copying the regex.\n *   - `removeY` {Boolean} Remove flag y while copying the regex.\n *   - `isInternalOnly` {Boolean} Whether the copied regex will be used only for internal\n *     operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *     skipping some operations like attaching `XRegExp.prototype` properties.\n *   - `source` {String} Overrides `<regex>.source`, for special cases.\n * @returns {RegExp} Copy of the provided regex, possibly with modified flags.\n */function copyRegex(regex,options){if(!XRegExp.isRegExp(regex)){throw new TypeError('Type RegExp expected');}var xData=regex[REGEX_DATA]||{};var flags=getNativeFlags(regex);var flagsToAdd='';var flagsToRemove='';var xregexpSource=null;var xregexpFlags=null;options=options||{};if(options.removeG){flagsToRemove+='g';}if(options.removeY){flagsToRemove+='y';}if(flagsToRemove){flags=nativ.replace.call(flags,new RegExp('['+flagsToRemove+']+','g'),'');}if(options.addG){flagsToAdd+='g';}if(options.addY){flagsToAdd+='y';}if(flagsToAdd){flags=clipDuplicates(flags+flagsToAdd);}if(!options.isInternalOnly){if(xData.source!==undefined){xregexpSource=xData.source;}// null or undefined; don't want to add to `flags` if the previous value was null, since\n// that indicates we're not tracking original precompilation flags\nif(xData.flags!=null){// Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never\n// removed for non-internal regexes, so don't need to handle it\nxregexpFlags=flagsToAdd?clipDuplicates(xData.flags+flagsToAdd):xData.flags;}}// Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid\n// searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and\n// unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the\n// translation to native regex syntax\nregex=augment(new RegExp(options.source||regex.source,flags),hasNamedCapture(regex)?xData.captureNames.slice(0):null,xregexpSource,xregexpFlags,options.isInternalOnly);return regex;}/**\n * Converts hexadecimal to decimal.\n *\n * @private\n * @param {String} hex\n * @returns {Number}\n */function dec(hex){return parseInt(hex,16);}/**\n * Returns a pattern that can be used in a native RegExp in place of an ignorable token such as an\n * inline comment or whitespace with flag x. This is used directly as a token handler function\n * passed to `XRegExp.addToken`.\n *\n * @private\n * @param {String} match Match arg of `XRegExp.addToken` handler\n * @param {String} scope Scope arg of `XRegExp.addToken` handler\n * @param {String} flags Flags arg of `XRegExp.addToken` handler\n * @returns {String} Either '' or '(?:)', depending on which is needed in the context of the match.\n */function getContextualTokenSeparator(match,scope,flags){if(// No need to separate tokens if at the beginning or end of a group\nmatch.input[match.index-1]==='('||match.input[match.index+match[0].length]===')'||// Avoid separating tokens when the following token is a quantifier\nisQuantifierNext(match.input,match.index+match[0].length,flags)){return'';}// Keep tokens separated. This avoids e.g. inadvertedly changing `\\1 1` or `\\1(?#)1` to `\\11`.\n// This also ensures all tokens remain as discrete atoms, e.g. it avoids converting the syntax\n// error `(? :` into `(?:`.\nreturn'(?:)';}/**\n * Returns native `RegExp` flags used by a regex object.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {String} Native flags in use.\n */function getNativeFlags(regex){return hasFlagsProp?regex.flags:// Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation\n// with an empty string) allows this to continue working predictably when\n// `XRegExp.proptotype.toString` is overridden\nnativ.exec.call(/\\/([a-z]*)$/i,RegExp.prototype.toString.call(regex))[1];}/**\n * Determines whether a regex has extended instance data used to track capture names.\n *\n * @private\n * @param {RegExp} regex Regex to check.\n * @returns {Boolean} Whether the regex uses named capture.\n */function hasNamedCapture(regex){return!!(regex[REGEX_DATA]&&regex[REGEX_DATA].captureNames);}/**\n * Converts decimal to hexadecimal.\n *\n * @private\n * @param {Number|String} dec\n * @returns {String}\n */function hex(dec){return parseInt(dec,10).toString(16);}/**\n * Checks whether the next nonignorable token after the specified position is a quantifier.\n *\n * @private\n * @param {String} pattern Pattern to search within.\n * @param {Number} pos Index in `pattern` to search at.\n * @param {String} flags Flags used by the pattern.\n * @returns {Boolean} Whether the next nonignorable token is a quantifier.\n */function isQuantifierNext(pattern,pos,flags){var inlineCommentPattern='\\\\(\\\\?#[^)]*\\\\)';var lineCommentPattern='#[^#\\\\n]*';var quantifierPattern='[?*+]|{\\\\d+(?:,\\\\d*)?}';return nativ.test.call(flags.indexOf('x')!==-1?// Ignore any leading whitespace, line comments, and inline comments\n/^(?:\\s|#[^#\\n]*|\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/:// Ignore any leading inline comments\n/^(?:\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/,pattern.slice(pos));}/**\n * Determines whether a value is of the specified type, by resolving its internal [[Class]].\n *\n * @private\n * @param {*} value Object to check.\n * @param {String} type Type to check for, in TitleCase.\n * @returns {Boolean} Whether the object matches the type.\n */function isType(value,type){return toString.call(value)==='[object '+type+']';}/**\n * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.\n *\n * @private\n * @param {String} str\n * @returns {String}\n */function pad4(str){while(str.length<4){str='0'+str;}return str;}/**\n * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads\n * the flag preparation logic from the `XRegExp` constructor.\n *\n * @private\n * @param {String} pattern Regex pattern, possibly with a leading mode modifier.\n * @param {String} flags Any combination of flags.\n * @returns {Object} Object with properties `pattern` and `flags`.\n */function prepareFlags(pattern,flags){var i=void 0;// Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags\nif(clipDuplicates(flags)!==flags){throw new SyntaxError('Invalid duplicate regex flag '+flags);}// Strip and apply a leading mode modifier with any combination of flags except g or y\npattern=nativ.replace.call(pattern,/^\\(\\?([\\w$]+)\\)/,function($0,$1){if(nativ.test.call(/[gy]/,$1)){throw new SyntaxError('Cannot use flag g or y in mode modifier '+$0);}// Allow duplicate flags within the mode modifier\nflags=clipDuplicates(flags+$1);return'';});// Throw on unknown native or nonnative flags\nfor(i=0;i<flags.length;++i){if(!registeredFlags[flags[i]]){throw new SyntaxError('Unknown regex flag '+flags[i]);}}return{pattern:pattern,flags:flags};}/**\n * Prepares an options object from the given value.\n *\n * @private\n * @param {String|Object} value Value to convert to an options object.\n * @returns {Object} Options object.\n */function prepareOptions(value){var options={};if(isType(value,'String')){XRegExp.forEach(value,/[^\\s,]+/,function(match){options[match]=true;});return options;}return value;}/**\n * Registers a flag so it doesn't throw an 'unknown flag' error.\n *\n * @private\n * @param {String} flag Single-character flag to register.\n */function registerFlag(flag){if(!/^[\\w$]$/.test(flag)){throw new Error('Flag must be a single character A-Za-z0-9_$');}registeredFlags[flag]=true;}/**\n * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified\n * position, until a match is found.\n *\n * @private\n * @param {String} pattern Original pattern from which an XRegExp object is being built.\n * @param {String} flags Flags being used to construct the regex.\n * @param {Number} pos Position to search for tokens within `pattern`.\n * @param {Number} scope Regex scope to apply: 'default' or 'class'.\n * @param {Object} context Context object to use for token handler functions.\n * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.\n */function runTokens(pattern,flags,pos,scope,context){var i=tokens.length;var leadChar=pattern[pos];var result=null;var match=void 0;var t=void 0;// Run in reverse insertion order\nwhile(i--){t=tokens[i];if(t.leadChar&&t.leadChar!==leadChar||t.scope!==scope&&t.scope!=='all'||t.flag&&!(flags.indexOf(t.flag)!==-1)){continue;}match=XRegExp.exec(pattern,t.regex,pos,'sticky');if(match){result={matchLength:match[0].length,output:t.handler.call(context,match,scope,flags),reparse:t.reparse};// Finished with token tests\nbreak;}}return result;}/**\n * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to\n * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if\n * the Unicode Base addon is not available, since flag A is registered by that addon.\n *\n * @private\n * @param {Boolean} on `true` to enable; `false` to disable.\n */function setAstral(on){features.astral=on;}/**\n * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow\n * the ES5 abstract operation `ToObject`.\n *\n * @private\n * @param {*} value Object to check and return.\n * @returns {*} The provided object.\n */function toObject(value){// null or undefined\nif(value==null){throw new TypeError('Cannot convert null or undefined to object');}return value;}// ==--------------------------==\n// Constructor\n// ==--------------------------==\n/**\n * Creates an extended regular expression object for matching text with a pattern. Differs from a\n * native regular expression in that additional syntax and flags are supported. The returned object\n * is in fact a native `RegExp` and works with all native methods.\n *\n * @class XRegExp\n * @constructor\n * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.\n * @param {String} [flags] Any combination of flags.\n *   Native flags:\n *     - `g` - global\n *     - `i` - ignore case\n *     - `m` - multiline anchors\n *     - `u` - unicode (ES6)\n *     - `y` - sticky (Firefox 3+, ES6)\n *   Additional XRegExp flags:\n *     - `n` - explicit capture\n *     - `s` - dot matches all (aka singleline)\n *     - `x` - free-spacing and line comments (aka extended)\n *     - `A` - astral (requires the Unicode Base addon)\n *   Flags cannot be provided when constructing one `RegExp` from another.\n * @returns {RegExp} Extended regular expression object.\n * @example\n *\n * // With named capture and flag x\n * XRegExp(`(?<year>  [0-9]{4} ) -?  # year\n *          (?<month> [0-9]{2} ) -?  # month\n *          (?<day>   [0-9]{2} )     # day`, 'x');\n *\n * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)\n * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and\n * // have fresh `lastIndex` properties (set to zero).\n * XRegExp(/regex/);\n */function XRegExp(pattern,flags){if(XRegExp.isRegExp(pattern)){if(flags!==undefined){throw new TypeError('Cannot supply flags when copying a RegExp');}return copyRegex(pattern);}// Copy the argument behavior of `RegExp`\npattern=pattern===undefined?'':String(pattern);flags=flags===undefined?'':String(flags);if(XRegExp.isInstalled('astral')&&!(flags.indexOf('A')!==-1)){// This causes an error to be thrown if the Unicode Base addon is not available\nflags+='A';}if(!patternCache[pattern]){patternCache[pattern]={};}if(!patternCache[pattern][flags]){var context={hasNamedCapture:false,captureNames:[]};var scope=defaultScope;var output='';var pos=0;var result=void 0;// Check for flag-related errors, and strip/apply flags in a leading mode modifier\nvar applied=prepareFlags(pattern,flags);var appliedPattern=applied.pattern;var appliedFlags=applied.flags;// Use XRegExp's tokens to translate the pattern to a native regex pattern.\n// `appliedPattern.length` may change on each iteration if tokens use `reparse`\nwhile(pos<appliedPattern.length){do{// Check for custom tokens at the current position\nresult=runTokens(appliedPattern,appliedFlags,pos,scope,context);// If the matched token used the `reparse` option, splice its output into the\n// pattern before running tokens again at the same position\nif(result&&result.reparse){appliedPattern=appliedPattern.slice(0,pos)+result.output+appliedPattern.slice(pos+result.matchLength);}}while(result&&result.reparse);if(result){output+=result.output;pos+=result.matchLength||1;}else{// Get the native token at the current position\nvar token=XRegExp.exec(appliedPattern,nativeTokens[scope],pos,'sticky')[0];output+=token;pos+=token.length;if(token==='['&&scope===defaultScope){scope=classScope;}else if(token===']'&&scope===classScope){scope=defaultScope;}}}patternCache[pattern][flags]={// Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty\n// groups are sometimes inserted during regex transpilation in order to keep tokens\n// separated. However, more than one empty group in a row is never needed.\npattern:nativ.replace.call(output,/(?:\\(\\?:\\))+/g,'(?:)'),// Strip all but native flags\nflags:nativ.replace.call(appliedFlags,/[^gimuy]+/g,''),// `context.captureNames` has an item for each capturing group, even if unnamed\ncaptures:context.hasNamedCapture?context.captureNames:null};}var generated=patternCache[pattern][flags];return augment(new RegExp(generated.pattern,generated.flags),generated.captures,pattern,flags);}// Add `RegExp.prototype` to the prototype chain\nXRegExp.prototype=/(?:)/;// ==--------------------------==\n// Public properties\n// ==--------------------------==\n/**\n * The XRegExp version number as a string containing three dot-separated parts. For example,\n * '2.0.0-beta-3'.\n *\n * @static\n * @memberOf XRegExp\n * @type String\n */XRegExp.version='4.0.0';// ==--------------------------==\n// Public methods\n// ==--------------------------==\n// Intentionally undocumented; used in tests and addons\nXRegExp._clipDuplicates=clipDuplicates;XRegExp._hasNativeFlag=hasNativeFlag;XRegExp._dec=dec;XRegExp._hex=hex;XRegExp._pad4=pad4;/**\n * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to\n * create XRegExp addons. If more than one token can match the same string, the last added wins.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex object that matches the new token.\n * @param {Function} handler Function that returns a new pattern string (using native regex syntax)\n *   to replace the matched token within all future XRegExp regexes. Has access to persistent\n *   properties of the regex being built, through `this`. Invoked with three arguments:\n *   - The match array, with named backreference properties.\n *   - The regex scope where the match was found: 'default' or 'class'.\n *   - The flags used by the regex, including any flags in a leading mode modifier.\n *   The handler function becomes part of the XRegExp construction process, so be careful not to\n *   construct XRegExps within the function or you will trigger infinite recursion.\n * @param {Object} [options] Options object with optional properties:\n *   - `scope` {String} Scope where the token applies: 'default', 'class', or 'all'.\n *   - `flag` {String} Single-character flag that triggers the token. This also registers the\n *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.\n *   - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are\n *     not required to trigger the token. This registers the flags, to prevent XRegExp from\n *     throwing an 'unknown flag' error when any of the flags are used.\n *   - `reparse` {Boolean} Whether the `handler` function's output should not be treated as\n *     final, and instead be reparseable by other tokens (including the current token). Allows\n *     token chaining or deferring.\n *   - `leadChar` {String} Single character that occurs at the beginning of any successful match\n *     of the token (not always applicable). This doesn't change the behavior of the token unless\n *     you provide an erroneous value. However, providing it can increase the token's performance\n *     since the token can be skipped at any positions where this character doesn't appear.\n * @example\n *\n * // Basic usage: Add \\a for the ALERT control code\n * XRegExp.addToken(\n *   /\\\\a/,\n *   () => '\\\\x07',\n *   {scope: 'all'}\n * );\n * XRegExp('\\\\a[\\\\a-\\\\n]+').test('\\x07\\n\\x07'); // -> true\n *\n * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.\n * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of\n * // character classes only)\n * XRegExp.addToken(\n *   /([?*+]|{\\d+(?:,\\d*)?})(\\??)/,\n *   (match) => `${match[1]}${match[2] ? '' : '?'}`,\n *   {flag: 'U'}\n * );\n * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'\n * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'\n */XRegExp.addToken=function(regex,handler,options){options=options||{};var optionalFlags=options.optionalFlags;var i=void 0;if(options.flag){registerFlag(options.flag);}if(optionalFlags){optionalFlags=nativ.split.call(optionalFlags,'');for(i=0;i<optionalFlags.length;++i){registerFlag(optionalFlags[i]);}}// Add to the private list of syntax tokens\ntokens.push({regex:copyRegex(regex,{addG:true,addY:hasNativeY,isInternalOnly:true}),handler:handler,scope:options.scope||defaultScope,flag:options.flag,reparse:options.reparse,leadChar:options.leadChar});// Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags\n// might now produce different results\nXRegExp.cache.flush('patterns');};/**\n * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with\n * the same pattern and flag combination, the cached copy of the regex is returned.\n *\n * @memberOf XRegExp\n * @param {String} pattern Regex pattern string.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @returns {RegExp} Cached XRegExp object.\n * @example\n *\n * while (match = XRegExp.cache('.', 'gs').exec(str)) {\n *   // The regex is compiled once only\n * }\n */XRegExp.cache=function(pattern,flags){if(!regexCache[pattern]){regexCache[pattern]={};}return regexCache[pattern][flags]||(regexCache[pattern][flags]=XRegExp(pattern,flags));};// Intentionally undocumented; used in tests\nXRegExp.cache.flush=function(cacheName){if(cacheName==='patterns'){// Flush the pattern cache used by the `XRegExp` constructor\npatternCache={};}else{// Flush the regex cache populated by `XRegExp.cache`\nregexCache={};}};/**\n * Escapes any regular expression metacharacters, for use when matching literal strings. The result\n * can safely be used at any point within a regex that uses any flags.\n *\n * @memberOf XRegExp\n * @param {String} str String to escape.\n * @returns {String} String with regex metacharacters escaped.\n * @example\n *\n * XRegExp.escape('Escaped? <.>');\n * // -> 'Escaped\\?\\ <\\.>'\n */XRegExp.escape=function(str){return nativ.replace.call(toObject(str),/[-\\[\\]{}()*+?.,\\\\^$|#\\s]/g,'\\\\$&');};/**\n * Executes a regex search in a specified string. Returns a match array or `null`. If the provided\n * regex uses named capture, named backreference properties are included on the match array.\n * Optional `pos` and `sticky` arguments specify the search start position, and whether the match\n * must start at the specified position only. The `lastIndex` property of the provided regex is not\n * used, but is updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.exec` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Array} Match array with named backreference properties, or `null`.\n * @example\n *\n * // Basic use, with named backreference\n * let match = XRegExp.exec('U+2620', XRegExp('U\\\\+(?<hex>[0-9A-F]{4})'));\n * match.hex; // -> '2620'\n *\n * // With pos and sticky, in a loop\n * let pos = 2, result = [], match;\n * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\d)>/, pos, 'sticky')) {\n *   result.push(match[1]);\n *   pos = match.index + match[0].length;\n * }\n * // result -> ['2', '3', '4']\n */XRegExp.exec=function(str,regex,pos,sticky){var cacheKey='g';var addY=false;var fakeY=false;var match=void 0;addY=hasNativeY&&!!(sticky||regex.sticky&&sticky!==false);if(addY){cacheKey+='y';}else if(sticky){// Simulate sticky matching by appending an empty capture to the original regex. The\n// resulting regex will succeed no matter what at the current index (set with `lastIndex`),\n// and will not search the rest of the subject string. We'll know that the original regex\n// has failed if that last capture is `''` rather than `undefined` (i.e., if that last\n// capture participated in the match).\nfakeY=true;cacheKey+='FakeY';}regex[REGEX_DATA]=regex[REGEX_DATA]||{};// Shares cached copies with `XRegExp.match`/`replace`\nvar r2=regex[REGEX_DATA][cacheKey]||(regex[REGEX_DATA][cacheKey]=copyRegex(regex,{addG:true,addY:addY,source:fakeY?regex.source+'|()':undefined,removeY:sticky===false,isInternalOnly:true}));pos=pos||0;r2.lastIndex=pos;// Fixed `exec` required for `lastIndex` fix, named backreferences, etc.\nmatch=fixed.exec.call(r2,str);// Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means\n// the original regexp failed (see above).\nif(fakeY&&match&&match.pop()===''){match=null;}if(regex.global){regex.lastIndex=match?r2.lastIndex:0;}return match;};/**\n * Executes a provided function once per regex match. Searches always start at the beginning of the\n * string and continue until the end, regardless of the state of the regex's `global` property and\n * initial `lastIndex`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Function} callback Function to execute for each match. Invoked with four arguments:\n *   - The match array, with named backreference properties.\n *   - The zero-based match index.\n *   - The string being traversed.\n *   - The regex object being used to traverse the string.\n * @example\n *\n * // Extracts every other digit from a string\n * const evens = [];\n * XRegExp.forEach('1a2345', /\\d/, (match, i) => {\n *   if (i % 2) evens.push(+match[0]);\n * });\n * // evens -> [2, 4]\n */XRegExp.forEach=function(str,regex,callback){var pos=0;var i=-1;var match=void 0;while(match=XRegExp.exec(str,regex,pos)){// Because `regex` is provided to `callback`, the function could use the deprecated/\n// nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`\n// doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,\n// at least. Actually, because of the way `XRegExp.exec` caches globalized versions of\n// regexes, mutating the regex will not have any effect on the iteration or matched strings,\n// which is a nice side effect that brings extra safety.\ncallback(match,++i,str,regex);pos=match.index+(match[0].length||1);}};/**\n * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with\n * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native\n * regexes are not recompiled using XRegExp syntax.\n *\n * @memberOf XRegExp\n * @param {RegExp} regex Regex to globalize.\n * @returns {RegExp} Copy of the provided regex with flag `g` added.\n * @example\n *\n * const globalCopy = XRegExp.globalize(/regex/);\n * globalCopy.global; // -> true\n */XRegExp.globalize=function(regex){return copyRegex(regex,{addG:true});};/**\n * Installs optional features according to the specified options. Can be undone using\n * `XRegExp.uninstall`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.install({\n *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)\n *   astral: true\n * });\n *\n * // With an options string\n * XRegExp.install('astral');\n */XRegExp.install=function(options){options=prepareOptions(options);if(!features.astral&&options.astral){setAstral(true);}};/**\n * Checks whether an individual optional feature is installed.\n *\n * @memberOf XRegExp\n * @param {String} feature Name of the feature to check. One of:\n *   - `astral`\n * @returns {Boolean} Whether the feature is installed.\n * @example\n *\n * XRegExp.isInstalled('astral');\n */XRegExp.isInstalled=function(feature){return!!features[feature];};/**\n * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes\n * created in another frame, when `instanceof` and `constructor` checks would fail.\n *\n * @memberOf XRegExp\n * @param {*} value Object to check.\n * @returns {Boolean} Whether the object is a `RegExp` object.\n * @example\n *\n * XRegExp.isRegExp('string'); // -> false\n * XRegExp.isRegExp(/regex/i); // -> true\n * XRegExp.isRegExp(RegExp('^', 'm')); // -> true\n * XRegExp.isRegExp(XRegExp('(?s).')); // -> true\n */XRegExp.isRegExp=function(value){return toString.call(value)==='[object RegExp]';};// isType(value, 'RegExp');\n/**\n * Returns the first matched string, or in global mode, an array containing all matched strings.\n * This is essentially a more convenient re-implementation of `String.prototype.match` that gives\n * the result types you actually want (string instead of `exec`-style array in match-first mode,\n * and an empty array instead of `null` when no matches are found in match-all mode). It also lets\n * you override flag g and ignore `lastIndex`, and fixes browser bugs.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to\n *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,\n *   `scope` is 'all'.\n * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all\n *   mode: Array of all matched strings, or an empty array.\n * @example\n *\n * // Match first\n * XRegExp.match('abc', /\\w/); // -> 'a'\n * XRegExp.match('abc', /\\w/g, 'one'); // -> 'a'\n * XRegExp.match('abc', /x/g, 'one'); // -> null\n *\n * // Match all\n * XRegExp.match('abc', /\\w/g); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /\\w/, 'all'); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /x/, 'all'); // -> []\n */XRegExp.match=function(str,regex,scope){var global=regex.global&&scope!=='one'||scope==='all';var cacheKey=(global?'g':'')+(regex.sticky?'y':'')||'noGY';regex[REGEX_DATA]=regex[REGEX_DATA]||{};// Shares cached copies with `XRegExp.exec`/`replace`\nvar r2=regex[REGEX_DATA][cacheKey]||(regex[REGEX_DATA][cacheKey]=copyRegex(regex,{addG:!!global,removeG:scope==='one',isInternalOnly:true}));var result=nativ.match.call(toObject(str),r2);if(regex.global){regex.lastIndex=scope==='one'&&result?// Can't use `r2.lastIndex` since `r2` is nonglobal in this case\nresult.index+result[0].length:0;}return global?result||[]:result&&result[0];};/**\n * Retrieves the matches from searching a string using a chain of regexes that successively search\n * within previous matches. The provided `chain` array can contain regexes and or objects with\n * `regex` and `backref` properties. When a backreference is specified, the named or numbered\n * backreference is passed forward to the next regex or returned.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} chain Regexes that each search for matches within preceding results.\n * @returns {Array} Matches by the last regex in the chain, or an empty array.\n * @example\n *\n * // Basic usage; matches numbers within <b> tags\n * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\n *   XRegExp('(?is)<b>.*?</b>'),\n *   /\\d+/\n * ]);\n * // -> ['2', '4', '56']\n *\n * // Passing forward and returning specific backreferences\n * html = '<a href=\"http://xregexp.com/api/\">XRegExp</a>\\\n *         <a href=\"http://www.google.com/\">Google</a>';\n * XRegExp.matchChain(html, [\n *   {regex: /<a href=\"([^\"]+)\">/i, backref: 1},\n *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\n * ]);\n * // -> ['xregexp.com', 'www.google.com']\n */XRegExp.matchChain=function(str,chain){return function recurseChain(values,level){var item=chain[level].regex?chain[level]:{regex:chain[level]};var matches=[];function addMatch(match){if(item.backref){// Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold the\n// `undefined`s for backreferences to nonparticipating capturing groups. In such\n// cases, a `hasOwnProperty` or `in` check on its own would inappropriately throw\n// the exception, so also check if the backreference is a number that is within the\n// bounds of the array.\nif(!(match.hasOwnProperty(item.backref)||+item.backref<match.length)){throw new ReferenceError('Backreference to undefined group: '+item.backref);}matches.push(match[item.backref]||'');}else{matches.push(match[0]);}}for(var i=0;i<values.length;++i){XRegExp.forEach(values[i],item.regex,addMatch);}return level===chain.length-1||!matches.length?matches:recurseChain(matches,level+1);}([str],0);};/**\n * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string\n * or regex, and the replacement can be a string or a function to be called for each match. To\n * perform a global search and replace, use the optional `scope` argument or include flag g if using\n * a regex. Replacement strings can use `${n}` or `$<n>` for named and numbered backreferences.\n * Replacement functions can use named backreferences via `arguments[0].name`. Also fixes browser\n * bugs compared to the native `String.prototype.replace` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n *   Replacement strings can include special replacement syntax:\n *     - $$ - Inserts a literal $ character.\n *     - $&, $0 - Inserts the matched substring.\n *     - $` - Inserts the string that precedes the matched substring (left context).\n *     - $' - Inserts the string that follows the matched substring (right context).\n *     - $n, $nn - Where n/nn are digits referencing an existent capturing group, inserts\n *       backreference n/nn.\n *     - ${n}, $<n> - Where n is a name or any number of digits that reference an existent capturing\n *       group, inserts backreference n.\n *   Replacement functions are invoked with three or more arguments:\n *     - The matched substring (corresponds to $& above). Named backreferences are accessible as\n *       properties of this first argument.\n *     - 0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).\n *     - The zero-based index of the match within the total search string.\n *     - The total string being searched.\n * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not\n *   explicitly specified and using a regex with flag g, `scope` is 'all'.\n * @returns {String} New string with one or all matches replaced.\n * @example\n *\n * // Regex search, using named backreferences in replacement string\n * const name = XRegExp('(?<first>\\\\w+) (?<last>\\\\w+)');\n * XRegExp.replace('John Smith', name, '$<last>, $<first>');\n * // -> 'Smith, John'\n *\n * // Regex search, using named backreferences in replacement function\n * XRegExp.replace('John Smith', name, (match) => `${match.last}, ${match.first}`);\n * // -> 'Smith, John'\n *\n * // String search, with replace-all\n * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');\n * // -> 'XRegExp builds XRegExps'\n */XRegExp.replace=function(str,search,replacement,scope){var isRegex=XRegExp.isRegExp(search);var global=search.global&&scope!=='one'||scope==='all';var cacheKey=(global?'g':'')+(search.sticky?'y':'')||'noGY';var s2=search;if(isRegex){search[REGEX_DATA]=search[REGEX_DATA]||{};// Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s\n// `lastIndex` isn't updated *during* replacement iterations\ns2=search[REGEX_DATA][cacheKey]||(search[REGEX_DATA][cacheKey]=copyRegex(search,{addG:!!global,removeG:scope==='one',isInternalOnly:true}));}else if(global){s2=new RegExp(XRegExp.escape(String(search)),'g');}// Fixed `replace` required for named backreferences, etc.\nvar result=fixed.replace.call(toObject(str),s2,replacement);if(isRegex&&search.global){// Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\nsearch.lastIndex=0;}return result;};/**\n * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an\n * array of replacement details. Later replacements operate on the output of earlier replacements.\n * Replacement details are accepted as an array with a regex or string to search for, the\n * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp\n * replacement text syntax, which supports named backreference properties via `${name}` or\n * `$<name>`.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {Array} replacements Array of replacement detail arrays.\n * @returns {String} New string with all replacements.\n * @example\n *\n * str = XRegExp.replaceEach(str, [\n *   [XRegExp('(?<name>a)'), 'z${name}'],\n *   [/b/gi, 'y'],\n *   [/c/g, 'x', 'one'], // scope 'one' overrides /g\n *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g\n *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings\n *   [/f/g, ($0) => $0.toUpperCase()]\n * ]);\n */XRegExp.replaceEach=function(str,replacements){var i=void 0;var r=void 0;for(i=0;i<replacements.length;++i){r=replacements[i];str=XRegExp.replace(str,r[0],r[1],r[2]);}return str;};/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * XRegExp.split('a b c', ' ');\n * // -> ['a', 'b', 'c']\n *\n * // With limit\n * XRegExp.split('a b c', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * XRegExp.split('..word1..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', '..']\n */XRegExp.split=function(str,separator,limit){return fixed.split.call(toObject(str),separator,limit);};/**\n * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and\n * `sticky` arguments specify the search start position, and whether the match must start at the\n * specified position only. The `lastIndex` property of the provided regex is not used, but is\n * updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.test` and can be used reliably cross-browser.\n *\n * @memberOf XRegExp\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Boolean} Whether the regex matched the provided value.\n * @example\n *\n * // Basic use\n * XRegExp.test('abc', /c/); // -> true\n *\n * // With pos and sticky\n * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false\n * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true\n */ // Do this the easy way :-)\nXRegExp.test=function(str,regex,pos,sticky){return!!XRegExp.exec(str,regex,pos,sticky);};/**\n * Uninstalls optional features according to the specified options. All optional features start out\n * uninstalled, so this is used to undo the actions of `XRegExp.install`.\n *\n * @memberOf XRegExp\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.uninstall({\n *   // Disables support for astral code points in Unicode addons\n *   astral: true\n * });\n *\n * // With an options string\n * XRegExp.uninstall('astral');\n */XRegExp.uninstall=function(options){options=prepareOptions(options);if(features.astral&&options.astral){setAstral(false);}};/**\n * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as\n * regex objects or strings. Metacharacters are escaped in patterns provided as strings.\n * Backreferences in provided regex objects are automatically renumbered to work correctly within\n * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the\n * `flags` argument.\n *\n * @memberOf XRegExp\n * @param {Array} patterns Regexes and strings to combine.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @param {Object} [options] Options object with optional properties:\n *   - `conjunction` {String} Type of conjunction to use: 'or' (default) or 'none'.\n * @returns {RegExp} Union of the provided regexes and strings.\n * @example\n *\n * XRegExp.union(['a+b*c', /(dogs)\\1/, /(cats)\\1/], 'i');\n * // -> /a\\+b\\*c|(dogs)\\1|(cats)\\2/i\n *\n * XRegExp.union([/man/, /bear/, /pig/], 'i', {conjunction: 'none'});\n * // -> /manbearpig/i\n */XRegExp.union=function(patterns,flags,options){options=options||{};var conjunction=options.conjunction||'or';var numCaptures=0;var numPriorCaptures=void 0;var captureNames=void 0;function rewrite(match,paren,backref){var name=captureNames[numCaptures-numPriorCaptures];// Capturing group\nif(paren){++numCaptures;// If the current capture has a name, preserve the name\nif(name){return'(?<'+name+'>';}// Backreference\n}else if(backref){// Rewrite the backreference\nreturn'\\\\'+(+backref+numPriorCaptures);}return match;}if(!(isType(patterns,'Array')&&patterns.length)){throw new TypeError('Must provide a nonempty array of patterns to merge');}var parts=/(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;var output=[];var pattern=void 0;for(var i=0;i<patterns.length;++i){pattern=patterns[i];if(XRegExp.isRegExp(pattern)){numPriorCaptures=numCaptures;captureNames=pattern[REGEX_DATA]&&pattern[REGEX_DATA].captureNames||[];// Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are\n// independently valid; helps keep this simple. Named captures are put back\noutput.push(nativ.replace.call(XRegExp(pattern.source).source,parts,rewrite));}else{output.push(XRegExp.escape(pattern));}}var separator=conjunction==='none'?'':'|';return XRegExp(output.join(separator),flags);};// ==--------------------------==\n// Fixed/extended native methods\n// ==--------------------------==\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `RegExp.prototype.exec`. Use via `XRegExp.exec`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Array} Match array with named backreference properties, or `null`.\n */fixed.exec=function(str){var origLastIndex=this.lastIndex;var match=nativ.exec.apply(this,arguments);if(match){// Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing\n// groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9\n// in standards mode follows the spec.\nif(!correctExecNpcg&&match.length>1&&match.indexOf('')!==-1){var r2=copyRegex(this,{removeG:true,isInternalOnly:true});// Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed\n// matching due to characters outside the match\nnativ.replace.call(String(str).slice(match.index),r2,function(){for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}var len=args.length;// Skip index 0 and the last 2\nfor(var i=1;i<len-2;++i){if(args[i]===undefined){match[i]=undefined;}}});}// Attach named capture properties\nif(this[REGEX_DATA]&&this[REGEX_DATA].captureNames){// Skip index 0\nfor(var i=1;i<match.length;++i){var name=this[REGEX_DATA].captureNames[i-1];if(name){match[name]=match[i];}}}// Fix browsers that increment `lastIndex` after zero-length matches\nif(this.global&&!match[0].length&&this.lastIndex>match.index){this.lastIndex=match.index;}}if(!this.global){// Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\nthis.lastIndex=origLastIndex;}return match;};/**\n * Fixes browser bugs in the native `RegExp.prototype.test`.\n *\n * @memberOf RegExp\n * @param {String} str String to search.\n * @returns {Boolean} Whether the regex matched the provided value.\n */fixed.test=function(str){// Do this the easy way :-)\nreturn!!fixed.exec.call(this,str);};/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `String.prototype.match`.\n *\n * @memberOf String\n * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.\n * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,\n *   the result of calling `regex.exec(this)`.\n */fixed.match=function(regex){if(!XRegExp.isRegExp(regex)){// Use the native `RegExp` rather than `XRegExp`\nregex=new RegExp(regex);}else if(regex.global){var result=nativ.match.apply(this,arguments);// Fixes IE bug\nregex.lastIndex=0;return result;}return fixed.exec.call(regex,toObject(this));};/**\n * Adds support for `${n}` (or `$<n>`) tokens for named and numbered backreferences in replacement\n * text, and provides named backreferences to replacement functions as `arguments[0].name`. Also\n * fixes browser bugs in replacement text syntax when performing a replacement using a nonregex\n * search value, and the value of a replacement regex's `lastIndex` property during replacement\n * iterations and upon completion. Note that this doesn't support SpiderMonkey's proprietary third\n * (`flags`) argument. Use via `XRegExp.replace`.\n *\n * @memberOf String\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n * @returns {String} New string with one or all matches replaced.\n */fixed.replace=function(search,replacement){var isRegex=XRegExp.isRegExp(search);var origLastIndex=void 0;var captureNames=void 0;var result=void 0;if(isRegex){if(search[REGEX_DATA]){captureNames=search[REGEX_DATA].captureNames;}// Only needed if `search` is nonglobal\norigLastIndex=search.lastIndex;}else{search+='';// Type-convert\n}// Don't use `typeof`; some older browsers return 'function' for regex objects\nif(isType(replacement,'Function')){// Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement\n// functions isn't type-converted to a string\nresult=nativ.replace.call(String(this),search,function(){for(var _len2=arguments.length,args=Array(_len2),_key2=0;_key2<_len2;_key2++){args[_key2]=arguments[_key2];}if(captureNames){// Change the `args[0]` string primitive to a `String` object that can store\n// properties. This really does need to use `String` as a constructor\nargs[0]=new String(args[0]);// Store named backreferences on the first argument\nfor(var i=0;i<captureNames.length;++i){if(captureNames[i]){args[0][captureNames[i]]=args[i+1];}}}// Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox, Safari\n// bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)\nif(isRegex&&search.global){search.lastIndex=args[args.length-2]+args[0].length;}// ES6 specs the context for replacement functions as `undefined`\nreturn replacement.apply(undefined,args);});}else{// Ensure that the last value of `args` will be a string when given nonstring `this`,\n// while still throwing on null or undefined context\nresult=nativ.replace.call(this==null?this:String(this),search,function(){for(var _len3=arguments.length,args=Array(_len3),_key3=0;_key3<_len3;_key3++){args[_key3]=arguments[_key3];}return nativ.replace.call(String(replacement),replacementToken,replacer);function replacer($0,bracketed,angled,dollarToken){bracketed=bracketed||angled;// Named or numbered backreference with curly or angled braces\nif(bracketed){// XRegExp behavior for `${n}` or `$<n>`:\n// 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the\n//    entire match. Any number of leading zeros may be used.\n// 2. Backreference to named capture `n`, if it exists and is not an integer\n//    overridden by numbered capture. In practice, this does not overlap with\n//    numbered capture since XRegExp does not allow named capture to use a bare\n//    integer as the name.\n// 3. If the name or number does not refer to an existing capturing group, it's\n//    an error.\nvar n=+bracketed;// Type-convert; drop leading zeros\nif(n<=args.length-3){return args[n]||'';}// Groups with the same name is an error, else would need `lastIndexOf`\nn=captureNames?captureNames.indexOf(bracketed):-1;if(n<0){throw new SyntaxError('Backreference to undefined group '+$0);}return args[n+1]||'';}// Else, special variable or numbered backreference without curly braces\nif(dollarToken==='$'){// $$\nreturn'$';}if(dollarToken==='&'||+dollarToken===0){// $&, $0 (not followed by 1-9), $00\nreturn args[0];}if(dollarToken==='`'){// $` (left context)\nreturn args[args.length-1].slice(0,args[args.length-2]);}if(dollarToken===\"'\"){// $' (right context)\nreturn args[args.length-1].slice(args[args.length-2]+args[0].length);}// Else, numbered backreference without braces\ndollarToken=+dollarToken;// Type-convert; drop leading zero\n// XRegExp behavior for `$n` and `$nn`:\n// - Backrefs end after 1 or 2 digits. Use `${..}` or `$<..>` for more digits.\n// - `$1` is an error if no capturing groups.\n// - `$10` is an error if less than 10 capturing groups. Use `${1}0` or `$<1>0`\n//   instead.\n// - `$01` is `$1` if at least one capturing group, else it's an error.\n// - `$0` (not followed by 1-9) and `$00` are the entire match.\n// Native behavior, for comparison:\n// - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.\n// - `$1` is a literal `$1` if no capturing groups.\n// - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.\n// - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.\n// - `$0` is a literal `$0`.\nif(!isNaN(dollarToken)){if(dollarToken>args.length-3){throw new SyntaxError('Backreference to undefined group '+$0);}return args[dollarToken]||'';}// `$` followed by an unsupported char is an error, unlike native JS\nthrow new SyntaxError('Invalid token '+$0);}});}if(isRegex){if(search.global){// Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\nsearch.lastIndex=0;}else{// Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\nsearch.lastIndex=origLastIndex;}}return result;};/**\n * Fixes browser bugs in the native `String.prototype.split`. Use via `XRegExp.split`.\n *\n * @memberOf String\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n */fixed.split=function(separator,limit){if(!XRegExp.isRegExp(separator)){// Browsers handle nonregex split correctly, so use the faster native method\nreturn nativ.split.apply(this,arguments);}var str=String(this);var output=[];var origLastIndex=separator.lastIndex;var lastLastIndex=0;var lastLength=void 0;// Values for `limit`, per the spec:\n// If undefined: pow(2,32) - 1\n// If 0, Infinity, or NaN: 0\n// If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);\n// If negative number: pow(2,32) - floor(abs(limit))\n// If other: Type-convert, then use the above rules\n// This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless\n// Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+\nlimit=(limit===undefined?-1:limit)>>>0;XRegExp.forEach(str,separator,function(match){// This condition is not the same as `if (match[0].length)`\nif(match.index+match[0].length>lastLastIndex){output.push(str.slice(lastLastIndex,match.index));if(match.length>1&&match.index<str.length){Array.prototype.push.apply(output,match.slice(1));}lastLength=match[0].length;lastLastIndex=match.index+lastLength;}});if(lastLastIndex===str.length){if(!nativ.test.call(separator,'')||lastLength){output.push('');}}else{output.push(str.slice(lastLastIndex));}separator.lastIndex=origLastIndex;return output.length>limit?output.slice(0,limit):output;};// ==--------------------------==\n// Built-in syntax/flag tokens\n// ==--------------------------==\n/*\n * Letter escapes that natively match literal characters: `\\a`, `\\A`, etc. These should be\n * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser\n * consistency and to reserve their syntax, but lets them be superseded by addons.\n */XRegExp.addToken(/\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|x(?![\\dA-Fa-f]{2}))/,function(match,scope){// \\B is allowed in default scope only\nif(match[1]==='B'&&scope===defaultScope){return match[0];}throw new SyntaxError('Invalid escape '+match[0]);},{scope:'all',leadChar:'\\\\'});/*\n * Unicode code point escape with curly braces: `\\u{N..}`. `N..` is any one or more digit\n * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag\n * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to\n * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior\n * if you follow a `\\u{N..}` token that references a code point above U+FFFF with a quantifier, or\n * if you use the same in a character class.\n */XRegExp.addToken(/\\\\u{([\\dA-Fa-f]+)}/,function(match,scope,flags){var code=dec(match[1]);if(code>0x10FFFF){throw new SyntaxError('Invalid Unicode code point '+match[0]);}if(code<=0xFFFF){// Converting to \\uNNNN avoids needing to escape the literal character and keep it\n// separate from preceding tokens\nreturn'\\\\u'+pad4(hex(code));}// If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling\nif(hasNativeU&&flags.indexOf('u')!==-1){return match[0];}throw new SyntaxError('Cannot use Unicode code point above \\\\u{FFFF} without flag u');},{scope:'all',leadChar:'\\\\'});/*\n * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.\n * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because\n * character class endings can't be determined.\n */XRegExp.addToken(/\\[(\\^?)\\]/,// For cross-browser compatibility with ES3, convert [] to \\b\\B and [^] to [\\s\\S].\n// (?!) should work like \\b\\B, but is unreliable in some versions of Firefox\n/* eslint-disable no-confusing-arrow */function(match){return match[1]?'[\\\\s\\\\S]':'\\\\b\\\\B';},/* eslint-enable no-confusing-arrow */{leadChar:'['});/*\n * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in\n * free-spacing mode (flag x).\n */XRegExp.addToken(/\\(\\?#[^)]*\\)/,getContextualTokenSeparator,{leadChar:'('});/*\n * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.\n */XRegExp.addToken(/\\s+|#[^\\n]*\\n?/,getContextualTokenSeparator,{flag:'x'});/*\n * Dot, in dotall mode (aka singleline mode, flag s) only.\n */XRegExp.addToken(/\\./,function(){return'[\\\\s\\\\S]';},{flag:'s',leadChar:'.'});/*\n * Named backreference: `\\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,\n * and $ only. Also allows numbered backreferences as `\\k<n>`.\n */XRegExp.addToken(/\\\\k<([\\w$]+)>/,function(match){// Groups with the same name is an error, else would need `lastIndexOf`\nvar index=isNaN(match[1])?this.captureNames.indexOf(match[1])+1:+match[1];var endIndex=match.index+match[0].length;if(!index||index>this.captureNames.length){throw new SyntaxError('Backreference to undefined group '+match[0]);}// Keep backreferences separate from subsequent literal numbers. This avoids e.g.\n// inadvertedly changing `(?<n>)\\k<n>1` to `()\\11`.\nreturn'\\\\'+index+(endIndex===match.input.length||isNaN(match.input[endIndex])?'':'(?:)');},{leadChar:'\\\\'});/*\n * Numbered backreference or octal, plus any following digits: `\\0`, `\\11`, etc. Octals except `\\0`\n * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches\n * are returned unaltered. IE < 9 doesn't support backreferences above `\\99` in regex syntax.\n */XRegExp.addToken(/\\\\(\\d+)/,function(match,scope){if(!(scope===defaultScope&&/^[1-9]/.test(match[1])&&+match[1]<=this.captureNames.length)&&match[1]!=='0'){throw new SyntaxError('Cannot use octal escape or backreference to undefined group '+match[0]);}return match[0];},{scope:'all',leadChar:'\\\\'});/*\n * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the\n * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style\n * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively\n * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to\n * Python-style named capture as octals.\n */XRegExp.addToken(/\\(\\?P?<([\\w$]+)>/,function(match){// Disallow bare integers as names because named backreferences are added to match arrays\n// and therefore numeric properties may lead to incorrect lookups\nif(!isNaN(match[1])){throw new SyntaxError('Cannot use integer as capture name '+match[0]);}if(match[1]==='length'||match[1]==='__proto__'){throw new SyntaxError('Cannot use reserved word as capture name '+match[0]);}if(this.captureNames.indexOf(match[1])!==-1){throw new SyntaxError('Cannot use same name for multiple groups '+match[0]);}this.captureNames.push(match[1]);this.hasNamedCapture=true;return'(';},{leadChar:'('});/*\n * Capturing group; match the opening parenthesis only. Required for support of named capturing\n * groups. Also adds explicit capture mode (flag n).\n */XRegExp.addToken(/\\((?!\\?)/,function(match,scope,flags){if(flags.indexOf('n')!==-1){return'(?:';}this.captureNames.push(null);return'(';},{optionalFlags:'n',leadChar:'('});exports.default=XRegExp;module.exports=exports['default'];","map":null,"metadata":{},"sourceType":"module"}