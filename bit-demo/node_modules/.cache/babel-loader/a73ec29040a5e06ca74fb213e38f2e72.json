{"ast":null,"code":"import{isObjectType,isListType,isNonNullType,isAbstractType}from'../type/definition';/**\n * Provided two types, return true if the types are equal (invariant).\n */export function isEqualType(typeA,typeB){// Equivalent types are equal.\nif(typeA===typeB){return true;}// If either type is non-null, the other must also be non-null.\nif(isNonNullType(typeA)&&isNonNullType(typeB)){return isEqualType(typeA.ofType,typeB.ofType);}// If either type is a list, the other must also be a list.\nif(isListType(typeA)&&isListType(typeB)){return isEqualType(typeA.ofType,typeB.ofType);}// Otherwise the types are not equal.\nreturn false;}/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */export function isTypeSubTypeOf(schema,maybeSubType,superType){// Equivalent type is a valid subtype\nif(maybeSubType===superType){return true;}// If superType is non-null, maybeSubType must also be non-null.\nif(isNonNullType(superType)){if(isNonNullType(maybeSubType)){return isTypeSubTypeOf(schema,maybeSubType.ofType,superType.ofType);}return false;}if(isNonNullType(maybeSubType)){// If superType is nullable, maybeSubType may be non-null or nullable.\nreturn isTypeSubTypeOf(schema,maybeSubType.ofType,superType);}// If superType type is a list, maybeSubType type must also be a list.\nif(isListType(superType)){if(isListType(maybeSubType)){return isTypeSubTypeOf(schema,maybeSubType.ofType,superType.ofType);}return false;}if(isListType(maybeSubType)){// If superType is not a list, maybeSubType must also be not a list.\nreturn false;}// If superType type is an abstract type, maybeSubType type may be a currently\n// possible object type.\nif(isAbstractType(superType)&&isObjectType(maybeSubType)&&schema.isPossibleType(superType,maybeSubType)){return true;}// Otherwise, the child type is not a valid subtype of the parent type.\nreturn false;}/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */export function doTypesOverlap(schema,typeA,typeB){// Equivalent types overlap\nif(typeA===typeB){return true;}if(isAbstractType(typeA)){if(isAbstractType(typeB)){// If both types are abstract, then determine if there is any intersection\n// between possible concrete types of each.\nreturn schema.getPossibleTypes(typeA).some(function(type){return schema.isPossibleType(typeB,type);});}// Determine if the latter type is a possible concrete type of the former.\nreturn schema.isPossibleType(typeA,typeB);}if(isAbstractType(typeB)){// Determine if the former type is a possible concrete type of the latter.\nreturn schema.isPossibleType(typeB,typeA);}// Otherwise the types do not overlap.\nreturn false;}","map":null,"metadata":{},"sourceType":"module"}