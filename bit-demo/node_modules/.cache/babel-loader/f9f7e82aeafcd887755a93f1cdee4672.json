{"ast":null,"code":"module.exports=minimatch;minimatch.Minimatch=Minimatch;const path=(()=>{try{return require('path');}catch(e){}})()||{sep:'/'};minimatch.sep=path.sep;const GLOBSTAR=minimatch.GLOBSTAR=Minimatch.GLOBSTAR={};const expand=require('brace-expansion');const plTypes={'!':{open:'(?:(?!(?:',close:'))[^/]*?)'},'?':{open:'(?:',close:')?'},'+':{open:'(?:',close:')+'},'*':{open:'(?:',close:')*'},'@':{open:'(?:',close:')'}};// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark='[^/]';// * => any number of characters\nconst star=qmark+'*?';// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot='(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?';// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot='(?:(?!(?:\\\\\\/|^)\\\\.).)*?';// characters that need to be escaped in RegExp.\nconst reSpecials=charSet('().*{}+?[]^$\\\\!');// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet(s){return s.split('').reduce(function(set,c){set[c]=true;return set;},{});}// normalizes slashes.\nconst slashSplit=/\\/+/;minimatch.filter=filter;function filter(pattern,options){options=options||{};return function(p,i,list){return minimatch(p,pattern,options);};}function ext(a,b){a=a||{};b=b||{};const t={};Object.keys(a).forEach(function(k){t[k]=a[k];});Object.keys(b).forEach(function(k){t[k]=b[k];});return t;}minimatch.defaults=function(def){if(!def||typeof def!=='object'||!Object.keys(def).length){return minimatch;}const orig=minimatch;const m=function minimatch(p,pattern,options){return orig(p,pattern,ext(def,options));};m.Minimatch=function Minimatch(pattern,options){return new orig.Minimatch(pattern,ext(def,options));};m.Minimatch.defaults=options=>{return orig.defaults(ext(def,options)).Minimatch;};m.filter=function filter(pattern,options){return orig.filter(pattern,ext(def,options));};m.defaults=function defaults(options){return orig.defaults(ext(def,options));};m.makeRe=function makeRe(pattern,options){return orig.makeRe(pattern,ext(def,options));};m.braceExpand=function braceExpand(pattern,options){return orig.braceExpand(pattern,ext(def,options));};m.match=function(list,pattern,options){return orig.match(list,pattern,ext(def,options));};return m;};Minimatch.defaults=function(def){return minimatch.defaults(def).Minimatch;};function minimatch(p,pattern,options){assertValidPattern(pattern);if(!options)options={};// shortcut: comments match nothing.\nif(!options.nocomment&&pattern.charAt(0)==='#'){return false;}// \"\" only matches \"\"\nif(pattern.trim()==='')return p==='';return new Minimatch(pattern,options).match(p);}function Minimatch(pattern,options){if(!(this instanceof Minimatch)){return new Minimatch(pattern,options);}assertValidPattern(pattern);if(!options)options={};pattern=pattern.trim();// windows support: need to use /, not \\\nif(path.sep!=='/'){pattern=pattern.split(path.sep).join('/');}this.options=options;this.set=[];this.pattern=pattern;this.regexp=null;this.negate=false;this.comment=false;this.empty=false;// make the set of regexps etc.\nthis.make();}Minimatch.prototype.debug=function(){};Minimatch.prototype.make=make;function make(){// don't do it more than once.\nif(this._made)return;var pattern=this.pattern;var options=this.options;// empty patterns and comments match nothing.\nif(!options.nocomment&&pattern.charAt(0)==='#'){this.comment=true;return;}if(!pattern){this.empty=true;return;}// step 1: figure out negation, etc.\nthis.parseNegate();// step 2: expand braces\nvar set=this.globSet=this.braceExpand();if(options.debug)this.debug=console.error;this.debug(this.pattern,set);// step 3: now we have a set, so turn each one into a series of path-portion\n// matching patterns.\n// These will be regexps, except in the case of \"**\", which is\n// set to the GLOBSTAR object for globstar behavior,\n// and will not contain any / characters\nset=this.globParts=set.map(function(s){return s.split(slashSplit);});this.debug(this.pattern,set);// glob --> regexps\nset=set.map(function(s,si,set){return s.map(this.parse,this);},this);this.debug(this.pattern,set);// filter out everything that didn't compile properly.\nset=set.filter(function(s){return s.indexOf(false)===-1;});this.debug(this.pattern,set);this.set=set;}Minimatch.prototype.parseNegate=parseNegate;function parseNegate(){var pattern=this.pattern;var negate=false;var options=this.options;var negateOffset=0;if(options.nonegate)return;for(var i=0,l=pattern.length;i<l&&pattern.charAt(i)==='!';i++){negate=!negate;negateOffset++;}if(negateOffset)this.pattern=pattern.substr(negateOffset);this.negate=negate;}// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand=function(pattern,options){return braceExpand(pattern,options);};Minimatch.prototype.braceExpand=braceExpand;function braceExpand(pattern,options){if(!options){if(this instanceof Minimatch){options=this.options;}else{options={};}}pattern=typeof pattern==='undefined'?this.pattern:pattern;assertValidPattern(pattern);if(options.nobrace||!/\\{(?:(?!\\{).)*\\}/.test(pattern)){// shortcut. no need to expand.\nreturn[pattern];}return expand(pattern);}const MAX_PATTERN_LENGTH=1024*64;const assertValidPattern=pattern=>{if(typeof pattern!=='string'){throw new TypeError('invalid pattern');}if(pattern.length>MAX_PATTERN_LENGTH){throw new TypeError('pattern is too long');}};// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse=parse;const SUBPARSE={};function parse(pattern,isSub){assertValidPattern(pattern);var options=this.options;// shortcuts\nif(!options.noglobstar&&pattern==='**')return GLOBSTAR;if(pattern==='')return'';var re='';var hasMagic=false;var escaping=false;// ? => one single character\nvar patternListStack=[];var negativeLists=[];var stateChar;var inClass=false;var reClassStart=-1;var classStart=-1;// . and .. never match anything that doesn't start with .,\n// even when options.dot is set.\nvar patternStart=pattern.charAt(0)==='.'?''// anything\n// not (start or / followed by . or .. followed by / or end)\n:options.dot?'(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))':'(?!\\\\.)';var self=this;function clearStateChar(){if(stateChar){// we had some state-tracking character\n// that wasn't consumed by this pass.\nswitch(stateChar){case'*':re+=star;hasMagic=true;break;case'?':re+=qmark;hasMagic=true;break;default:re+='\\\\'+stateChar;break;}self.debug('clearStateChar %j %j',stateChar,re);stateChar=false;}}for(var i=0,len=pattern.length,c;i<len&&(c=pattern.charAt(i));i++){this.debug('%s\\t%s %s %j',pattern,i,re,c);// skip over any that are escaped.\nif(escaping&&reSpecials[c]){re+='\\\\'+c;escaping=false;continue;}switch(c){case'/':/* istanbul ignore next */{// completely not allowed, even escaped.\n// Should already be path-split by now.\nreturn false;}case'\\\\':clearStateChar();escaping=true;continue;// the various stateChar values\n// for the \"extglob\" stuff.\ncase'?':case'*':case'+':case'@':case'!':this.debug('%s\\t%s %s %j <-- stateChar',pattern,i,re,c);// all of those are literals inside a class, except that\n// the glob [!a] means [^a] in regexp\nif(inClass){this.debug('  in class');if(c==='!'&&i===classStart+1)c='^';re+=c;continue;}// if we already have a stateChar, then it means\n// that there was something like ** or +? in there.\n// Handle the stateChar, then proceed with this one.\nself.debug('call clearStateChar %j',stateChar);clearStateChar();stateChar=c;// if extglob is disabled, then +(asdf|foo) isn't a thing.\n// just clear the statechar *now*, rather than even diving into\n// the patternList stuff.\nif(options.noext)clearStateChar();continue;case'(':if(inClass){re+='(';continue;}if(!stateChar){re+='\\\\(';continue;}patternListStack.push({type:stateChar,start:i-1,reStart:re.length,open:plTypes[stateChar].open,close:plTypes[stateChar].close});// negation is (?:(?!js)[^/]*)\nre+=stateChar==='!'?'(?:(?!(?:':'(?:';this.debug('plType %j %j',stateChar,re);stateChar=false;continue;case')':if(inClass||!patternListStack.length){re+='\\\\)';continue;}clearStateChar();hasMagic=true;var pl=patternListStack.pop();// negation is (?:(?!js)[^/]*)\n// The others are (?:<pattern>)<type>\nre+=pl.close;if(pl.type==='!'){negativeLists.push(pl);}pl.reEnd=re.length;continue;case'|':if(inClass||!patternListStack.length||escaping){re+='\\\\|';escaping=false;continue;}clearStateChar();re+='|';continue;// these are mostly the same in regexp and glob\ncase'[':// swallow any state-tracking char before the [\nclearStateChar();if(inClass){re+='\\\\'+c;continue;}inClass=true;classStart=i;reClassStart=re.length;re+=c;continue;case']'://  a right bracket shall lose its special\n//  meaning and represent itself in\n//  a bracket expression if it occurs\n//  first in the list.  -- POSIX.2 2.8.3.2\nif(i===classStart+1||!inClass){re+='\\\\'+c;escaping=false;continue;}// handle the case where we left a class open.\n// \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\nif(inClass){// split where the last [ was, make sure we don't have\n// an invalid re. if so, re-walk the contents of the\n// would-be class to re-translate any characters that\n// were passed through as-is\n// TODO: It would probably be faster to determine this\n// without a try/catch and a new RegExp, but it's tricky\n// to do safely.  For now, this is safe and works.\nvar cs=pattern.substring(classStart+1,i);try{RegExp('['+cs+']');}catch(er){// not a valid class!\nvar sp=this.parse(cs,SUBPARSE);re=re.substr(0,reClassStart)+'\\\\['+sp[0]+'\\\\]';hasMagic=hasMagic||sp[1];inClass=false;continue;}}// finish up the class.\nhasMagic=true;inClass=false;re+=c;continue;default:// swallow any state char that wasn't consumed\nclearStateChar();if(escaping){// no need\nescaping=false;}else if(reSpecials[c]&&!(c==='^'&&inClass)){re+='\\\\';}re+=c;}// switch\n}// for\n// handle the case where we left a class open.\n// \"[abc\" is valid, equivalent to \"\\[abc\"\nif(inClass){// split where the last [ was, and escape it\n// this is a huge pita.  We now have to re-walk\n// the contents of the would-be class to re-translate\n// any characters that were passed through as-is\ncs=pattern.substr(classStart+1);sp=this.parse(cs,SUBPARSE);re=re.substr(0,reClassStart)+'\\\\['+sp[0];hasMagic=hasMagic||sp[1];}// handle the case where we had a +( thing at the *end*\n// of the pattern.\n// each pattern list stack adds 3 chars, and we need to go through\n// and escape any | chars that were passed through as-is for the regexp.\n// Go through and escape them, taking care not to double-escape any\n// | chars that were already escaped.\nfor(pl=patternListStack.pop();pl;pl=patternListStack.pop()){var tail=re.slice(pl.reStart+pl.open.length);this.debug('setting tail',re,pl);// maybe some even number of \\, then maybe 1 \\, followed by a |\ntail=tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g,function(_,$1,$2){if(!$2){// the | isn't already escaped, so escape it.\n$2='\\\\';}// need to escape all those slashes *again*, without escaping the\n// one that we need for escaping the | character.  As it works out,\n// escaping an even number of slashes can be done by simply repeating\n// it exactly after itself.  That's why this trick works.\n//\n// I am sorry that you have to see this.\nreturn $1+$1+$2+'|';});this.debug('tail=%j\\n   %s',tail,tail,pl,re);var t=pl.type==='*'?star:pl.type==='?'?qmark:'\\\\'+pl.type;hasMagic=true;re=re.slice(0,pl.reStart)+t+'\\\\('+tail;}// handle trailing things that only matter at the very end.\nclearStateChar();if(escaping){// trailing \\\\\nre+='\\\\\\\\';}// only need to apply the nodot start if the re starts with\n// something that could conceivably capture a dot\nvar addPatternStart=false;switch(re.charAt(0)){case'.':case'[':case'(':addPatternStart=true;}// Hack to work around lack of negative lookbehind in JS\n// A pattern like: *.!(x).!(y|z) needs to ensure that a name\n// like 'a.xyz.yz' doesn't match.  So, the first negative\n// lookahead, has to look ALL the way ahead, to the end of\n// the pattern.\nfor(var n=negativeLists.length-1;n>-1;n--){var nl=negativeLists[n];var nlBefore=re.slice(0,nl.reStart);var nlFirst=re.slice(nl.reStart,nl.reEnd-8);var nlLast=re.slice(nl.reEnd-8,nl.reEnd);var nlAfter=re.slice(nl.reEnd);nlLast+=nlAfter;// Handle nested stuff like *(*.js|!(*.json)), where open parens\n// mean that we should *not* include the ) in the bit that is considered\n// \"after\" the negated section.\nvar openParensBefore=nlBefore.split('(').length-1;var cleanAfter=nlAfter;for(i=0;i<openParensBefore;i++){cleanAfter=cleanAfter.replace(/\\)[+*?]?/,'');}nlAfter=cleanAfter;var dollar='';if(nlAfter===''&&isSub!==SUBPARSE){dollar='$';}var newRe=nlBefore+nlFirst+nlAfter+dollar+nlLast;re=newRe;}// if the re is not \"\" at this point, then we need to make sure\n// it doesn't match against an empty path part.\n// Otherwise a/* will match a/, which it should not.\nif(re!==''&&hasMagic){re='(?=.)'+re;}if(addPatternStart){re=patternStart+re;}// parsing just a piece of a larger pattern.\nif(isSub===SUBPARSE){return[re,hasMagic];}// skip the regexp for non-magical patterns\n// unescape anything in it, though, so that it'll be\n// an exact match against a file etc.\nif(!hasMagic){return globUnescape(pattern);}var flags=options.nocase?'i':'';try{var regExp=new RegExp('^'+re+'$',flags);}catch(er)/* istanbul ignore next - should be impossible */{// If it was an invalid regular expression, then it can't match\n// anything.  This trick looks for a character after the end of\n// the string, which is of course impossible, except in multi-line\n// mode, but it's not a /m regex.\nreturn new RegExp('$.');}regExp._glob=pattern;regExp._src=re;return regExp;}minimatch.makeRe=function(pattern,options){return new Minimatch(pattern,options||{}).makeRe();};Minimatch.prototype.makeRe=makeRe;function makeRe(){if(this.regexp||this.regexp===false)return this.regexp;// at this point, this.set is a 2d array of partial\n// pattern strings, or \"**\".\n//\n// It's better to use .match().  This function shouldn't\n// be used, really, but it's pretty convenient sometimes,\n// when you just want to work with a regex.\nvar set=this.set;if(!set.length){this.regexp=false;return this.regexp;}var options=this.options;var twoStar=options.noglobstar?star:options.dot?twoStarDot:twoStarNoDot;var flags=options.nocase?'i':'';var re=set.map(function(pattern){return pattern.map(function(p){return p===GLOBSTAR?twoStar:typeof p==='string'?regExpEscape(p):p._src;}).join('\\\\\\/');}).join('|');// must match entire pattern\n// ending in a * or ** will make it less strict.\nre='^(?:'+re+')$';// can match anything, as long as it's not this.\nif(this.negate)re='^(?!'+re+').*$';try{this.regexp=new RegExp(re,flags);}catch(ex)/* istanbul ignore next - should be impossible */{this.regexp=false;}return this.regexp;}minimatch.match=function(list,pattern,options){options=options||{};const mm=new Minimatch(pattern,options);list=list.filter(function(f){return mm.match(f);});if(mm.options.nonull&&!list.length){list.push(pattern);}return list;};Minimatch.prototype.match=match;function match(f,partial){this.debug('match',f,this.pattern);// short-circuit in the case of busted things.\n// comments, etc.\nif(this.comment)return false;if(this.empty)return f==='';if(f==='/'&&partial)return true;var options=this.options;// windows: need to use /, not \\\nif(path.sep!=='/'){f=f.split(path.sep).join('/');}// treat the test path as a set of pathparts.\nf=f.split(slashSplit);this.debug(this.pattern,'split',f);// just ONE of the pattern sets in this.set needs to match\n// in order for it to be valid.  If negating, then just one\n// match means that we have failed.\n// Either way, return on the first hit.\nvar set=this.set;this.debug(this.pattern,'set',set);// Find the basename of the path by looking for the last non-empty segment\nvar filename;var i;for(i=f.length-1;i>=0;i--){filename=f[i];if(filename)break;}for(i=0;i<set.length;i++){var pattern=set[i];var file=f;if(options.matchBase&&pattern.length===1){file=[filename];}var hit=this.matchOne(file,pattern,partial);if(hit){if(options.flipNegate)return true;return!this.negate;}}// didn't get any hits.  this is success if it's a negative\n// pattern, failure otherwise.\nif(options.flipNegate)return false;return this.negate;}// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne=function(file,pattern,partial){var options=this.options;this.debug('matchOne',{'this':this,file:file,pattern:pattern});this.debug('matchOne',file.length,pattern.length);for(var fi=0,pi=0,fl=file.length,pl=pattern.length;fi<fl&&pi<pl;fi++,pi++){this.debug('matchOne loop');var p=pattern[pi];var f=file[fi];this.debug(pattern,p,f);// should be impossible.\n// some invalid regexp stuff in the set.\n/* istanbul ignore if */if(p===false)return false;if(p===GLOBSTAR){this.debug('GLOBSTAR',[pattern,p,f]);// \"**\"\n// a/**/b/**/c would match the following:\n// a/b/x/y/z/c\n// a/x/y/z/b/c\n// a/b/x/b/x/c\n// a/b/c\n// To do this, take the rest of the pattern after\n// the **, and see if it would match the file remainder.\n// If so, return success.\n// If not, the ** \"swallows\" a segment, and try again.\n// This is recursively awful.\n//\n// a/**/b/**/c matching a/b/x/y/z/c\n// - a matches a\n// - doublestar\n//   - matchOne(b/x/y/z/c, b/**/c)\n//     - b matches b\n//     - doublestar\n//       - matchOne(x/y/z/c, c) -> no\n//       - matchOne(y/z/c, c) -> no\n//       - matchOne(z/c, c) -> no\n//       - matchOne(c, c) yes, hit\nvar fr=fi;var pr=pi+1;if(pr===pl){this.debug('** at the end');// a ** at the end will just swallow the rest.\n// We have found a match.\n// however, it will not swallow /.x, unless\n// options.dot is set.\n// . and .. are *never* matched by **, for explosively\n// exponential reasons.\nfor(;fi<fl;fi++){if(file[fi]==='.'||file[fi]==='..'||!options.dot&&file[fi].charAt(0)==='.')return false;}return true;}// ok, let's see if we can swallow whatever we can.\nwhile(fr<fl){var swallowee=file[fr];this.debug('\\nglobstar while',file,fr,pattern,pr,swallowee);// XXX remove this slice.  Just pass the start index.\nif(this.matchOne(file.slice(fr),pattern.slice(pr),partial)){this.debug('globstar found match!',fr,fl,swallowee);// found a match.\nreturn true;}else{// can't swallow \".\" or \"..\" ever.\n// can only swallow \".foo\" when explicitly asked.\nif(swallowee==='.'||swallowee==='..'||!options.dot&&swallowee.charAt(0)==='.'){this.debug('dot detected!',file,fr,pattern,pr);break;}// ** swallows a segment, and continue.\nthis.debug('globstar swallow a segment, and continue');fr++;}}// no match was found.\n// However, in partial mode, we can't say this is necessarily over.\n// If there's more *pattern* left, then\n/* istanbul ignore if */if(partial){// ran out of file\nthis.debug('\\n>>> no match, partial?',file,fr,pattern,pr);if(fr===fl)return true;}return false;}// something other than **\n// non-magic patterns just have to match exactly\n// patterns with magic have been turned into regexps.\nvar hit;if(typeof p==='string'){if(options.nocase){hit=f.toLowerCase()===p.toLowerCase();}else{hit=f===p;}this.debug('string match',p,f,hit);}else{hit=f.match(p);this.debug('pattern match',p,f,hit);}if(!hit)return false;}// Note: ending in / means that we'll get a final \"\"\n// at the end of the pattern.  This can only match a\n// corresponding \"\" at the end of the file.\n// If the file ends in /, then it can only match a\n// a pattern that ends in /, unless the pattern just\n// doesn't have any more for it. But, a/b/ should *not*\n// match \"a/b/*\", even though \"\" matches against the\n// [^/]*? pattern, except in partial mode, where it might\n// simply not be reached yet.\n// However, a/b/ should still satisfy a/*\n// now either we fell off the end of the pattern, or we're done.\nif(fi===fl&&pi===pl){// ran out of pattern and filename at the same time.\n// an exact hit!\nreturn true;}else if(fi===fl){// ran out of file, but still had pattern left.\n// this is ok if we're doing the match as part of\n// a glob fs traversal.\nreturn partial;}else/* istanbul ignore else */if(pi===pl){// ran out of pattern, still have file left.\n// this is only acceptable if we're on the very last\n// empty segment of a file with a trailing slash.\n// a/* should match a/b/\nreturn fi===fl-1&&file[fi]==='';}// should be unreachable.\n/* istanbul ignore next */throw new Error('wtf?');};// replace stuff like \\* with *\nfunction globUnescape(s){return s.replace(/\\\\(.)/g,'$1');}function regExpEscape(s){return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g,'\\\\$&');}","map":null,"metadata":{},"sourceType":"module"}