{"ast":null,"code":"/*! *****************************************************************************\nCopyright (C) Microsoft. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */var Reflect;(function(Reflect){// Metadata Proposal\n// https://rbuckton.github.io/reflect-metadata/\n(function(factory){var root=typeof global===\"object\"?global:typeof self===\"object\"?self:typeof this===\"object\"?this:Function(\"return this;\")();var exporter=makeExporter(Reflect);if(typeof root.Reflect===\"undefined\"){root.Reflect=Reflect;}else{exporter=makeExporter(root.Reflect,exporter);}factory(exporter);function makeExporter(target,previous){return function(key,value){if(typeof target[key]!==\"function\"){Object.defineProperty(target,key,{configurable:true,writable:true,value:value});}if(previous)previous(key,value);};}})(function(exporter){var hasOwn=Object.prototype.hasOwnProperty;// feature test for Symbol support\nvar supportsSymbol=typeof Symbol===\"function\";var toPrimitiveSymbol=supportsSymbol&&typeof Symbol.toPrimitive!==\"undefined\"?Symbol.toPrimitive:\"@@toPrimitive\";var iteratorSymbol=supportsSymbol&&typeof Symbol.iterator!==\"undefined\"?Symbol.iterator:\"@@iterator\";var supportsCreate=typeof Object.create===\"function\";// feature test for Object.create support\nvar supportsProto={__proto__:[]}instanceof Array;// feature test for __proto__ support\nvar downLevel=!supportsCreate&&!supportsProto;var HashMap={// create an object in dictionary mode (a.k.a. \"slow\" mode in v8)\ncreate:supportsCreate?function(){return MakeDictionary(Object.create(null));}:supportsProto?function(){return MakeDictionary({__proto__:null});}:function(){return MakeDictionary({});},has:downLevel?function(map,key){return hasOwn.call(map,key);}:function(map,key){return key in map;},get:downLevel?function(map,key){return hasOwn.call(map,key)?map[key]:undefined;}:function(map,key){return map[key];}};// Load global or shim versions of Map, Set, and WeakMap\nvar functionPrototype=Object.getPrototypeOf(Function);var usePolyfill=typeof process===\"object\"&&process.env&&process.env[\"REFLECT_METADATA_USE_MAP_POLYFILL\"]===\"true\";var _Map=!usePolyfill&&typeof Map===\"function\"&&typeof Map.prototype.entries===\"function\"?Map:CreateMapPolyfill();var _Set=!usePolyfill&&typeof Set===\"function\"&&typeof Set.prototype.entries===\"function\"?Set:CreateSetPolyfill();var _WeakMap=!usePolyfill&&typeof WeakMap===\"function\"?WeakMap:CreateWeakMapPolyfill();// [[Metadata]] internal slot\n// https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots\nvar Metadata=new _WeakMap();/**\n         * Applies a set of decorators to a property of a target object.\n         * @param decorators An array of decorators.\n         * @param target The target object.\n         * @param propertyKey (Optional) The property key to decorate.\n         * @param attributes (Optional) The property descriptor for the target key.\n         * @remarks Decorators are applied in reverse order.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     Example = Reflect.decorate(decoratorsArray, Example);\n         *\n         *     // property (on constructor)\n         *     Reflect.decorate(decoratorsArray, Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     Reflect.decorate(decoratorsArray, Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     Object.defineProperty(Example, \"staticMethod\",\n         *         Reflect.decorate(decoratorsArray, Example, \"staticMethod\",\n         *             Object.getOwnPropertyDescriptor(Example, \"staticMethod\")));\n         *\n         *     // method (on prototype)\n         *     Object.defineProperty(Example.prototype, \"method\",\n         *         Reflect.decorate(decoratorsArray, Example.prototype, \"method\",\n         *             Object.getOwnPropertyDescriptor(Example.prototype, \"method\")));\n         *\n         */function decorate(decorators,target,propertyKey,attributes){if(!IsUndefined(propertyKey)){if(!IsArray(decorators))throw new TypeError();if(!IsObject(target))throw new TypeError();if(!IsObject(attributes)&&!IsUndefined(attributes)&&!IsNull(attributes))throw new TypeError();if(IsNull(attributes))attributes=undefined;propertyKey=ToPropertyKey(propertyKey);return DecorateProperty(decorators,target,propertyKey,attributes);}else{if(!IsArray(decorators))throw new TypeError();if(!IsConstructor(target))throw new TypeError();return DecorateConstructor(decorators,target);}}exporter(\"decorate\",decorate);// 4.1.2 Reflect.metadata(metadataKey, metadataValue)\n// https://rbuckton.github.io/reflect-metadata/#reflect.metadata\n/**\n         * A default metadata decorator factory that can be used on a class, class member, or parameter.\n         * @param metadataKey The key for the metadata entry.\n         * @param metadataValue The value for the metadata entry.\n         * @returns A decorator function.\n         * @remarks\n         * If `metadataKey` is already defined for the target and target key, the\n         * metadataValue for that key will be overwritten.\n         * @example\n         *\n         *     // constructor\n         *     @Reflect.metadata(key, value)\n         *     class Example {\n         *     }\n         *\n         *     // property (on constructor, TypeScript only)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         static staticProperty;\n         *     }\n         *\n         *     // property (on prototype, TypeScript only)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         property;\n         *     }\n         *\n         *     // method (on constructor)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         static staticMethod() { }\n         *     }\n         *\n         *     // method (on prototype)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         method() { }\n         *     }\n         *\n         */function metadata(metadataKey,metadataValue){function decorator(target,propertyKey){if(!IsObject(target))throw new TypeError();if(!IsUndefined(propertyKey)&&!IsPropertyKey(propertyKey))throw new TypeError();OrdinaryDefineOwnMetadata(metadataKey,metadataValue,target,propertyKey);}return decorator;}exporter(\"metadata\",metadata);/**\n         * Define a unique metadata entry on the target.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param metadataValue A value that contains attached metadata.\n         * @param target The target object on which to define metadata.\n         * @param propertyKey (Optional) The property key for the target.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example);\n         *\n         *     // property (on constructor)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"method\");\n         *\n         *     // decorator factory as metadata-producing annotation.\n         *     function MyAnnotation(options): Decorator {\n         *         return (target, key?) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\n         *     }\n         *\n         */function defineMetadata(metadataKey,metadataValue,target,propertyKey){if(!IsObject(target))throw new TypeError();if(!IsUndefined(propertyKey))propertyKey=ToPropertyKey(propertyKey);return OrdinaryDefineOwnMetadata(metadataKey,metadataValue,target,propertyKey);}exporter(\"defineMetadata\",defineMetadata);/**\n         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */function hasMetadata(metadataKey,target,propertyKey){if(!IsObject(target))throw new TypeError();if(!IsUndefined(propertyKey))propertyKey=ToPropertyKey(propertyKey);return OrdinaryHasMetadata(metadataKey,target,propertyKey);}exporter(\"hasMetadata\",hasMetadata);/**\n         * Gets a value indicating whether the target object has the provided metadata key defined.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */function hasOwnMetadata(metadataKey,target,propertyKey){if(!IsObject(target))throw new TypeError();if(!IsUndefined(propertyKey))propertyKey=ToPropertyKey(propertyKey);return OrdinaryHasOwnMetadata(metadataKey,target,propertyKey);}exporter(\"hasOwnMetadata\",hasOwnMetadata);/**\n         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */function getMetadata(metadataKey,target,propertyKey){if(!IsObject(target))throw new TypeError();if(!IsUndefined(propertyKey))propertyKey=ToPropertyKey(propertyKey);return OrdinaryGetMetadata(metadataKey,target,propertyKey);}exporter(\"getMetadata\",getMetadata);/**\n         * Gets the metadata value for the provided metadata key on the target object.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */function getOwnMetadata(metadataKey,target,propertyKey){if(!IsObject(target))throw new TypeError();if(!IsUndefined(propertyKey))propertyKey=ToPropertyKey(propertyKey);return OrdinaryGetOwnMetadata(metadataKey,target,propertyKey);}exporter(\"getOwnMetadata\",getOwnMetadata);/**\n         * Gets the metadata keys defined on the target object or its prototype chain.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns An array of unique metadata keys.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getMetadataKeys(Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getMetadataKeys(Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getMetadataKeys(Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getMetadataKeys(Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getMetadataKeys(Example.prototype, \"method\");\n         *\n         */function getMetadataKeys(target,propertyKey){if(!IsObject(target))throw new TypeError();if(!IsUndefined(propertyKey))propertyKey=ToPropertyKey(propertyKey);return OrdinaryMetadataKeys(target,propertyKey);}exporter(\"getMetadataKeys\",getMetadataKeys);/**\n         * Gets the unique metadata keys defined on the target object.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns An array of unique metadata keys.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getOwnMetadataKeys(Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getOwnMetadataKeys(Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getOwnMetadataKeys(Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"method\");\n         *\n         */function getOwnMetadataKeys(target,propertyKey){if(!IsObject(target))throw new TypeError();if(!IsUndefined(propertyKey))propertyKey=ToPropertyKey(propertyKey);return OrdinaryOwnMetadataKeys(target,propertyKey);}exporter(\"getOwnMetadataKeys\",getOwnMetadataKeys);/**\n         * Deletes the metadata entry from the target object with the provided key.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata entry was found and deleted; otherwise, false.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */function deleteMetadata(metadataKey,target,propertyKey){if(!IsObject(target))throw new TypeError();if(!IsUndefined(propertyKey))propertyKey=ToPropertyKey(propertyKey);var metadataMap=GetOrCreateMetadataMap(target,propertyKey,/*Create*/false);if(IsUndefined(metadataMap))return false;if(!metadataMap.delete(metadataKey))return false;if(metadataMap.size>0)return true;var targetMetadata=Metadata.get(target);targetMetadata.delete(propertyKey);if(targetMetadata.size>0)return true;Metadata.delete(target);return true;}exporter(\"deleteMetadata\",deleteMetadata);function DecorateConstructor(decorators,target){for(var i=decorators.length-1;i>=0;--i){var decorator=decorators[i];var decorated=decorator(target);if(!IsUndefined(decorated)&&!IsNull(decorated)){if(!IsConstructor(decorated))throw new TypeError();target=decorated;}}return target;}function DecorateProperty(decorators,target,propertyKey,descriptor){for(var i=decorators.length-1;i>=0;--i){var decorator=decorators[i];var decorated=decorator(target,propertyKey,descriptor);if(!IsUndefined(decorated)&&!IsNull(decorated)){if(!IsObject(decorated))throw new TypeError();descriptor=decorated;}}return descriptor;}function GetOrCreateMetadataMap(O,P,Create){var targetMetadata=Metadata.get(O);if(IsUndefined(targetMetadata)){if(!Create)return undefined;targetMetadata=new _Map();Metadata.set(O,targetMetadata);}var metadataMap=targetMetadata.get(P);if(IsUndefined(metadataMap)){if(!Create)return undefined;metadataMap=new _Map();targetMetadata.set(P,metadataMap);}return metadataMap;}// 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)\n// https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata\nfunction OrdinaryHasMetadata(MetadataKey,O,P){var hasOwn=OrdinaryHasOwnMetadata(MetadataKey,O,P);if(hasOwn)return true;var parent=OrdinaryGetPrototypeOf(O);if(!IsNull(parent))return OrdinaryHasMetadata(MetadataKey,parent,P);return false;}// 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)\n// https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata\nfunction OrdinaryHasOwnMetadata(MetadataKey,O,P){var metadataMap=GetOrCreateMetadataMap(O,P,/*Create*/false);if(IsUndefined(metadataMap))return false;return ToBoolean(metadataMap.has(MetadataKey));}// 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)\n// https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata\nfunction OrdinaryGetMetadata(MetadataKey,O,P){var hasOwn=OrdinaryHasOwnMetadata(MetadataKey,O,P);if(hasOwn)return OrdinaryGetOwnMetadata(MetadataKey,O,P);var parent=OrdinaryGetPrototypeOf(O);if(!IsNull(parent))return OrdinaryGetMetadata(MetadataKey,parent,P);return undefined;}// 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)\n// https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata\nfunction OrdinaryGetOwnMetadata(MetadataKey,O,P){var metadataMap=GetOrCreateMetadataMap(O,P,/*Create*/false);if(IsUndefined(metadataMap))return undefined;return metadataMap.get(MetadataKey);}// 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)\n// https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata\nfunction OrdinaryDefineOwnMetadata(MetadataKey,MetadataValue,O,P){var metadataMap=GetOrCreateMetadataMap(O,P,/*Create*/true);metadataMap.set(MetadataKey,MetadataValue);}// 3.1.6.1 OrdinaryMetadataKeys(O, P)\n// https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys\nfunction OrdinaryMetadataKeys(O,P){var ownKeys=OrdinaryOwnMetadataKeys(O,P);var parent=OrdinaryGetPrototypeOf(O);if(parent===null)return ownKeys;var parentKeys=OrdinaryMetadataKeys(parent,P);if(parentKeys.length<=0)return ownKeys;if(ownKeys.length<=0)return parentKeys;var set=new _Set();var keys=[];for(var _i=0,ownKeys_1=ownKeys;_i<ownKeys_1.length;_i++){var key=ownKeys_1[_i];var hasKey=set.has(key);if(!hasKey){set.add(key);keys.push(key);}}for(var _a=0,parentKeys_1=parentKeys;_a<parentKeys_1.length;_a++){var key=parentKeys_1[_a];var hasKey=set.has(key);if(!hasKey){set.add(key);keys.push(key);}}return keys;}// 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)\n// https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys\nfunction OrdinaryOwnMetadataKeys(O,P){var keys=[];var metadataMap=GetOrCreateMetadataMap(O,P,/*Create*/false);if(IsUndefined(metadataMap))return keys;var keysObj=metadataMap.keys();var iterator=GetIterator(keysObj);var k=0;while(true){var next=IteratorStep(iterator);if(!next){keys.length=k;return keys;}var nextValue=IteratorValue(next);try{keys[k]=nextValue;}catch(e){try{IteratorClose(iterator);}finally{throw e;}}k++;}}// 6 ECMAScript Data Typ0es and Values\n// https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values\nfunction Type(x){if(x===null)return 1/* Null */;switch(typeof x){case\"undefined\":return 0/* Undefined */;case\"boolean\":return 2/* Boolean */;case\"string\":return 3/* String */;case\"symbol\":return 4/* Symbol */;case\"number\":return 5/* Number */;case\"object\":return x===null?1/* Null */:6/* Object */;default:return 6/* Object */;}}// 6.1.1 The Undefined Type\n// https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type\nfunction IsUndefined(x){return x===undefined;}// 6.1.2 The Null Type\n// https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type\nfunction IsNull(x){return x===null;}// 6.1.5 The Symbol Type\n// https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type\nfunction IsSymbol(x){return typeof x===\"symbol\";}// 6.1.7 The Object Type\n// https://tc39.github.io/ecma262/#sec-object-type\nfunction IsObject(x){return typeof x===\"object\"?x!==null:typeof x===\"function\";}// 7.1 Type Conversion\n// https://tc39.github.io/ecma262/#sec-type-conversion\n// 7.1.1 ToPrimitive(input [, PreferredType])\n// https://tc39.github.io/ecma262/#sec-toprimitive\nfunction ToPrimitive(input,PreferredType){switch(Type(input)){case 0/* Undefined */:return input;case 1/* Null */:return input;case 2/* Boolean */:return input;case 3/* String */:return input;case 4/* Symbol */:return input;case 5/* Number */:return input;}var hint=PreferredType===3/* String */?\"string\":PreferredType===5/* Number */?\"number\":\"default\";var exoticToPrim=GetMethod(input,toPrimitiveSymbol);if(exoticToPrim!==undefined){var result=exoticToPrim.call(input,hint);if(IsObject(result))throw new TypeError();return result;}return OrdinaryToPrimitive(input,hint===\"default\"?\"number\":hint);}// 7.1.1.1 OrdinaryToPrimitive(O, hint)\n// https://tc39.github.io/ecma262/#sec-ordinarytoprimitive\nfunction OrdinaryToPrimitive(O,hint){if(hint===\"string\"){var toString_1=O.toString;if(IsCallable(toString_1)){var result=toString_1.call(O);if(!IsObject(result))return result;}var valueOf=O.valueOf;if(IsCallable(valueOf)){var result=valueOf.call(O);if(!IsObject(result))return result;}}else{var valueOf=O.valueOf;if(IsCallable(valueOf)){var result=valueOf.call(O);if(!IsObject(result))return result;}var toString_2=O.toString;if(IsCallable(toString_2)){var result=toString_2.call(O);if(!IsObject(result))return result;}}throw new TypeError();}// 7.1.2 ToBoolean(argument)\n// https://tc39.github.io/ecma262/2016/#sec-toboolean\nfunction ToBoolean(argument){return!!argument;}// 7.1.12 ToString(argument)\n// https://tc39.github.io/ecma262/#sec-tostring\nfunction ToString(argument){return\"\"+argument;}// 7.1.14 ToPropertyKey(argument)\n// https://tc39.github.io/ecma262/#sec-topropertykey\nfunction ToPropertyKey(argument){var key=ToPrimitive(argument,3/* String */);if(IsSymbol(key))return key;return ToString(key);}// 7.2 Testing and Comparison Operations\n// https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations\n// 7.2.2 IsArray(argument)\n// https://tc39.github.io/ecma262/#sec-isarray\nfunction IsArray(argument){return Array.isArray?Array.isArray(argument):argument instanceof Object?argument instanceof Array:Object.prototype.toString.call(argument)===\"[object Array]\";}// 7.2.3 IsCallable(argument)\n// https://tc39.github.io/ecma262/#sec-iscallable\nfunction IsCallable(argument){// NOTE: This is an approximation as we cannot check for [[Call]] internal method.\nreturn typeof argument===\"function\";}// 7.2.4 IsConstructor(argument)\n// https://tc39.github.io/ecma262/#sec-isconstructor\nfunction IsConstructor(argument){// NOTE: This is an approximation as we cannot check for [[Construct]] internal method.\nreturn typeof argument===\"function\";}// 7.2.7 IsPropertyKey(argument)\n// https://tc39.github.io/ecma262/#sec-ispropertykey\nfunction IsPropertyKey(argument){switch(Type(argument)){case 3/* String */:return true;case 4/* Symbol */:return true;default:return false;}}// 7.3 Operations on Objects\n// https://tc39.github.io/ecma262/#sec-operations-on-objects\n// 7.3.9 GetMethod(V, P)\n// https://tc39.github.io/ecma262/#sec-getmethod\nfunction GetMethod(V,P){var func=V[P];if(func===undefined||func===null)return undefined;if(!IsCallable(func))throw new TypeError();return func;}// 7.4 Operations on Iterator Objects\n// https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects\nfunction GetIterator(obj){var method=GetMethod(obj,iteratorSymbol);if(!IsCallable(method))throw new TypeError();// from Call\nvar iterator=method.call(obj);if(!IsObject(iterator))throw new TypeError();return iterator;}// 7.4.4 IteratorValue(iterResult)\n// https://tc39.github.io/ecma262/2016/#sec-iteratorvalue\nfunction IteratorValue(iterResult){return iterResult.value;}// 7.4.5 IteratorStep(iterator)\n// https://tc39.github.io/ecma262/#sec-iteratorstep\nfunction IteratorStep(iterator){var result=iterator.next();return result.done?false:result;}// 7.4.6 IteratorClose(iterator, completion)\n// https://tc39.github.io/ecma262/#sec-iteratorclose\nfunction IteratorClose(iterator){var f=iterator[\"return\"];if(f)f.call(iterator);}// 9.1 Ordinary Object Internal Methods and Internal Slots\n// https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots\n// 9.1.1.1 OrdinaryGetPrototypeOf(O)\n// https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof\nfunction OrdinaryGetPrototypeOf(O){var proto=Object.getPrototypeOf(O);if(typeof O!==\"function\"||O===functionPrototype)return proto;// TypeScript doesn't set __proto__ in ES5, as it's non-standard.\n// Try to determine the superclass constructor. Compatible implementations\n// must either set __proto__ on a subclass constructor to the superclass constructor,\n// or ensure each class has a valid `constructor` property on its prototype that\n// points back to the constructor.\n// If this is not the same as Function.[[Prototype]], then this is definately inherited.\n// This is the case when in ES6 or when using __proto__ in a compatible browser.\nif(proto!==functionPrototype)return proto;// If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.\nvar prototype=O.prototype;var prototypeProto=prototype&&Object.getPrototypeOf(prototype);if(prototypeProto==null||prototypeProto===Object.prototype)return proto;// If the constructor was not a function, then we cannot determine the heritage.\nvar constructor=prototypeProto.constructor;if(typeof constructor!==\"function\")return proto;// If we have some kind of self-reference, then we cannot determine the heritage.\nif(constructor===O)return proto;// we have a pretty good guess at the heritage.\nreturn constructor;}// naive Map shim\nfunction CreateMapPolyfill(){var cacheSentinel={};var arraySentinel=[];var MapIterator=/** @class */function(){function MapIterator(keys,values,selector){this._index=0;this._keys=keys;this._values=values;this._selector=selector;}MapIterator.prototype[\"@@iterator\"]=function(){return this;};MapIterator.prototype[iteratorSymbol]=function(){return this;};MapIterator.prototype.next=function(){var index=this._index;if(index>=0&&index<this._keys.length){var result=this._selector(this._keys[index],this._values[index]);if(index+1>=this._keys.length){this._index=-1;this._keys=arraySentinel;this._values=arraySentinel;}else{this._index++;}return{value:result,done:false};}return{value:undefined,done:true};};MapIterator.prototype.throw=function(error){if(this._index>=0){this._index=-1;this._keys=arraySentinel;this._values=arraySentinel;}throw error;};MapIterator.prototype.return=function(value){if(this._index>=0){this._index=-1;this._keys=arraySentinel;this._values=arraySentinel;}return{value:value,done:true};};return MapIterator;}();return(/** @class */function(){function Map(){this._keys=[];this._values=[];this._cacheKey=cacheSentinel;this._cacheIndex=-2;}Object.defineProperty(Map.prototype,\"size\",{get:function(){return this._keys.length;},enumerable:true,configurable:true});Map.prototype.has=function(key){return this._find(key,/*insert*/false)>=0;};Map.prototype.get=function(key){var index=this._find(key,/*insert*/false);return index>=0?this._values[index]:undefined;};Map.prototype.set=function(key,value){var index=this._find(key,/*insert*/true);this._values[index]=value;return this;};Map.prototype.delete=function(key){var index=this._find(key,/*insert*/false);if(index>=0){var size=this._keys.length;for(var i=index+1;i<size;i++){this._keys[i-1]=this._keys[i];this._values[i-1]=this._values[i];}this._keys.length--;this._values.length--;if(key===this._cacheKey){this._cacheKey=cacheSentinel;this._cacheIndex=-2;}return true;}return false;};Map.prototype.clear=function(){this._keys.length=0;this._values.length=0;this._cacheKey=cacheSentinel;this._cacheIndex=-2;};Map.prototype.keys=function(){return new MapIterator(this._keys,this._values,getKey);};Map.prototype.values=function(){return new MapIterator(this._keys,this._values,getValue);};Map.prototype.entries=function(){return new MapIterator(this._keys,this._values,getEntry);};Map.prototype[\"@@iterator\"]=function(){return this.entries();};Map.prototype[iteratorSymbol]=function(){return this.entries();};Map.prototype._find=function(key,insert){if(this._cacheKey!==key){this._cacheIndex=this._keys.indexOf(this._cacheKey=key);}if(this._cacheIndex<0&&insert){this._cacheIndex=this._keys.length;this._keys.push(key);this._values.push(undefined);}return this._cacheIndex;};return Map;}());function getKey(key,_){return key;}function getValue(_,value){return value;}function getEntry(key,value){return[key,value];}}// naive Set shim\nfunction CreateSetPolyfill(){return(/** @class */function(){function Set(){this._map=new _Map();}Object.defineProperty(Set.prototype,\"size\",{get:function(){return this._map.size;},enumerable:true,configurable:true});Set.prototype.has=function(value){return this._map.has(value);};Set.prototype.add=function(value){return this._map.set(value,value),this;};Set.prototype.delete=function(value){return this._map.delete(value);};Set.prototype.clear=function(){this._map.clear();};Set.prototype.keys=function(){return this._map.keys();};Set.prototype.values=function(){return this._map.values();};Set.prototype.entries=function(){return this._map.entries();};Set.prototype[\"@@iterator\"]=function(){return this.keys();};Set.prototype[iteratorSymbol]=function(){return this.keys();};return Set;}());}// naive WeakMap shim\nfunction CreateWeakMapPolyfill(){var UUID_SIZE=16;var keys=HashMap.create();var rootKey=CreateUniqueKey();return(/** @class */function(){function WeakMap(){this._key=CreateUniqueKey();}WeakMap.prototype.has=function(target){var table=GetOrCreateWeakMapTable(target,/*create*/false);return table!==undefined?HashMap.has(table,this._key):false;};WeakMap.prototype.get=function(target){var table=GetOrCreateWeakMapTable(target,/*create*/false);return table!==undefined?HashMap.get(table,this._key):undefined;};WeakMap.prototype.set=function(target,value){var table=GetOrCreateWeakMapTable(target,/*create*/true);table[this._key]=value;return this;};WeakMap.prototype.delete=function(target){var table=GetOrCreateWeakMapTable(target,/*create*/false);return table!==undefined?delete table[this._key]:false;};WeakMap.prototype.clear=function(){// NOTE: not a real clear, just makes the previous data unreachable\nthis._key=CreateUniqueKey();};return WeakMap;}());function CreateUniqueKey(){var key;do key=\"@@WeakMap@@\"+CreateUUID();while(HashMap.has(keys,key));keys[key]=true;return key;}function GetOrCreateWeakMapTable(target,create){if(!hasOwn.call(target,rootKey)){if(!create)return undefined;Object.defineProperty(target,rootKey,{value:HashMap.create()});}return target[rootKey];}function FillRandomBytes(buffer,size){for(var i=0;i<size;++i)buffer[i]=Math.random()*0xff|0;return buffer;}function GenRandomBytes(size){if(typeof Uint8Array===\"function\"){if(typeof crypto!==\"undefined\")return crypto.getRandomValues(new Uint8Array(size));if(typeof msCrypto!==\"undefined\")return msCrypto.getRandomValues(new Uint8Array(size));return FillRandomBytes(new Uint8Array(size),size);}return FillRandomBytes(new Array(size),size);}function CreateUUID(){var data=GenRandomBytes(UUID_SIZE);// mark as random - RFC 4122 § 4.4\ndata[6]=data[6]&0x4f|0x40;data[8]=data[8]&0xbf|0x80;var result=\"\";for(var offset=0;offset<UUID_SIZE;++offset){var byte=data[offset];if(offset===4||offset===6||offset===8)result+=\"-\";if(byte<16)result+=\"0\";result+=byte.toString(16).toLowerCase();}return result;}}// uses a heuristic used by v8 and chakra to force an object into dictionary mode.\nfunction MakeDictionary(obj){obj.__=undefined;delete obj.__;return obj;}});})(Reflect||(Reflect={}));","map":null,"metadata":{},"sourceType":"module"}