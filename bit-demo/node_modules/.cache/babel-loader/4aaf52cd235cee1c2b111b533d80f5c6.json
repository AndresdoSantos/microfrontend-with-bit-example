{"ast":null,"code":"/*global define:false */ /**\n * Copyright 2012-2017 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.6.5\n * @url craig.is/killing/mice\n */(function(window,document,undefined){// Check if mousetrap is used inside browser, if not, return\nif(!window){return;}/**\n     * mapping of special keycodes to their corresponding keys\n     *\n     * everything in this dictionary cannot use keypress events\n     * so it has to be here to map to the correct keycodes for\n     * keyup/keydown events\n     *\n     * @type {Object}\n     */var _MAP={8:'backspace',9:'tab',13:'enter',16:'shift',17:'ctrl',18:'alt',20:'capslock',27:'esc',32:'space',33:'pageup',34:'pagedown',35:'end',36:'home',37:'left',38:'up',39:'right',40:'down',45:'ins',46:'del',91:'meta',93:'meta',224:'meta'};/**\n     * mapping for special characters so they can support\n     *\n     * this dictionary is only used incase you want to bind a\n     * keyup or keydown event to one of these keys\n     *\n     * @type {Object}\n     */var _KEYCODE_MAP={106:'*',107:'+',109:'-',110:'.',111:'/',186:';',187:'=',188:',',189:'-',190:'.',191:'/',192:'`',219:'[',220:'\\\\',221:']',222:'\\''};/**\n     * this is a mapping of keys that require shift on a US keypad\n     * back to the non shift equivelents\n     *\n     * this is so you can use keyup events with these keys\n     *\n     * note that this will only work reliably on US keyboards\n     *\n     * @type {Object}\n     */var _SHIFT_MAP={'~':'`','!':'1','@':'2','#':'3','$':'4','%':'5','^':'6','&':'7','*':'8','(':'9',')':'0','_':'-','+':'=',':':';','\\\"':'\\'','<':',','>':'.','?':'/','|':'\\\\'};/**\n     * this is a list of special strings you can use to map\n     * to modifier keys when you specify your keyboard shortcuts\n     *\n     * @type {Object}\n     */var _SPECIAL_ALIASES={'option':'alt','command':'meta','return':'enter','escape':'esc','plus':'+','mod':/Mac|iPod|iPhone|iPad/.test(navigator.platform)?'meta':'ctrl'};/**\n     * variable to store the flipped version of _MAP from above\n     * needed to check if we should use keypress or not when no action\n     * is specified\n     *\n     * @type {Object|undefined}\n     */var _REVERSE_MAP;/**\n     * loop through the f keys, f1 to f19 and add them to the map\n     * programatically\n     */for(var i=1;i<20;++i){_MAP[111+i]='f'+i;}/**\n     * loop through to map numbers on the numeric keypad\n     */for(i=0;i<=9;++i){// This needs to use a string cause otherwise since 0 is falsey\n// mousetrap will never fire for numpad 0 pressed as part of a keydown\n// event.\n//\n// @see https://github.com/ccampbell/mousetrap/pull/258\n_MAP[i+96]=i.toString();}/**\n     * cross browser add event method\n     *\n     * @param {Element|HTMLDocument} object\n     * @param {string} type\n     * @param {Function} callback\n     * @returns void\n     */function _addEvent(object,type,callback){if(object.addEventListener){object.addEventListener(type,callback,false);return;}object.attachEvent('on'+type,callback);}/**\n     * takes the event and returns the key character\n     *\n     * @param {Event} e\n     * @return {string}\n     */function _characterFromEvent(e){// for keypress events we should return the character as is\nif(e.type=='keypress'){var character=String.fromCharCode(e.which);// if the shift key is not pressed then it is safe to assume\n// that we want the character to be lowercase.  this means if\n// you accidentally have caps lock on then your key bindings\n// will continue to work\n//\n// the only side effect that might not be desired is if you\n// bind something like 'A' cause you want to trigger an\n// event when capital A is pressed caps lock will no longer\n// trigger the event.  shift+a will though.\nif(!e.shiftKey){character=character.toLowerCase();}return character;}// for non keypress events the special maps are needed\nif(_MAP[e.which]){return _MAP[e.which];}if(_KEYCODE_MAP[e.which]){return _KEYCODE_MAP[e.which];}// if it is not in the special map\n// with keydown and keyup events the character seems to always\n// come in as an uppercase character whether you are pressing shift\n// or not.  we should make sure it is always lowercase for comparisons\nreturn String.fromCharCode(e.which).toLowerCase();}/**\n     * checks if two arrays are equal\n     *\n     * @param {Array} modifiers1\n     * @param {Array} modifiers2\n     * @returns {boolean}\n     */function _modifiersMatch(modifiers1,modifiers2){return modifiers1.sort().join(',')===modifiers2.sort().join(',');}/**\n     * takes a key event and figures out what the modifiers are\n     *\n     * @param {Event} e\n     * @returns {Array}\n     */function _eventModifiers(e){var modifiers=[];if(e.shiftKey){modifiers.push('shift');}if(e.altKey){modifiers.push('alt');}if(e.ctrlKey){modifiers.push('ctrl');}if(e.metaKey){modifiers.push('meta');}return modifiers;}/**\n     * prevents default for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */function _preventDefault(e){if(e.preventDefault){e.preventDefault();return;}e.returnValue=false;}/**\n     * stops propogation for this event\n     *\n     * @param {Event} e\n     * @returns void\n     */function _stopPropagation(e){if(e.stopPropagation){e.stopPropagation();return;}e.cancelBubble=true;}/**\n     * determines if the keycode specified is a modifier key or not\n     *\n     * @param {string} key\n     * @returns {boolean}\n     */function _isModifier(key){return key=='shift'||key=='ctrl'||key=='alt'||key=='meta';}/**\n     * reverses the map lookup so that we can look for specific keys\n     * to see what can and can't use keypress\n     *\n     * @return {Object}\n     */function _getReverseMap(){if(!_REVERSE_MAP){_REVERSE_MAP={};for(var key in _MAP){// pull out the numeric keypad from here cause keypress should\n// be able to detect the keys from the character\nif(key>95&&key<112){continue;}if(_MAP.hasOwnProperty(key)){_REVERSE_MAP[_MAP[key]]=key;}}}return _REVERSE_MAP;}/**\n     * picks the best action based on the key combination\n     *\n     * @param {string} key - character for key\n     * @param {Array} modifiers\n     * @param {string=} action passed in\n     */function _pickBestAction(key,modifiers,action){// if no action was picked in we should try to pick the one\n// that we think would work best for this key\nif(!action){action=_getReverseMap()[key]?'keydown':'keypress';}// modifier keys don't work as expected with keypress,\n// switch to keydown\nif(action=='keypress'&&modifiers.length){action='keydown';}return action;}/**\n     * Converts from a string key combination to an array\n     *\n     * @param  {string} combination like \"command+shift+l\"\n     * @return {Array}\n     */function _keysFromString(combination){if(combination==='+'){return['+'];}combination=combination.replace(/\\+{2}/g,'+plus');return combination.split('+');}/**\n     * Gets info for a specific key combination\n     *\n     * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n     * @param  {string=} action\n     * @returns {Object}\n     */function _getKeyInfo(combination,action){var keys;var key;var i;var modifiers=[];// take the keys from this pattern and figure out what the actual\n// pattern is all about\nkeys=_keysFromString(combination);for(i=0;i<keys.length;++i){key=keys[i];// normalize key names\nif(_SPECIAL_ALIASES[key]){key=_SPECIAL_ALIASES[key];}// if this is not a keypress event then we should\n// be smart about using shift keys\n// this will only work for US keyboards however\nif(action&&action!='keypress'&&_SHIFT_MAP[key]){key=_SHIFT_MAP[key];modifiers.push('shift');}// if this key is a modifier then add it to the list of modifiers\nif(_isModifier(key)){modifiers.push(key);}}// depending on what the key combination is\n// we will try to pick the best event for it\naction=_pickBestAction(key,modifiers,action);return{key:key,modifiers:modifiers,action:action};}function _belongsTo(element,ancestor){if(element===null||element===document){return false;}if(element===ancestor){return true;}return _belongsTo(element.parentNode,ancestor);}function Mousetrap(targetElement){var self=this;targetElement=targetElement||document;if(!(self instanceof Mousetrap)){return new Mousetrap(targetElement);}/**\n         * element to attach key events to\n         *\n         * @type {Element}\n         */self.target=targetElement;/**\n         * a list of all the callbacks setup via Mousetrap.bind()\n         *\n         * @type {Object}\n         */self._callbacks={};/**\n         * direct map of string combinations to callbacks used for trigger()\n         *\n         * @type {Object}\n         */self._directMap={};/**\n         * keeps track of what level each sequence is at since multiple\n         * sequences can start out with the same sequence\n         *\n         * @type {Object}\n         */var _sequenceLevels={};/**\n         * variable to store the setTimeout call\n         *\n         * @type {null|number}\n         */var _resetTimer;/**\n         * temporary state where we will ignore the next keyup\n         *\n         * @type {boolean|string}\n         */var _ignoreNextKeyup=false;/**\n         * temporary state where we will ignore the next keypress\n         *\n         * @type {boolean}\n         */var _ignoreNextKeypress=false;/**\n         * are we currently inside of a sequence?\n         * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n         *\n         * @type {boolean|string}\n         */var _nextExpectedAction=false;/**\n         * resets all sequence counters except for the ones passed in\n         *\n         * @param {Object} doNotReset\n         * @returns void\n         */function _resetSequences(doNotReset){doNotReset=doNotReset||{};var activeSequences=false,key;for(key in _sequenceLevels){if(doNotReset[key]){activeSequences=true;continue;}_sequenceLevels[key]=0;}if(!activeSequences){_nextExpectedAction=false;}}/**\n         * finds all callbacks that match based on the keycode, modifiers,\n         * and action\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event|Object} e\n         * @param {string=} sequenceName - name of the sequence we are looking for\n         * @param {string=} combination\n         * @param {number=} level\n         * @returns {Array}\n         */function _getMatches(character,modifiers,e,sequenceName,combination,level){var i;var callback;var matches=[];var action=e.type;// if there are no events related to this keycode\nif(!self._callbacks[character]){return[];}// if a modifier key is coming up on its own we should allow it\nif(action=='keyup'&&_isModifier(character)){modifiers=[character];}// loop through all callbacks for the key that was pressed\n// and see if any of them match\nfor(i=0;i<self._callbacks[character].length;++i){callback=self._callbacks[character][i];// if a sequence name is not specified, but this is a sequence at\n// the wrong level then move onto the next match\nif(!sequenceName&&callback.seq&&_sequenceLevels[callback.seq]!=callback.level){continue;}// if the action we are looking for doesn't match the action we got\n// then we should keep going\nif(action!=callback.action){continue;}// if this is a keypress event and the meta key and control key\n// are not pressed that means that we need to only look at the\n// character, otherwise check the modifiers as well\n//\n// chrome will not fire a keypress if meta or control is down\n// safari will fire a keypress if meta or meta+shift is down\n// firefox will fire a keypress if meta or control is down\nif(action=='keypress'&&!e.metaKey&&!e.ctrlKey||_modifiersMatch(modifiers,callback.modifiers)){// when you bind a combination or sequence a second time it\n// should overwrite the first one.  if a sequenceName or\n// combination is specified in this call it does just that\n//\n// @todo make deleting its own method?\nvar deleteCombo=!sequenceName&&callback.combo==combination;var deleteSequence=sequenceName&&callback.seq==sequenceName&&callback.level==level;if(deleteCombo||deleteSequence){self._callbacks[character].splice(i,1);}matches.push(callback);}}return matches;}/**\n         * actually calls the callback function\n         *\n         * if your callback function returns false this will use the jquery\n         * convention - prevent default and stop propogation on the event\n         *\n         * @param {Function} callback\n         * @param {Event} e\n         * @returns void\n         */function _fireCallback(callback,e,combo,sequence){// if this event should not happen stop here\nif(self.stopCallback(e,e.target||e.srcElement,combo,sequence)){return;}if(callback(e,combo)===false){_preventDefault(e);_stopPropagation(e);}}/**\n         * handles a character key event\n         *\n         * @param {string} character\n         * @param {Array} modifiers\n         * @param {Event} e\n         * @returns void\n         */self._handleKey=function(character,modifiers,e){var callbacks=_getMatches(character,modifiers,e);var i;var doNotReset={};var maxLevel=0;var processedSequenceCallback=false;// Calculate the maxLevel for sequences so we can only execute the longest callback sequence\nfor(i=0;i<callbacks.length;++i){if(callbacks[i].seq){maxLevel=Math.max(maxLevel,callbacks[i].level);}}// loop through matching callbacks for this key event\nfor(i=0;i<callbacks.length;++i){// fire for all sequence callbacks\n// this is because if for example you have multiple sequences\n// bound such as \"g i\" and \"g t\" they both need to fire the\n// callback for matching g cause otherwise you can only ever\n// match the first one\nif(callbacks[i].seq){// only fire callbacks for the maxLevel to prevent\n// subsequences from also firing\n//\n// for example 'a option b' should not cause 'option b' to fire\n// even though 'option b' is part of the other sequence\n//\n// any sequences that do not match here will be discarded\n// below by the _resetSequences call\nif(callbacks[i].level!=maxLevel){continue;}processedSequenceCallback=true;// keep a list of which sequences were matches for later\ndoNotReset[callbacks[i].seq]=1;_fireCallback(callbacks[i].callback,e,callbacks[i].combo,callbacks[i].seq);continue;}// if there were no sequence matches but we are still here\n// that means this is a regular match so we should fire that\nif(!processedSequenceCallback){_fireCallback(callbacks[i].callback,e,callbacks[i].combo);}}// if the key you pressed matches the type of sequence without\n// being a modifier (ie \"keyup\" or \"keypress\") then we should\n// reset all sequences that were not matched by this event\n//\n// this is so, for example, if you have the sequence \"h a t\" and you\n// type \"h e a r t\" it does not match.  in this case the \"e\" will\n// cause the sequence to reset\n//\n// modifier keys are ignored because you can have a sequence\n// that contains modifiers such as \"enter ctrl+space\" and in most\n// cases the modifier key will be pressed before the next key\n//\n// also if you have a sequence such as \"ctrl+b a\" then pressing the\n// \"b\" key will trigger a \"keypress\" and a \"keydown\"\n//\n// the \"keydown\" is expected when there is a modifier, but the\n// \"keypress\" ends up matching the _nextExpectedAction since it occurs\n// after and that causes the sequence to reset\n//\n// we ignore keypresses in a sequence that directly follow a keydown\n// for the same character\nvar ignoreThisKeypress=e.type=='keypress'&&_ignoreNextKeypress;if(e.type==_nextExpectedAction&&!_isModifier(character)&&!ignoreThisKeypress){_resetSequences(doNotReset);}_ignoreNextKeypress=processedSequenceCallback&&e.type=='keydown';};/**\n         * handles a keydown event\n         *\n         * @param {Event} e\n         * @returns void\n         */function _handleKeyEvent(e){// normalize e.which for key events\n// @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\nif(typeof e.which!=='number'){e.which=e.keyCode;}var character=_characterFromEvent(e);// no character found then stop\nif(!character){return;}// need to use === for the character check because the character can be 0\nif(e.type=='keyup'&&_ignoreNextKeyup===character){_ignoreNextKeyup=false;return;}self.handleKey(character,_eventModifiers(e),e);}/**\n         * called to set a 1 second timeout on the specified sequence\n         *\n         * this is so after each key press in the sequence you have 1 second\n         * to press the next key before you have to start over\n         *\n         * @returns void\n         */function _resetSequenceTimer(){clearTimeout(_resetTimer);_resetTimer=setTimeout(_resetSequences,1000);}/**\n         * binds a key sequence to an event\n         *\n         * @param {string} combo - combo specified in bind call\n         * @param {Array} keys\n         * @param {Function} callback\n         * @param {string=} action\n         * @returns void\n         */function _bindSequence(combo,keys,callback,action){// start off by adding a sequence level record for this combination\n// and setting the level to 0\n_sequenceLevels[combo]=0;/**\n             * callback to increase the sequence level for this sequence and reset\n             * all other sequences that were active\n             *\n             * @param {string} nextAction\n             * @returns {Function}\n             */function _increaseSequence(nextAction){return function(){_nextExpectedAction=nextAction;++_sequenceLevels[combo];_resetSequenceTimer();};}/**\n             * wraps the specified callback inside of another function in order\n             * to reset all sequence counters as soon as this sequence is done\n             *\n             * @param {Event} e\n             * @returns void\n             */function _callbackAndReset(e){_fireCallback(callback,e,combo);// we should ignore the next key up if the action is key down\n// or keypress.  this is so if you finish a sequence and\n// release the key the final key will not trigger a keyup\nif(action!=='keyup'){_ignoreNextKeyup=_characterFromEvent(e);}// weird race condition if a sequence ends with the key\n// another sequence begins with\nsetTimeout(_resetSequences,10);}// loop through keys one at a time and bind the appropriate callback\n// function.  for any key leading up to the final one it should\n// increase the sequence. after the final, it should reset all sequences\n//\n// if an action is specified in the original bind call then that will\n// be used throughout.  otherwise we will pass the action that the\n// next key in the sequence should match.  this allows a sequence\n// to mix and match keypress and keydown events depending on which\n// ones are better suited to the key provided\nfor(var i=0;i<keys.length;++i){var isFinal=i+1===keys.length;var wrappedCallback=isFinal?_callbackAndReset:_increaseSequence(action||_getKeyInfo(keys[i+1]).action);_bindSingle(keys[i],wrappedCallback,action,combo,i);}}/**\n         * binds a single keyboard combination\n         *\n         * @param {string} combination\n         * @param {Function} callback\n         * @param {string=} action\n         * @param {string=} sequenceName - name of sequence if part of sequence\n         * @param {number=} level - what part of the sequence the command is\n         * @returns void\n         */function _bindSingle(combination,callback,action,sequenceName,level){// store a direct mapped reference for use with Mousetrap.trigger\nself._directMap[combination+':'+action]=callback;// make sure multiple spaces in a row become a single space\ncombination=combination.replace(/\\s+/g,' ');var sequence=combination.split(' ');var info;// if this pattern is a sequence of keys then run through this method\n// to reprocess each pattern one key at a time\nif(sequence.length>1){_bindSequence(combination,sequence,callback,action);return;}info=_getKeyInfo(combination,action);// make sure to initialize array if this is the first time\n// a callback is added for this key\nself._callbacks[info.key]=self._callbacks[info.key]||[];// remove an existing match if there is one\n_getMatches(info.key,info.modifiers,{type:info.action},sequenceName,combination,level);// add this call back to the array\n// if it is a sequence put it at the beginning\n// if not put it at the end\n//\n// this is important because the way these are processed expects\n// the sequence ones to come first\nself._callbacks[info.key][sequenceName?'unshift':'push']({callback:callback,modifiers:info.modifiers,action:info.action,seq:sequenceName,level:level,combo:combination});}/**\n         * binds multiple combinations to the same callback\n         *\n         * @param {Array} combinations\n         * @param {Function} callback\n         * @param {string|undefined} action\n         * @returns void\n         */self._bindMultiple=function(combinations,callback,action){for(var i=0;i<combinations.length;++i){_bindSingle(combinations[i],callback,action);}};// start!\n_addEvent(targetElement,'keypress',_handleKeyEvent);_addEvent(targetElement,'keydown',_handleKeyEvent);_addEvent(targetElement,'keyup',_handleKeyEvent);}/**\n     * binds an event to mousetrap\n     *\n     * can be a single key, a combination of keys separated with +,\n     * an array of keys, or a sequence of keys separated by spaces\n     *\n     * be sure to list the modifier keys first to make sure that the\n     * correct key ends up getting bound (the last key in the pattern)\n     *\n     * @param {string|Array} keys\n     * @param {Function} callback\n     * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n     * @returns void\n     */Mousetrap.prototype.bind=function(keys,callback,action){var self=this;keys=keys instanceof Array?keys:[keys];self._bindMultiple.call(self,keys,callback,action);return self;};/**\n     * unbinds an event to mousetrap\n     *\n     * the unbinding sets the callback function of the specified key combo\n     * to an empty function and deletes the corresponding key in the\n     * _directMap dict.\n     *\n     * TODO: actually remove this from the _callbacks dictionary instead\n     * of binding an empty function\n     *\n     * the keycombo+action has to be exactly the same as\n     * it was defined in the bind method\n     *\n     * @param {string|Array} keys\n     * @param {string} action\n     * @returns void\n     */Mousetrap.prototype.unbind=function(keys,action){var self=this;return self.bind.call(self,keys,function(){},action);};/**\n     * triggers an event that has already been bound\n     *\n     * @param {string} keys\n     * @param {string=} action\n     * @returns void\n     */Mousetrap.prototype.trigger=function(keys,action){var self=this;if(self._directMap[keys+':'+action]){self._directMap[keys+':'+action]({},keys);}return self;};/**\n     * resets the library back to its initial state.  this is useful\n     * if you want to clear out the current keyboard shortcuts and bind\n     * new ones - for example if you switch to another page\n     *\n     * @returns void\n     */Mousetrap.prototype.reset=function(){var self=this;self._callbacks={};self._directMap={};return self;};/**\n     * should we stop this event before firing off callbacks\n     *\n     * @param {Event} e\n     * @param {Element} element\n     * @return {boolean}\n     */Mousetrap.prototype.stopCallback=function(e,element){var self=this;// if the element has the class \"mousetrap\" then no need to stop\nif((' '+element.className+' ').indexOf(' mousetrap ')>-1){return false;}if(_belongsTo(element,self.target)){return false;}// Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,\n// not the initial event target in the shadow tree. Note that not all events cross the\n// shadow boundary.\n// For shadow trees with `mode: 'open'`, the initial event target is the first element in\n// the event’s composed path. For shadow trees with `mode: 'closed'`, the initial event\n// target cannot be obtained.\nif('composedPath'in e&&typeof e.composedPath==='function'){// For open shadow trees, update `element` so that the following check works.\nvar initialEventTarget=e.composedPath()[0];if(initialEventTarget!==e.target){element=initialEventTarget;}}// stop for input, select, and textarea\nreturn element.tagName=='INPUT'||element.tagName=='SELECT'||element.tagName=='TEXTAREA'||element.isContentEditable;};/**\n     * exposes _handleKey publicly so it can be overwritten by extensions\n     */Mousetrap.prototype.handleKey=function(){var self=this;return self._handleKey.apply(self,arguments);};/**\n     * allow custom key mappings\n     */Mousetrap.addKeycodes=function(object){for(var key in object){if(object.hasOwnProperty(key)){_MAP[key]=object[key];}}_REVERSE_MAP=null;};/**\n     * Init the global mousetrap functions\n     *\n     * This method is needed to allow the global mousetrap functions to work\n     * now that mousetrap is a constructor function.\n     */Mousetrap.init=function(){var documentMousetrap=Mousetrap(document);for(var method in documentMousetrap){if(method.charAt(0)!=='_'){Mousetrap[method]=function(method){return function(){return documentMousetrap[method].apply(documentMousetrap,arguments);};}(method);}}};Mousetrap.init();// expose mousetrap to the global object\nwindow.Mousetrap=Mousetrap;// expose as a common js module\nif(typeof module!=='undefined'&&module.exports){module.exports=Mousetrap;}// expose mousetrap as an AMD module\nif(typeof define==='function'&&define.amd){define(function(){return Mousetrap;});}})(typeof window!=='undefined'?window:null,typeof window!=='undefined'?document:null);","map":null,"metadata":{},"sourceType":"module"}