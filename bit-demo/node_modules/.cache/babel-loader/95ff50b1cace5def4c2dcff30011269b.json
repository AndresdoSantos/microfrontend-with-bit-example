{"ast":null,"code":"function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError(\"Cannot call a class as a function\");}}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if(\"value\"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import{getDefaultLocale,setDefaultLocale,getLocaleData,addLocaleData}from'./LocaleDataStore';import resolveLocale from'./resolveLocale';// Valid time units.\nexport var UNITS=[\"second\",\"minute\",\"hour\",\"day\",\"week\",\"month\",\"quarter\",\"year\"];// Valid values for the `numeric` option.\nvar NUMERIC_VALUES=[\"auto\",\"always\"];// Valid values for the `style` option.\nvar STYLE_VALUES=[\"long\",\"short\",\"narrow\"];/**\r\n * Polyfill for `Intl.RelativeTimeFormat` proposal.\r\n * https://github.com/tc39/proposal-intl-relative-time\r\n * https://github.com/tc39/proposal-intl-relative-time/issues/55\r\n */var RelativeTimeFormat=/*#__PURE__*/function(){/**\r\n   * @param {(string|string[])} [locales] - Preferred locales (or locale).\r\n   * @param {Object} [options] - Formatting options.\r\n   * @param {string} [options.style=\"long\"] - One of: \"long\", \"short\", \"narrow\".\r\n   * @param {string} [options.numeric=\"always\"] - (Version >= 2) One of: \"always\", \"auto\".\r\n   * @param {string} [options.localeMatcher=\"lookup\"] - One of: \"lookup\", \"best fit\". Currently only \"lookup\" is supported.\r\n   */function RelativeTimeFormat(){var locales=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,RelativeTimeFormat);_defineProperty(this,\"numeric\",\"always\");_defineProperty(this,\"style\",\"long\");_defineProperty(this,\"localeMatcher\",\"lookup\");var numeric=options.numeric,style=options.style,localeMatcher=options.localeMatcher;// Set `numeric` option.\nif(numeric){if(NUMERIC_VALUES.indexOf(numeric)<0){throw new RangeError(\"Invalid \\\"numeric\\\" option: \".concat(numeric));}this.numeric=numeric;}// Set `style` option.\nif(style){if(STYLE_VALUES.indexOf(style)<0){throw new RangeError(\"Invalid \\\"style\\\" option: \".concat(style));}this.style=style;}// Set `localeMatcher` option.\nif(localeMatcher){this.localeMatcher=localeMatcher;}// Set `locale`.\n// Convert `locales` to an array.\nif(typeof locales==='string'){locales=[locales];}// Add default locale.\nlocales.push(getDefaultLocale());// Choose the most appropriate locale.\nthis.locale=RelativeTimeFormat.supportedLocalesOf(locales,{localeMatcher:this.localeMatcher})[0];if(!this.locale){throw new TypeError(\"No supported locale was found\");}this.locale=resolveLocale(this.locale,{localeMatcher:this.localeMatcher});// Use `Intl.NumberFormat` for formatting numbers (when available).\nif(typeof Intl!=='undefined'&&Intl.NumberFormat){this.numberFormat=new Intl.NumberFormat(this.locale);}}/**\r\n   * Formats time `value` in `units` (either in past or in future).\r\n   * @param {number} value - Time interval value.\r\n   * @param {string} unit - Time interval measurement unit.\r\n   * @return {string}\r\n   * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n   * @example\r\n   * // Returns \"2 days ago\"\r\n   * rtf.format(-2, \"day\")\r\n   * // Returns \"in 5 minutes\"\r\n   * rtf.format(5, \"minute\")\r\n   */_createClass(RelativeTimeFormat,[{key:\"format\",value:function format(value,unit){return this.getRule(value,unit).replace('{0}',this.formatNumber(Math.abs(value)));}/**\r\n     * Formats time `value` in `units` (either in past or in future).\r\n     * @param {number} value - Time interval value.\r\n     * @param {string} unit - Time interval measurement unit.\r\n     * @return {Object[]} The parts (`{ type, value }`).\r\n     * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n     * @example\r\n     * // Version 1.\r\n     * // Returns [\r\n     * //   { type: \"literal\", value: \"in \" },\r\n     * //   { type: \"day\", value: \"100\" },\r\n     * //   { type: \"literal\", value: \" days\" }\r\n     * // ]\r\n     * rtf.formatToParts(100, \"day\")\r\n     * //\r\n     * // Version 2.\r\n     * // Returns [\r\n     * //   { type: \"literal\", value: \"in \" },\r\n     * //   { type: \"integer\", value: \"100\", unit: \"day\" },\r\n     * //   { type: \"literal\", value: \" days\" }\r\n     * // ]\r\n     * rtf.formatToParts(100, \"day\")\r\n     */},{key:\"formatToParts\",value:function formatToParts(value,unit){var rule=this.getRule(value,unit);var valueIndex=rule.indexOf(\"{0}\");// \"yesterday\"/\"today\"/\"tomorrow\".\nif(valueIndex<0){return[{type:\"literal\",value:rule}];}var parts=[];if(valueIndex>0){parts.push({type:\"literal\",value:rule.slice(0,valueIndex)});}parts.push({unit:unit,type:\"integer\",value:this.formatNumber(Math.abs(value))});if(valueIndex+\"{0}\".length<rule.length-1){parts.push({type:\"literal\",value:rule.slice(valueIndex+\"{0}\".length)});}return parts;}/**\r\n     * Returns formatting rule for `value` in `units` (either in past or in future).\r\n     * @param {number} value - Time interval value.\r\n     * @param {string} unit - Time interval measurement unit.\r\n     * @return {string}\r\n     * @throws {RangeError} If unit is not one of \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\".\r\n     * @example\r\n     * // Returns \"{0} days ago\"\r\n     * getRule(-2, \"day\")\r\n     */},{key:\"getRule\",value:function getRule(value,unit){if(UNITS.indexOf(unit)<0){throw new RangeError(\"Unknown time unit: \".concat(unit,\".\"));}// Get locale-specific time interval formatting rules\n// of a given `style` for the given value of measurement `unit`.\n//\n// E.g.:\n//\n// ```json\n// {\n//  \"past\": {\n//    \"one\": \"a second ago\",\n//    \"other\": \"{0} seconds ago\"\n//  },\n//  \"future\": {\n//    \"one\": \"in a second\",\n//    \"other\": \"in {0} seconds\"\n//  }\n// }\n// ```\n//\nvar unitRules=getLocaleData(this.locale)[this.style][unit];// Special case for \"yesterday\"/\"today\"/\"tomorrow\".\nif(this.numeric===\"auto\"){// \"yesterday\", \"the day before yesterday\", etc.\nif(value===-2||value===-1){var message=unitRules[\"previous\".concat(value===-1?'':'-'+Math.abs(value))];if(message){return message;}}// \"tomorrow\", \"the day after tomorrow\", etc.\nelse if(value===1||value===2){var _message=unitRules[\"next\".concat(value===1?'':'-'+Math.abs(value))];if(_message){return _message;}}// \"today\"\nelse if(value===0){if(unitRules.current){return unitRules.current;}}}// Choose either \"past\" or \"future\" based on time `value` sign.\n// If there's only \"other\" then it's being collapsed.\n// (the resulting bundle size optimization technique)\nvar quantifierRules=unitRules[value<=0?\"past\":\"future\"];// Bundle size optimization technique.\nif(typeof quantifierRules===\"string\"){return quantifierRules;}// Quantify `value`.\nvar quantify=getLocaleData(this.locale).quantify;var quantifier=quantify&&quantify(Math.abs(value));// There seems to be no such locale in CLDR\n// for which `quantify` is missing\n// and still `past` and `future` messages\n// contain something other than \"other\".\n/* istanbul ignore next */quantifier=quantifier||'other';// \"other\" rule is supposed to be always present.\n// If only \"other\" rule is present then \"rules\" is not an object and is a string.\nreturn quantifierRules[quantifier]||quantifierRules.other;}/**\r\n     * Formats a number into a string.\r\n     * Uses `Intl.NumberFormat` when available.\r\n     * @param  {number} number\r\n     * @return {string}\r\n     */},{key:\"formatNumber\",value:function formatNumber(number){return this.numberFormat?this.numberFormat.format(number):String(number);}/**\r\n     * Returns a new object with properties reflecting the locale and date and time formatting options computed during initialization of this DateTimeFormat object.\r\n     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/resolvedOptions\r\n     * @return {Object}\r\n     */},{key:\"resolvedOptions\",value:function resolvedOptions(){return{locale:this.locale,style:this.style,numeric:this.numeric};}}]);return RelativeTimeFormat;}();/**\r\n * Returns an array containing those of the provided locales\r\n * that are supported in collation without having to fall back\r\n * to the runtime's default locale.\r\n * @param {(string|string[])} locale - A string with a BCP 47 language tag, or an array of such strings. For the general form of the locales argument, see the Intl page.\r\n * @param {Object} [options] - An object that may have the following property:\r\n * @param {string} [options.localeMatcher=\"lookup\"] - The locale matching algorithm to use. Possible values are \"lookup\" and \"best fit\". Currently only \"lookup\" is supported.\r\n * @return {string[]} An array of strings representing a subset of the given locale tags that are supported in collation without having to fall back to the runtime's default locale.\r\n * @example\r\n * var locales = ['ban', 'id-u-co-pinyin', 'es-PY']\r\n * var options = { localeMatcher: 'lookup' }\r\n * // Returns [\"id\", \"es-PY\"]\r\n * Intl.RelativeTimeFormat.supportedLocalesOf(locales, options)\r\n */export{RelativeTimeFormat as default};RelativeTimeFormat.supportedLocalesOf=function(locales){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};// Convert `locales` to an array.\nif(typeof locales==='string'){locales=[locales];}return locales.filter(function(locale){return resolveLocale(locale,options);});};/**\r\n * Adds locale data for a specific locale.\r\n * @param {Object} localeData\r\n */RelativeTimeFormat.addLocale=addLocaleData;/**\r\n * Sets default locale.\r\n * @param  {string} locale\r\n */RelativeTimeFormat.setDefaultLocale=setDefaultLocale;/**\r\n * Gets default locale.\r\n * @return  {string} locale\r\n */RelativeTimeFormat.getDefaultLocale=getDefaultLocale;/**\r\n * Extracts language from an IETF BCP 47 language tag.\r\n * @param {string} languageTag - IETF BCP 47 language tag.\r\n * @return {string}\r\n * @example\r\n * // Returns \"he\"\r\n * getLanguageFromLanguageTag(\"he-IL-u-ca-hebrew-tz-jeruslm\")\r\n * // Returns \"ar\"\r\n * getLanguageFromLanguageTag(\"ar-u-nu-latn\")\r\n */ // export function getLanguageFromLanguageTag(languageTag) {\n//   const hyphenIndex = languageTag.indexOf('-')\n//   if (hyphenIndex > 0) {\n//     return languageTag.slice(0, hyphenIndex)\n//   }\n//   return languageTag\n// }","map":null,"metadata":{},"sourceType":"module"}