{"ast":null,"code":"import devAssert from'../jsutils/devAssert';import{GraphQLError}from'../error/GraphQLError';import{visit,visitInParallel,visitWithTypeInfo}from'../language/visitor';import{assertValidSchema}from'../type/validate';import{TypeInfo}from'../utilities/TypeInfo';import{specifiedRules,specifiedSDLRules}from'./specifiedRules';import{SDLValidationContext,ValidationContext}from'./ValidationContext';export var ABORT_VALIDATION=Object.freeze({});/**\n * Implements the \"Validation\" section of the spec.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the document is valid.\n *\n * A list of specific validation rules may be provided. If not provided, the\n * default list of rules defined by the GraphQL specification will be used.\n *\n * Each validation rules is a function which returns a visitor\n * (see the language/visitor API). Visitor methods are expected to return\n * GraphQLErrors, or Arrays of GraphQLErrors when invalid.\n *\n * Optionally a custom TypeInfo instance may be provided. If not provided, one\n * will be created from the provided schema.\n */export function validate(schema,documentAST){var rules=arguments.length>2&&arguments[2]!==undefined?arguments[2]:specifiedRules;var typeInfo=arguments.length>3&&arguments[3]!==undefined?arguments[3]:new TypeInfo(schema);var options=arguments.length>4?arguments[4]:undefined;documentAST||devAssert(0,'Must provide document');// If the schema used for validation is invalid, throw an error.\nassertValidSchema(schema);var abortObj=Object.freeze({});var errors=[];var maxErrors=options&&options.maxErrors;var context=new ValidationContext(schema,documentAST,typeInfo,function(error){if(maxErrors!=null&&errors.length>=maxErrors){errors.push(new GraphQLError('Too many validation errors, error limit reached. Validation aborted.'));throw abortObj;}errors.push(error);});// This uses a specialized visitor which runs multiple visitors in parallel,\n// while maintaining the visitor skip and break API.\nvar visitor=visitInParallel(rules.map(function(rule){return rule(context);}));// Visit the whole document with each instance of all provided rules.\ntry{visit(documentAST,visitWithTypeInfo(typeInfo,visitor));}catch(e){if(e!==abortObj){throw e;}}return errors;}// @internal\nexport function validateSDL(documentAST,schemaToExtend){var rules=arguments.length>2&&arguments[2]!==undefined?arguments[2]:specifiedSDLRules;var errors=[];var context=new SDLValidationContext(documentAST,schemaToExtend,function(error){errors.push(error);});var visitors=rules.map(function(rule){return rule(context);});visit(documentAST,visitInParallel(visitors));return errors;}/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */export function assertValidSDL(documentAST){var errors=validateSDL(documentAST);if(errors.length!==0){throw new Error(errors.map(function(error){return error.message;}).join('\\n\\n'));}}/**\n * Utility function which asserts a SDL document is valid by throwing an error\n * if it is invalid.\n *\n * @internal\n */export function assertValidSDLExtension(documentAST,schema){var errors=validateSDL(documentAST,schema);if(errors.length!==0){throw new Error(errors.map(function(error){return error.message;}).join('\\n\\n'));}}","map":null,"metadata":{},"sourceType":"module"}