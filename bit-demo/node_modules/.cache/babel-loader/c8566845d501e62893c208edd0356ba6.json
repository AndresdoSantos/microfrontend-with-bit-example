{"ast":null,"code":"const KEY_PATH_DELIMITER='.';const keyPathToSegments=keyPath=>keyPath?keyPath.split(KEY_PATH_DELIMITER):[];const segmentsToKeyPath=segments=>segments.join(KEY_PATH_DELIMITER);const createKeyPath=(key,prefix)=>{const segments=keyPathToSegments(prefix||'');segments.push(key);return segmentsToKeyPath(segments);};/**\n * Given a `keyPath`, set it to be `value` on `subject`, creating any intermediate\n * objects along the way.\n *\n * @param {Object} subject The object on which to set value.\n * @param {string} keyPath The key path at which to set value.\n * @param {Object} value The value to store at the given key path.\n * @returns {Object} Updated subject.\n */export const setAtKeyPath=(subject,keyPath,value)=>{const segments=keyPathToSegments(keyPath);segments.reduce((prevSubject,key,idx)=>{if(typeof prevSubject[key]==='undefined'){prevSubject[key]={};}if(idx===segments.length-1){prevSubject[key]=value;}return prevSubject[key];},subject);return subject;};/**\n * Given a dictionary of (nested) keys to function, flatten them to a map\n * from key path to function.\n *\n * @param {Object} methods The (potentially nested) object to serialize.\n * @param {string} prefix A string with which to prefix entries. Typically not intended to be used by consumers.\n * @returns {Object} An map from key path in `methods` to functions.\n */export const serializeMethods=(methods,prefix)=>{const flattenedMethods={};Object.keys(methods).forEach(key=>{const value=methods[key];const keyPath=createKeyPath(key,prefix);if(typeof value==='object'){// Recurse into any nested children.\nObject.assign(flattenedMethods,serializeMethods(value,keyPath));}if(typeof value==='function'){// If we've found a method, expose it.\nflattenedMethods[keyPath]=value;}});return flattenedMethods;};/**\n * Given a map of key paths to functions, unpack the key paths to an object.\n *\n * @param {Object} flattenedMethods A map of key paths to functions to unpack.\n * @returns {Object} A (potentially nested) map of functions.\n */export const deserializeMethods=flattenedMethods=>{const methods={};for(const keyPath in flattenedMethods){setAtKeyPath(methods,keyPath,flattenedMethods[keyPath]);}return methods;};","map":null,"metadata":{},"sourceType":"module"}