{"ast":null,"code":"// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nvar currentContext=null;// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nvar MISSING_VALUE={};var idCounter=1;// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nvar makeSlotClass=function(){return(/** @class */function(){function Slot(){// If you have a Slot object, you can find out its slot.id, but you cannot\n// guess the slot.id of a Slot you don't have access to, thanks to the\n// randomized suffix.\nthis.id=[\"slot\",idCounter++,Date.now(),Math.random().toString(36).slice(2)].join(\":\");}Slot.prototype.hasValue=function(){for(var context_1=currentContext;context_1;context_1=context_1.parent){// We use the Slot object iself as a key to its value, which means the\n// value cannot be obtained without a reference to the Slot object.\nif(this.id in context_1.slots){var value=context_1.slots[this.id];if(value===MISSING_VALUE)break;if(context_1!==currentContext){// Cache the value in currentContext.slots so the next lookup will\n// be faster. This caching is safe because the tree of contexts and\n// the values of the slots are logically immutable.\ncurrentContext.slots[this.id]=value;}return true;}}if(currentContext){// If a value was not found for this Slot, it's never going to be found\n// no matter how many times we look it up, so we might as well cache\n// the absence of the value, too.\ncurrentContext.slots[this.id]=MISSING_VALUE;}return false;};Slot.prototype.getValue=function(){if(this.hasValue()){return currentContext.slots[this.id];}};Slot.prototype.withValue=function(value,callback,// Given the prevalence of arrow functions, specifying arguments is likely\n// to be much more common than specifying `this`, hence this ordering:\nargs,thisArg){var _a;var slots=(_a={__proto__:null},_a[this.id]=value,_a);var parent=currentContext;currentContext={parent:parent,slots:slots};try{// Function.prototype.apply allows the arguments array argument to be\n// omitted or undefined, so args! is fine here.\nreturn callback.apply(thisArg,args);}finally{currentContext=parent;}};// Capture the current context and wrap a callback function so that it\n// reestablishes the captured context when called.\nSlot.bind=function(callback){var context=currentContext;return function(){var saved=currentContext;try{currentContext=context;return callback.apply(this,arguments);}finally{currentContext=saved;}};};// Immediately run a callback function without any captured context.\nSlot.noContext=function(callback,// Given the prevalence of arrow functions, specifying arguments is likely\n// to be much more common than specifying `this`, hence this ordering:\nargs,thisArg){if(currentContext){var saved=currentContext;try{currentContext=null;// Function.prototype.apply allows the arguments array argument to be\n// omitted or undefined, so args! is fine here.\nreturn callback.apply(thisArg,args);}finally{currentContext=saved;}}else{return callback.apply(thisArg,args);}};return Slot;}());};// We store a single global implementation of the Slot class as a permanent\n// non-enumerable symbol property of the Array constructor. This obfuscation\n// does nothing to prevent access to the Slot class, but at least it ensures\n// the implementation (i.e. currentContext) cannot be tampered with, and all\n// copies of the @wry/context package (hopefully just one) will share the\n// same Slot implementation. Since the first copy of the @wry/context package\n// to be imported wins, this technique imposes a very high cost for any\n// future breaking changes to the Slot class.\nvar globalKey=\"@wry/context:Slot\";var host=Array;var Slot=host[globalKey]||function(){var Slot=makeSlotClass();try{Object.defineProperty(host,globalKey,{value:host[globalKey]=Slot,enumerable:false,writable:false,configurable:false});}finally{return Slot;}}();var bind=Slot.bind,noContext=Slot.noContext;function setTimeoutWithContext(callback,delay){return setTimeout(bind(callback),delay);}// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nfunction asyncFromGen(genFn){return function(){var gen=genFn.apply(this,arguments);var boundNext=bind(gen.next);var boundThrow=bind(gen.throw);return new Promise(function(resolve,reject){function invoke(method,argument){try{var result=method.call(gen,argument);}catch(error){return reject(error);}var next=result.done?resolve:invokeNext;if(isPromiseLike(result.value)){result.value.then(next,result.done?reject:invokeThrow);}else{next(result.value);}}var invokeNext=function(value){return invoke(boundNext,value);};var invokeThrow=function(error){return invoke(boundThrow,error);};invokeNext();});};}function isPromiseLike(value){return value&&typeof value.then===\"function\";}// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nvar wrappedFibers=[];function wrapYieldingFiberMethods(Fiber){// There can be only one implementation of Fiber per process, so this array\n// should never grow longer than one element.\nif(wrappedFibers.indexOf(Fiber)<0){var wrap=function(obj,method){var fn=obj[method];obj[method]=function(){return noContext(fn,arguments,this);};};// These methods can yield, according to\n// https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\nwrap(Fiber,\"yield\");wrap(Fiber.prototype,\"run\");wrap(Fiber.prototype,\"throwInto\");wrappedFibers.push(Fiber);}return Fiber;}export{Slot,asyncFromGen,bind,noContext,setTimeoutWithContext as setTimeout,wrapYieldingFiberMethods};","map":null,"metadata":{},"sourceType":"module"}