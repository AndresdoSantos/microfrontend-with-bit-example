{"ast":null,"code":"function _typeof(obj){if(typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};}return _typeof(obj);}// Chooses the most appropriate locale\n// (one of the registered ones)\n// based on the list of preferred `locales` supplied by the user.\n//\n// @param {string[]} locales - the list of preferable locales (in [IETF format](https://en.wikipedia.org/wiki/IETF_language_tag)).\n// @param {Function} isLocaleDataAvailable - tests if a locale is available.\n//\n// @returns {string} The most suitable locale\n//\n// @example\n// // Returns 'en'\n// chooseLocale(['en-US'], undefined, (locale) => locale === 'ru' || locale === 'en')\n//\nexport default function chooseLocale(locales,isLocaleDataAvailable){// This is not an intelligent algorithm,\n// but it will do for this library's case.\n// `sr-Cyrl-BA` -> `sr-Cyrl` -> `sr`.\nfor(var _iterator=locales,_isArray=Array.isArray(_iterator),_i=0,_iterator=_isArray?_iterator:_iterator[Symbol.iterator]();;){var _ref;if(_isArray){if(_i>=_iterator.length)break;_ref=_iterator[_i++];}else{_i=_iterator.next();if(_i.done)break;_ref=_i.value;}var locale=_ref;if(isLocaleDataAvailable(locale)){return locale;}var parts=locale.split('-');while(parts.length>1){parts.pop();locale=parts.join('-');if(isLocaleDataAvailable(locale)){return locale;}}}throw new Error(\"No locale data has been registered for any of the locales: \".concat(locales.join(', ')));}/**\r\n * Whether can use `Intl.DateTimeFormat` for these `locales`.\r\n * Returns the first suitable one.\r\n * @param  {(string|string[])} locales\r\n * @return {?string} The first locale that can be used.\r\n */export function intlDateTimeFormatSupportedLocale(locales){/* istanbul ignore else */if(intlDateTimeFormatSupported()){return Intl.DateTimeFormat.supportedLocalesOf(locales)[0];}}/**\r\n * Whether can use `Intl.DateTimeFormat`.\r\n * @return {boolean}\r\n */export function intlDateTimeFormatSupported(){// Babel transforms `typeof` into some \"branches\"\n// so istanbul will show this as \"branch not covered\".\n/* istanbul ignore next */var isIntlAvailable=(typeof Intl===\"undefined\"?\"undefined\":_typeof(Intl))==='object';return isIntlAvailable&&typeof Intl.DateTimeFormat==='function';}","map":null,"metadata":{},"sourceType":"module"}