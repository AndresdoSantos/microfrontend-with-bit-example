{"ast":null,"code":"function _typeof(obj){if(typeof Symbol===\"function\"&&typeof Symbol.iterator===\"symbol\"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol===\"function\"&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;};}return _typeof(obj);}import{convenient}from'./gradation';/**\r\n * Takes seconds `elapsed` and measures them against\r\n * `gradation` to return the suitable `gradation` step.\r\n *\r\n * @param {number} elapsed - Time interval (in seconds). Is < 0 for past dates and > 0 for future dates.\r\n *\r\n * @param {string[]} units - A list of allowed time units\r\n *                           (e.g. ['second', 'minute', 'hour', …])\r\n *\r\n * @param {Object} [gradation] - Time scale gradation steps.\r\n *\r\n *                               E.g.:\r\n *                               [\r\n *                                 { unit: 'second', factor: 1 },\r\n *                                 { unit: 'minute', factor: 60, threshold: 60 },\r\n *                                 { format(), threshold: 24 * 60 * 60 },\r\n *                                 …\r\n *                               ]\r\n *\r\n * @return {?Object} `gradation` step.\r\n */export default function grade(elapsed,now,units){var gradation=arguments.length>3&&arguments[3]!==undefined?arguments[3]:convenient;// Leave only allowed time measurement units.\n// E.g. omit \"quarter\" unit.\ngradation=getAllowedSteps(gradation,units);// If no steps of gradation fit the conditions\n// then return nothing.\nif(gradation.length===0){return;}// Find the most appropriate gradation step\nvar i=findGradationStep(elapsed,now,gradation);var step=gradation[i];// If time elapsed is too small and even\n// the first gradation step doesn't suit it\n// then return nothing.\nif(i===-1){return;}// Apply granularity to the time amount\n// (and fall back to the previous step\n//  if the first level of granularity\n//  isn't met by this amount)\nif(step.granularity){// Recalculate the elapsed time amount based on granularity\nvar amount=Math.round(Math.abs(elapsed)/step.factor/step.granularity)*step.granularity;// If the granularity for this step\n// is too high, then fallback\n// to the previous step of gradation.\n// (if there is any previous step of gradation)\nif(amount===0&&i>0){return gradation[i-1];}}return step;}/**\r\n * Gets threshold for moving from `fromStep` to `next_step`.\r\n * @param  {Object} fromStep - From step.\r\n * @param  {Object} next_step - To step.\r\n * @param  {number} now - The current timestamp.\r\n * @param  {boolean} future - Is `true` for future dates (\"in 5 minutes\").\r\n * @return {number}\r\n * @throws Will throw if no threshold is found.\r\n */function getThreshold(fromStep,toStep,now,future){var threshold;// Allows custom thresholds when moving\n// from a specific step to a specific step.\nif(fromStep&&(fromStep.id||fromStep.unit)){threshold=toStep[\"threshold_for_\".concat(fromStep.id||fromStep.unit)];}// If no custom threshold is set for this transition\n// then use the usual threshold for the next step.\nif(threshold===undefined){threshold=toStep.threshold;}// Convert threshold to a number.\nif(typeof threshold==='function'){threshold=threshold(now,future);}// Throw if no threshold is found.\nif(fromStep&&typeof threshold!=='number'){// Babel transforms `typeof` into some \"branches\"\n// so istanbul will show this as \"branch not covered\".\n/* istanbul ignore next */var type=_typeof(threshold);throw new Error(\"Each step of a gradation must have a threshold defined except for the first one. Got \\\"\".concat(threshold,\"\\\", \").concat(type,\". Step: \").concat(JSON.stringify(toStep)));}return threshold;}/**\r\n * @param  {number} elapsed - Time elapsed (in seconds).\r\n * @param  {number} now - Current timestamp.\r\n * @param  {Object} gradation - Gradation.\r\n * @param  {number} i - Gradation step currently being tested.\r\n * @return {number} Gradation step index.\r\n */function findGradationStep(elapsed,now,gradation){var i=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;// If the threshold for moving from previous step\n// to this step is too high then return the previous step.\nif(Math.abs(elapsed)<getThreshold(gradation[i-1],gradation[i],now,elapsed<0)){return i-1;}// If it's the last step of gradation then return it.\nif(i===gradation.length-1){return i;}// Move to the next step.\nreturn findGradationStep(elapsed,now,gradation,i+1);}/**\r\n * Leaves only allowed gradation steps.\r\n * @param  {Object[]} gradation\r\n * @param  {string[]} units - Allowed time units.\r\n * @return {Object[]}\r\n */function getAllowedSteps(gradation,units){return gradation.filter(function(_ref){var unit=_ref.unit;// If this step has a `unit` defined\n// then this `unit` must be in the list of `units` allowed.\nif(unit){return units.indexOf(unit)>=0;}// A gradation step is not required to specify a `unit`.\n// E.g. for Twitter gradation it specifies `format()` instead.\nreturn true;});}","map":null,"metadata":{},"sourceType":"module"}