{"ast":null,"code":"\"use strict\";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});exports.Graph=void 0;const index_1=require(\"./index\");const index_2=require(\"./index\");const index_3=require(\"./index\");const lodash_1=__importDefault(require(\"lodash\"));const graph_algorithms_tarjan_1=require(\"@teambit/graph.algorithms.tarjan\");const node_1=require(\"./node\");const edge_1=require(\"./edge\");/**\n * Graph abstractly represents a graph with arbitrary objects\n * associated with nodes and edges. The graph provides basic\n * operations to access and manipulate the data associated with\n * nodes and edges as well as the underlying structure.\n *\n * @tparam N the node attribute type\n * @tparam E the edge attribute type\n */class Graph{constructor(/**\n     * array of graph nodes.\n     */nodes=[],/**\n     * array of graph edges.\n     */edges=[]){this._nodes=new Map();this._edges=new Map();nodes.forEach(elem=>this.setNode(elem));edges.forEach(elem=>this.setEdge(elem));}create(nodes=[],edges=[]){return new Graph(nodes,edges);}/**\n     * set a new node on the graph or override existing node with the same key\n     * @param id string\n     * @param node a node of generic data type N\n     */setNode(node,overrideExisting=true){if(!this.hasNode(node.id)){this._nodes.set(node.id,node);}else if(overrideExisting){let existingNode=this.node(node.id);if(existingNode){existingNode.attr=node.attr;}}return this;}/**\n     * set a new edge on the graph or override existing edge with the same source and target keys.\n     * @param sourceId the id of the source node\n     * @param targetId the id of the target node\n     * @param edge an edge of the generic data type E\n     */setEdge(edge,overrideExisting=true){const sourceId=edge.sourceId;const targetId=edge.targetId;if(this.hasEdge(sourceId,targetId)){if(overrideExisting){let existingEdge=this.edge(sourceId,targetId);if(existingEdge){existingEdge.attr=edge.attr;}return this;}else{return this;}}const id=index_2.Edge.edgeId(sourceId,targetId);this._edges.set(id,edge);if(this._nodes.has(sourceId)){let sourceNode=this._nodes.get(sourceId);if(sourceNode!==undefined){sourceNode.setOutEdge(id);}}else{throw Error(`source node ${sourceId} does not exist`);}if(this._nodes.has(targetId)){let targetNode=this._nodes.get(targetId);if(targetNode!==undefined){targetNode.setInEdge(id);}}else{throw Error(`target node ${targetId} does not exist`);}return this;}/**\n     * set multiple nodes on the graph.\n     * @param nodes an array of objects {id, node}\n     */setNodes(nodes,overrideExisting=true){nodes.forEach(node=>{if(!this.hasNode(node.id)){this.setNode(node);}else if(!!overrideExisting){let existingNode=this.node(node.id);if(existingNode){existingNode.attr=node.attr;}}});return this;}/**\n     * set multiple edges on the graph.\n     * @param edges an array of objects {sourceId, targetId, edge}\n     */setEdges(edges,overrideExisting=true){edges.forEach(edge=>{if(!this.hasEdge(edge.sourceId,edge.targetId)){this.setEdge(edge);}else if(!!overrideExisting){let existingEdge=this.edge(edge.sourceId,edge.targetId);if(existingEdge){existingEdge.attr=edge.attr;}}});return this;}/**\n     * determine whether a node exists on the graph.\n     * @param id the node id - string\n     */hasNode(id){return this._nodes.has(id);}/**\n     * determine whether an edge exists on the graph.\n     * @param sourceId the source node id (string)\n     * @param targetId the target node id (string)\n     */hasEdge(sourceId,targetId){return this._edges.has(index_2.Edge.edgeId(sourceId,targetId));}/**\n     * get a node from the graph by its ID. Undefined if id is not in graph.\n     * @param id the id of the node - string\n     */node(id){return this._nodes.get(id);}/**\n     * get a list of nodes from the graph by their IDs.\n     * @param ids the ids of the nodes - string[]\n     */getNodes(ids){let nodes=[];ids.forEach(id=>{const node=this._nodes.get(id);if(!!node)nodes.push(node);});return nodes;}/**\n     * get an edge from the graph by its ID. Undefined if id is not in graph.\n     * @param sourceId the id of the source node\n     * @param targetId the id of the target node\n     */edge(sourceId,targetId){return this._edges.get(index_2.Edge.edgeId(sourceId,targetId));}/**\n     * returns a Edge object from the graph by its ID. Undefined if id is not in graph.\n     * @param edgeId the internal id the graph assigns to edges of the form \"a->b\"\n     */edgeById(edgeId){return this._edges.get(edgeId);}/**\n     * get an edgeId of the format \"a->b\" and returns its source node Id and target node id.\n     * @param edgeId\n     */edgeNodesById(edgeId){var _a,_b;return{sourceId:(_a=this._edges.get(edgeId))===null||_a===void 0?void 0:_a.sourceId,targetId:(_b=this._edges.get(edgeId))===null||_b===void 0?void 0:_b.targetId};}/**\n     * get a map of all <nodeId, node> in the graph.\n     */get nodeMap(){return this._nodes;}/**\n     * get all <edgeId, edge> in the graph.\n     */get edgeMap(){return this._edges;}/**\n     * get an array of all nodes in the graph.\n     * note, this creates a new array every time\n     */get nodes(){return[...this._nodes.values()];}/**\n     * get an array of all edges in the graph.\n     * note, this creates a new array every time\n     */get edges(){return[...this._edges.values()];}/**\n     * return the number of nodes in the graph.\n     */nodeCount(){return this._nodes.size;}/**\n     * return the number of edges in the graph.\n     */edgeCount(){return this._edges.size;}/**\n     * return all nodes that have only out edges and no in edges.\n     */sources(){let nodesToReturn=[...this._nodes.values()];return nodesToReturn.filter(node=>node.isSource()).map(elem=>elem);}/**\n     * return all nodes that have only in edges and no out edges.\n     */sinks(){let nodesToReturn=[...this._nodes.values()];return nodesToReturn.filter(node=>node.isSink()).map(elem=>elem);}/**\n     * delete a single node by id if exists. Note that all edges to and from this node will also be deleted.\n     * @param id the id of the node to be deleted\n     */deleteNode(id){const node=this.node(id);if(typeof node==='undefined')return;node.nodeEdges.forEach(edgeId=>{const{sourceId,targetId}=index_2.Edge.parseEdgeId(edgeId);this.deleteEdge(sourceId,targetId);});this._nodes.delete(id);}/**\n     * delete a single edge by source and target ids if exist.\n     * @param sourceId the id of the source node of the edge to be deleted\n     * @param targetId the id of the target node of the edge to be deleted\n     */deleteEdge(sourceId,targetId){const edgeId=index_2.Edge.edgeId(sourceId,targetId);const edge=this._edges.get(edgeId);if(edge!==undefined){let sourceNode=this._nodes.get(sourceId);if(sourceNode!==undefined){sourceNode.deleteEdge(edgeId);}let targetNode=this._nodes.get(targetId);if(targetNode!==undefined){targetNode.deleteEdge(edgeId);}}this._edges.delete(edgeId);}/**\n     * return a map <string, Edge> of all inbound edges of the given node.\n     * @param nodeId string\n     */inEdgesMap(nodeId){return this._inEdges(nodeId);}/**\n     * return a map <string, Edge> of all outbound edges of the given node.\n     * @param nodeId string\n     */outEdgesMap(nodeId){return this._outEdges(nodeId);}/**\n     * return a map <string, Edge> of all inbound and outbound edges of the given node.\n     * @param nodeId string\n     */nodeEdgesMap(nodeId){return this._nodeEdges(nodeId);}/**\n     * return an array of all inbound edges of the given node.\n     * @param nodeId string\n     */inEdges(nodeId){return[...this._inEdges(nodeId).values()];}/**\n     * return an array of all outbound edges of the given node.\n     * @param nodeId string\n     */outEdges(nodeId){return[...this._outEdges(nodeId).values()];}/**\n     * return an array of all inbound and outbound edges of the given node.\n     * @param nodeId string\n     */nodeEdges(nodeId){return[...this._nodeEdges(nodeId).values()];}/**\n     * private. return a map of all <edgeId, Edge<E>> that point to the given node.\n     * @param nodeId\n     */_inEdges(nodeId){let newEdges=new Map();const node=this.node(nodeId);if(node===undefined)return newEdges;node.inEdges.forEach(edgeId=>{let{sourceId,targetId}=index_2.Edge.parseEdgeId(edgeId);let edge=this.edge(sourceId,targetId);if(edge!==undefined){newEdges.set(edgeId,edge);}});return newEdges;}/**\n     * return a map of all <edgeId, Edge<E>> that point from the given node to other nodes.\n     * @param nodeId\n     */_outEdges(nodeId){let newEdges=new Map();const node=this.node(nodeId);if(node===undefined)return newEdges;node.outEdges.forEach(edgeId=>{let{sourceId,targetId}=index_2.Edge.parseEdgeId(edgeId);let edge=this.edge(sourceId,targetId);if(edge!==undefined){newEdges.set(edgeId,edge);}});return newEdges;}/**\n     * return a map of all <edgeId, Edge<E>> that point to or from the given node.\n     * @param nodeId\n     */_nodeEdges(nodeId){let newEdges=new Map();const node=this.node(nodeId);if(node===undefined)return newEdges;node.nodeEdges.forEach(edgeId=>{let{sourceId,targetId}=index_2.Edge.parseEdgeId(edgeId);let edge=this.edge(sourceId,targetId);if(edge!==undefined){newEdges.set(edgeId,edge);}});return newEdges;}/**\n     * return a map of all <nodeId, node> that are immediately pointed to by the given node.\n     * @param nodeId the id of the source node\n     * @param { nodeFilter, edgeFilter } - object with two boolean functions: nodeFilter which traverses the graph only on\n     * nodes that return truthy for it, and edgeFilter which performs the same for edges.\n     */successorMap(nodeId,{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){return this._successors(nodeId,{nodeFilter,edgeFilter});}/**\n     * return a map of all <nodeId, node> that point to by the given node.\n     * @param nodeId the id of the target node\n     * @param { nodeFilter, edgeFilter } - object with two boolean functions: nodeFilter which traverses the graph only on\n     * nodes that return truthy for it, and edgeFilter which performs the same for edges.\n     * */predecessorMap(nodeId,{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){return this._predecessors(nodeId,{nodeFilter,edgeFilter});}/**\n     * return a map of all <nodeId, node> that are directly or indirectly connected to the given node.\n     * @param nodeId the id of the node\n     * @param { nodeFilter, edgeFilter } - object with two boolean functions: nodeFilter which traverses the graph only on\n     * nodes that return truthy for it, and edgeFilter which performs the same for edges.\n     */neighborMap(nodeId,{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){return this._neighbors(nodeId,{nodeFilter,edgeFilter});}/**\n     * Internal. Return a map of all <string, Node> that are immediately pointed to by the given node.\n     * @param nodeId the id of the source node\n     * @param { nodeFilter, edgeFilter } - object with two boolean functions: nodeFilter which traverses the graph only on\n     * nodes that return truthy for it, and edgeFilter which performs the same for edges.\n     * */_successors(nodeId,{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){let successors=new Map();const node=this.node(nodeId);if(node===undefined)return successors;node.outEdges.forEach(edgeId=>{const edge=this._edges.get(edgeId);if(edge!=undefined&&edgeFilter(edge)){const{sourceId,targetId}=index_2.Edge.parseEdgeId(edgeId);const targetNode=this.node(targetId);if(!!targetId&&targetNode!==undefined&&nodeFilter(targetNode)){successors.set(targetId,targetNode);}}});return successors;}/**\n     * Private. Return a map of all <string, Node> that point to by the given node.\n     * @param nodeId the id of the target node\n     * @param { nodeFilter, edgeFilter } - object with two boolean functions: nodeFilter which traverses the graph only on\n     * nodes that return truthy for it, and edgeFilter which performs the same for edges.\n     */_predecessors(nodeId,{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){let predecessors=new Map();const node=this.node(nodeId);if(node===undefined)return predecessors;node.inEdges.forEach(edgeId=>{const edge=this._edges.get(edgeId);if(edge!=undefined&&edgeFilter(edge)){const{sourceId,targetId}=index_2.Edge.parseEdgeId(edgeId);const sourceNode=this.node(sourceId);if(!!sourceId&&sourceNode!==undefined&&nodeFilter(sourceNode)){predecessors.set(sourceId,sourceNode);}}});return predecessors;}/**\n     * return a map of all <string, Node> that are directly or indirectly connected to the given node.\n     * @param nodeId the id of the node\n     * @param { nodeFilter, edgeFilter } - object with two boolean functions: nodeFilter which traverses the graph only on\n     * nodes that return truthy for it, and edgeFilter which performs the same for edges.\n     */_neighbors(nodeId,{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){let neighbors=new Map([...this._predecessors(nodeId,{nodeFilter,edgeFilter}),...this._successors(nodeId,{nodeFilter,edgeFilter})]);return neighbors;}/**\n     * return a sub-graph of all the nodes and edges that are recursively successors of the given node.\n     * @param nodeIds the source nodes of the sub-graph required\n     * @param { nodeFilter, edgeFilter } - object with two boolean functions: nodeFilter which traverses the graph only on\n     * nodes that return truthy for it, and edgeFilter which performs the same for edges.\n     */successorsSubgraph(nodeIds,{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){return this._buildSubgraphs(nodeIds,'successors',{nodeFilter,edgeFilter});}_alreadyProcessed(nodeId,subgraphs){for(const graph of subgraphs){if(graph.hasNode(nodeId)){return true;}}return false;}_buildSubgraphs(nodeIds,order,{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){let subgraphs=[];if(!Array.isArray(nodeIds)){return this._buildSubgraph(nodeIds,order,{nodeFilter,edgeFilter});}nodeIds.forEach(nodeId=>{if(this._alreadyProcessed(nodeId,subgraphs)){return;}subgraphs.push(this._buildSubgraph(nodeId,order,{nodeFilter,edgeFilter}));});if(subgraphs.length===1){return subgraphs[0];}let mergedGraphs=this.create();if(subgraphs.length){mergedGraphs=subgraphs[0].merge(subgraphs);}return mergedGraphs;}_buildSubgraph(nodeId,order,{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){let g=this.create();let graphNode=this.node(nodeId);if(!graphNode){throw new Error(`Node ${nodeId} does not exist on graph`);}else{g.setNode(graphNode);}return order==='successors'?this._successorsSubgraphUtil(nodeId,g,{},{nodeFilter,edgeFilter}):this._predecessorsSubgraphUtil(nodeId,g,{},{nodeFilter,edgeFilter});}_successorsSubgraphUtil(nodeId,successorsGraph,visited={},{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){const successors=[...this._successors(nodeId,{nodeFilter,edgeFilter}).keys()]||[];if(successors.length>0&&!visited[nodeId]){successors.forEach(successor=>{visited[nodeId]=true;const newNode=this._nodes.get(successor);const newEdge=this._edges.get(index_2.Edge.edgeId(nodeId,successor));if(newNode!==undefined&&newEdge!=undefined){successorsGraph.setNode(newNode);successorsGraph.setEdge(newEdge);return this._successorsSubgraphUtil(successor,successorsGraph,visited,{nodeFilter,edgeFilter});}});}return successorsGraph;}/**\n     * return an array of all the nodes that are recursively successors of the given node (that the given node points to).\n     * @param node the source node of the successor array required\n     * @param { nodeFilter, edgeFilter } - object with two boolean functions: nodeFilter which traverses the graph only on\n     * nodes that return truthy for it, and edgeFilter which performs the same for edges.\n     */successors(nodeId,{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){const successorIds=lodash_1.default.uniq(this._successorsArrayUtil(nodeId,[],{},{nodeFilter,edgeFilter}));let successors=[];successorIds.forEach(id=>{let node=this.node(id);if(node!=undefined){successors.push(node);}});return successors;}_successorsArrayUtil(nodeId,successorsList=[],visited={},{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){const successors=[...this._successors(nodeId,{nodeFilter,edgeFilter}).keys()]||[];if(successors.length>0&&!visited[nodeId]){successors.forEach(successor=>{visited[nodeId]=true;successorsList.push(successor);return this._successorsArrayUtil(successor,successorsList,visited,{nodeFilter,edgeFilter});});}return successorsList;}successorsLayers(nodeKey,{nodeFilter=returnTrue,edgeFilter=returnTrue,order='fromSource'}={}){let successorsGraph=this.successorsSubgraph(nodeKey,{nodeFilter,edgeFilter});if(this.isCyclic(successorsGraph)){throw new Error('cyclic dependency');}let layers=[];layers[0]=[nodeKey];let floor=0;let rawLayers=this._successorsLayersUtil([nodeKey],layers,floor,{nodeFilter,edgeFilter});return arrangeLayers(rawLayers,order);}_successorsLayersUtil(nodeKeys,layers,floor,{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){if(nodeKeys.length>0){let nextFloor=floor+1;layers.push([]);layers[floor].forEach(successor=>{const successors=[...this.successorMap(successor,{nodeFilter,edgeFilter}).keys()];layers[nextFloor]=layers[nextFloor].concat(successors);});return this._successorsLayersUtil(layers[nextFloor],layers,nextFloor,{nodeFilter,edgeFilter});}return layers;}/**\n     * return a sub-graph of all the nodes and edges that are recursively predecessors (point to) of the given node.\n     * @param nodeIds the target nodes of the sub-graph required\n     * @param { nodeFilter, edgeFilter } - object with two boolean functions: nodeFilter which traverses the graph only on\n     * nodes that return truthy for it, and edgeFilter which performs the same for edges.\n     */predecessorsSubgraph(nodeIds,{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){return this._buildSubgraphs(nodeIds,'predecessors',{nodeFilter,edgeFilter});}_predecessorsSubgraphUtil(nodeId,predecessorsGraph,visited={},{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){const predecessors=[...this._predecessors(nodeId,{nodeFilter,edgeFilter}).keys()]||[];if(predecessors.length>0&&!visited[nodeId]){predecessors.forEach(predecessor=>{visited[nodeId]=true;const newNode=this._nodes.get(predecessor);const newEdge=this._edges.get(index_2.Edge.edgeId(predecessor,nodeId));if(newNode!==undefined&&newEdge!=undefined){predecessorsGraph.setNode(newNode);predecessorsGraph.setEdge(newEdge);return this._predecessorsSubgraphUtil(predecessor,predecessorsGraph,visited,{nodeFilter,edgeFilter});}});}return predecessorsGraph;}/**\n     * return an array of all the nodes that are recursively predecessors of the given node (that point to the given node).\n     * @param node the source node of the predecessor array required\n     * @param { nodeFilter, edgeFilter } - object with two boolean functions: nodeFilter which traverses the graph only on\n     * nodes that return truthy for it, and edgeFilter which performs the same for edges.\n     */predecessors(nodeId,{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){const predecessorIds=lodash_1.default.uniq(this._predecessorsArrayUtil(nodeId,[],{},{nodeFilter,edgeFilter}));let predecessors=[];predecessorIds.forEach(id=>{let node=this.node(id);if(node!=undefined){predecessors.push(node);}});return predecessors;}_predecessorsArrayUtil(nodeId,predecessorsList=[],visited={},{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){const predecessors=[...this._predecessors(nodeId,{nodeFilter,edgeFilter}).keys()]||[];if(predecessors.length>0&&!visited[nodeId]){predecessors.forEach(predecessor=>{visited[nodeId]=true;predecessorsList.push(predecessor);return this._predecessorsArrayUtil(predecessor,predecessorsList,visited,{nodeFilter,edgeFilter});});}return predecessorsList;}predecessorsLayers(nodeKey,{nodeFilter=returnTrue,edgeFilter=returnTrue,order='fromSource'}={}){let successorsGraph=this.predecessorsSubgraph(nodeKey,{nodeFilter,edgeFilter});// first getting as a graph to check if cyclic\nif(this.isCyclic(successorsGraph)){throw new Error('cyclic sub-graph');}let layers=[];layers[0]=[nodeKey];let floor=0;let rawLayers=this._predecessorsLayersUtil([nodeKey],layers,floor,{nodeFilter,edgeFilter});return arrangeLayers(rawLayers,order);}_predecessorsLayersUtil(nodeKeys,layers,floor,{nodeFilter=returnTrue,edgeFilter=returnTrue}={}){if(nodeKeys.length>0){let nextFloor=floor+1;layers.push([]);layers[floor].forEach(predecessor=>{const predecessors=[...this.predecessorMap(predecessor,{nodeFilter,edgeFilter}).keys()];layers[nextFloor]=layers[nextFloor].concat(predecessors);});return this._predecessorsLayersUtil(layers[nextFloor],layers,nextFloor,{nodeFilter,edgeFilter});}return layers;}/**\n     * A topological sort of the graph\n     */toposort(reverse=false){let nodes=this._toposort().map(nodeId=>this.node(nodeId));nodes=lodash_1.default.compact(nodes);// remove any undefined entries\n//@ts-ignore\nreturn reverse?nodes.reverse():nodes;}_transformEdges(){let edges=[];this._edges.forEach(originalEdge=>{edges.push([originalEdge.sourceId,originalEdge.targetId]);});return edges;}_toposort(){const nodes=[...this._nodes.keys()];const edges=this._transformEdges();var cursor=nodes.length,sorted=new Array(cursor),visited={},i=cursor,outgoingEdges=makeOutgoingEdges(edges),nodesHash=makeNodesHash(nodes);// check for unknown nodes\nedges.forEach(function(edge){if(!nodesHash.has(edge[0])||!nodesHash.has(edge[1])){throw new Error('Unknown node. There is an unknown node in the supplied edges.');}});while(i--){//@ts-ignore\nif(!visited[i])visit(nodes[i],i,new Set());}return sorted;//@ts-ignore\nfunction visit(node,i,predecessors){if(predecessors.has(node)){var nodeRep;try{nodeRep=', node was:'+JSON.stringify(node);}catch(e){nodeRep='';}throw new index_3.CyclicError('Cyclic dependency'+nodeRep);}if(!nodesHash.has(node)){throw new Error('Found unknown node. Make sure to provide all involved nodes. Unknown node: '+JSON.stringify(node));}//@ts-ignore\nif(visited[i])return;//@ts-ignore\nvisited[i]=true;var outgoing=outgoingEdges.get(node)||new Set();outgoing=Array.from(outgoing);if(i=outgoing.length){predecessors.add(node);do{var child=outgoing[--i];visit(child,nodesHash.get(child),predecessors);}while(i);predecessors.delete(node);}sorted[--cursor]=node;}}isCyclic(graph=this){try{graph.toposort();}catch(e){if(e instanceof index_3.CyclicError){return true;}throw e;}return false;}findCycles(graph=this){return findCycles(graph);}/**\n     * Merge the provided graphs (of the same type as this graph) from right to left into this graph\n     * @param graphs any number of Graph objects\n     */merge(graphs){let mergedGraph=this;graphs.forEach(incomingGraph=>{var _a,_b;//iterate on nodes\nfor(let[nodeId,node]of incomingGraph.nodeMap){mergedGraph.setNode(node);// override right node data with left (incoming) node data if this node id exists or creates a new node with this id if doesn't exist\n}//iterate on edges\nfor(let[edgeId,edge]of incomingGraph.edgeMap){const sourceId=(_a=incomingGraph._edges.get(edgeId))===null||_a===void 0?void 0:_a.sourceId;const targetId=(_b=incomingGraph._edges.get(edgeId))===null||_b===void 0?void 0:_b.targetId;if(mergedGraph.edgeMap.has(edgeId)&&!!sourceId&&!!targetId){mergedGraph.setEdge(edge);// override right edge data with left (incoming) edge data if edge id exists\n}else{// make sure both source and target nodes exist\nif(!!sourceId&&!!targetId&&mergedGraph.hasNode(sourceId)&&mergedGraph.hasNode(targetId)){mergedGraph.setEdge(edge);}else{throw index_3.NodeDoesntExist;}}}});return mergedGraph;}/**\n     * find all paths from one node to another node.\n     * @param sourceId\n     * @param targetId\n     */allPaths(sourceId,targetId){const paths=this._allPaths(sourceId,targetId,[],[]);return paths;}_allPaths(source,target,currPath,paths,visited={}){// Mark current node as visited and store in current path\nvisited[source]=true;currPath.push(source);// If current node is same as destination, add current path to paths\nif(source===target){paths.push(lodash_1.default.cloneDeep(currPath));}else{// If current node is not target, recur for all its succesors\nconst successors=[...this._successors(source).keys()]||[];successors.forEach(nodeId=>{if(!visited[nodeId]){this._allPaths(nodeId,target,currPath,paths,visited);}});}// Remove current node from currentPath[] and mark it as unvisited\ncurrPath.pop();visited[source]=false;return paths;}/***\n     * graph to JSON object\n     */toJson(graph){return graph?this._toJson(graph,'object'):this._toJson(this,'object');}/**\n     * stringify the graph to a JSON string\n     * @param graph\n     */stringify(graph){return graph?this._toJson(graph,'string'):this._toJson(this,'string');}/**\n     * build graph from json\n     * @param json should be of the format:\n     * {\n     *   nodes: {id: string, node: N}[],\n     *   edges: {sourceId: string, targetId: string, edge:E}[]\n     * }\n     */static parse(json,parseNode=node_1.genericParseNode,parseEdge=edge_1.genericParseEdge){return this._fromJson(json,parseNode,parseEdge);}/**\n     * Gets a graph with (possibly) nodes that point to each other with two or more edges\n     * and converts them to one bidirectional edge for each of the node pairs\n     */static convertToBidirectionalEdges(graph){let newEdgeMap=new Map();for(const[key,val]of graph.edgeMap){if(!newEdgeMap.has(key)){const reversedEdgeKey=val.targetId+'->'+val.sourceId;if(!newEdgeMap.has(reversedEdgeKey)){newEdgeMap.set(key,val);}else{let reveresedEdge=newEdgeMap.get(reversedEdgeKey);reveresedEdge===null||reveresedEdge===void 0?void 0:reveresedEdge.setBidirectional(true);}}}return new Graph(graph.nodes,[...newEdgeMap.values()]);}_toJson(graph,returnType){let nodeArray=[];for(let[nodeId,nodeData]of graph.nodeMap.entries()){const graphNode=graph.node(nodeId);if(!!graphNode){let convertedNode;if(returnType==='object'){if(!!graphNode.attr['toJson']&&typeof graphNode.attr['toJson']==='function'){convertedNode=graphNode.attr.toJson();}else{convertedNode=(0,node_1.genericNodeToJson)(graphNode.attr);}}else{convertedNode=graphNode.stringify();}nodeArray.push({id:nodeId,attr:convertedNode});}}let edgeArray=[];for(let[edgeId,edgeData]of graph.edgeMap.entries()){const graphEdge=graph.edgeById(edgeId);if(!!graphEdge){let convertedEdge;if(returnType==='object'){if(!!graphEdge.attr['toJson']&&typeof graphEdge.attr['toJson']==='function'){convertedEdge=graphEdge.attr.toJson();}else{convertedEdge=(0,node_1.genericNodeToJson)(graphEdge.attr);}}else{convertedEdge=graphEdge.stringify();}edgeArray.push({sourceId:graphEdge.sourceId,targetId:graphEdge.targetId,attr:convertedEdge,bidirectional:graphEdge.bidirectional});}}let json={nodes:nodeArray,edges:edgeArray};return returnType==='object'?json:JSON.stringify(json);}/**\n     * builds a graph from the provided JSON.\n     * @param json should be of the format:\n     * {\n     *   nodes: {id: string, node: N}[],\n     *   edges: {sourceId: string, targetId: string, edge:E}[]\n     * }\n     */static _fromJson(json,parseNode,parseEdge){const obj=typeof json==='string'?JSON.parse(json):json;let graph=new Graph();if(!obj.hasOwnProperty('nodes')||!obj.hasOwnProperty('edges')){throw Error('missing properties on JSON. Should contain nodes: {id: string, node: N}[], and edges: {sourceId: string, targetId: string, edge:E}[]');}obj.nodes.forEach(nodeObj=>{const res=index_1.Node.fromObject(nodeObj,parseNode);graph.setNode(res);});obj.edges.forEach(edgeObj=>{const res=index_2.Edge.fromObject(edgeObj,parseEdge);graph.setEdge(res);});return graph;}bfs(){}dfs(){}}exports.Graph=Graph;function returnTrue(){return true;}//@ts-ignore\nfunction makeOutgoingEdges(arr){var edges=new Map();for(var i=0,len=arr.length;i<len;i++){var edge=arr[i];if(!edges.has(edge[0]))edges.set(edge[0],new Set());if(!edges.has(edge[1]))edges.set(edge[1],new Set());edges.get(edge[0]).add(edge[1]);}return edges;}//@ts-ignore\nfunction makeNodesHash(arr){var res=new Map();for(var i=0,len=arr.length;i<len;i++){res.set(arr[i],i);}return res;}function findCycles(g){return lodash_1.default.filter((0,graph_algorithms_tarjan_1.tarjan)(g),function(cmpt){return cmpt.length>1||cmpt.length===1&&g.hasEdge(cmpt[0],cmpt[0]);});}function arrangeLayers(layers,order){let finalLayers=[];let seenNodes=[];layers=layers.reverse();let i=0;layers.forEach(layer=>{if(layer.length>0){finalLayers.push([]);layer.forEach(node=>{if(seenNodes.indexOf(node)==-1){//if node not seen\nseenNodes.push(node);finalLayers[i].push(node);}});i++;}});return order==='fromSource'?finalLayers.reverse():finalLayers;}","map":null,"metadata":{},"sourceType":"module"}