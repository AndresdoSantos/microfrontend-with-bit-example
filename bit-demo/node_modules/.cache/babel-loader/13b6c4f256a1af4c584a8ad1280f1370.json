{"ast":null,"code":"import connectCallReceiver from'../connectCallReceiver';import connectCallSender from'../connectCallSender';/**\n * Handles an ACK handshake message.\n */export default((serializedMethods,childOrigin,originForSending,destructor,log)=>{const{destroy,onDestroy}=destructor;let destroyCallReceiver;let receiverMethodNames;// We resolve the promise with the call sender. If the child reconnects\n// (for example, after refreshing or navigating to another page that\n// uses Penpal, we'll update the call sender with methods that match the\n// latest provided by the child.\nconst callSender={};return event=>{if(childOrigin!=='*'&&event.origin!==childOrigin){log(`Parent: Handshake - Received ACK message from origin ${event.origin} which did not match expected origin ${childOrigin}`);return;}log('Parent: Handshake - Received ACK');const info={localName:'Parent',local:window,remote:event.source,originForSending:originForSending,originForReceiving:childOrigin};// If the child reconnected, we need to destroy the prior call receiver\n// before setting up a new one.\nif(destroyCallReceiver){destroyCallReceiver();}destroyCallReceiver=connectCallReceiver(info,serializedMethods,log);onDestroy(destroyCallReceiver);// If the child reconnected, we need to remove the methods from the\n// previous call receiver off the sender.\nif(receiverMethodNames){receiverMethodNames.forEach(receiverMethodName=>{delete callSender[receiverMethodName];});}receiverMethodNames=event.data.methodNames;const destroyCallSender=connectCallSender(callSender,info,receiverMethodNames,destroy,log);onDestroy(destroyCallSender);return callSender;};});","map":null,"metadata":{},"sourceType":"module"}