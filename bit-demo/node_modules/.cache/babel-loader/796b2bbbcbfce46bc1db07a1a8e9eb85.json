{"ast":null,"code":"import isPromise from'./jsutils/isPromise';import{parse}from'./language/parser';import{validate}from'./validation/validate';import{validateSchema}from'./type/validate';import{execute}from'./execution/execute';/**\n * This is the primary entry point function for fulfilling GraphQL operations\n * by parsing, validating, and executing a GraphQL document along side a\n * GraphQL schema.\n *\n * More sophisticated GraphQL servers, such as those which persist queries,\n * may wish to separate the validation and execution phases to a static time\n * tooling step, and a server runtime step.\n *\n * Accepts either an object with named arguments, or individual arguments:\n *\n * schema:\n *    The GraphQL type system to use when validating and executing a query.\n * source:\n *    A GraphQL language formatted string representing the requested operation.\n * rootValue:\n *    The value provided as the first argument to resolver functions on the top\n *    level type (e.g. the query object type).\n * contextValue:\n *    The context value is provided as an argument to resolver functions after\n *    field arguments. It is used to pass shared information useful at any point\n *    during executing this query, for example the currently logged in user and\n *    connections to databases or other services.\n * variableValues:\n *    A mapping of variable name to runtime value to use for all variables\n *    defined in the requestString.\n * operationName:\n *    The name of the operation to use if requestString contains multiple\n *    possible operations. Can be omitted if requestString contains only\n *    one operation.\n * fieldResolver:\n *    A resolver function to use when one is not provided by the schema.\n *    If not provided, the default field resolver is used (which looks for a\n *    value or method on the source value with the field's name).\n * typeResolver:\n *    A type resolver function to use when none is provided by the schema.\n *    If not provided, the default type resolver is used (which looks for a\n *    `__typename` field or alternatively calls the `isTypeOf` method).\n */export function graphql(argsOrSchema,source,rootValue,contextValue,variableValues,operationName,fieldResolver,typeResolver){var _arguments=arguments;/* eslint-enable no-redeclare */ // Always return a Promise for a consistent API.\nreturn new Promise(function(resolve){return resolve(// Extract arguments from object args if provided.\n_arguments.length===1?graphqlImpl(argsOrSchema):graphqlImpl({schema:argsOrSchema,source:source,rootValue:rootValue,contextValue:contextValue,variableValues:variableValues,operationName:operationName,fieldResolver:fieldResolver,typeResolver:typeResolver}));});}/**\n * The graphqlSync function also fulfills GraphQL operations by parsing,\n * validating, and executing a GraphQL document along side a GraphQL schema.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */export function graphqlSync(argsOrSchema,source,rootValue,contextValue,variableValues,operationName,fieldResolver,typeResolver){/* eslint-enable no-redeclare */ // Extract arguments from object args if provided.\nvar result=arguments.length===1?graphqlImpl(argsOrSchema):graphqlImpl({schema:argsOrSchema,source:source,rootValue:rootValue,contextValue:contextValue,variableValues:variableValues,operationName:operationName,fieldResolver:fieldResolver,typeResolver:typeResolver});// Assert that the execution was synchronous.\nif(isPromise(result)){throw new Error('GraphQL execution failed to complete synchronously.');}return result;}function graphqlImpl(args){var schema=args.schema,source=args.source,rootValue=args.rootValue,contextValue=args.contextValue,variableValues=args.variableValues,operationName=args.operationName,fieldResolver=args.fieldResolver,typeResolver=args.typeResolver;// Validate Schema\nvar schemaValidationErrors=validateSchema(schema);if(schemaValidationErrors.length>0){return{errors:schemaValidationErrors};}// Parse\nvar document;try{document=parse(source);}catch(syntaxError){return{errors:[syntaxError]};}// Validate\nvar validationErrors=validate(schema,document);if(validationErrors.length>0){return{errors:validationErrors};}// Execute\nreturn execute({schema:schema,document:document,rootValue:rootValue,contextValue:contextValue,variableValues:variableValues,operationName:operationName,fieldResolver:fieldResolver,typeResolver:typeResolver});}","map":null,"metadata":{},"sourceType":"module"}