{"ast":null,"code":"const SemVer=require('../classes/semver');const parse=require('./parse');const{re,t}=require('../internal/re');const coerce=(version,options)=>{if(version instanceof SemVer){return version;}if(typeof version==='number'){version=String(version);}if(typeof version!=='string'){return null;}options=options||{};let match=null;if(!options.rtl){match=version.match(re[t.COERCE]);}else{// Find the right-most coercible string that does not share\n// a terminus with a more left-ward coercible string.\n// Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n//\n// Walk through the string checking with a /g regexp\n// Manually set the index so as to pick up overlapping matches.\n// Stop when we get a match that ends at the string end, since no\n// coercible string can be more right-ward without the same terminus.\nlet next;while((next=re[t.COERCERTL].exec(version))&&(!match||match.index+match[0].length!==version.length)){if(!match||next.index+next[0].length!==match.index+match[0].length){match=next;}re[t.COERCERTL].lastIndex=next.index+next[1].length+next[2].length;}// leave it in a clean state\nre[t.COERCERTL].lastIndex=-1;}if(match===null)return null;return parse(`${match[2]}.${match[3]||'0'}.${match[4]||'0'}`,options);};module.exports=coerce;","map":null,"metadata":{},"sourceType":"module"}