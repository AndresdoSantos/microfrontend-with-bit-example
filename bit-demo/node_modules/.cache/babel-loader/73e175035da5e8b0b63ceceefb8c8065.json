{"ast":null,"code":"function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(source,true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(source).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}import objectEntries from'../polyfills/objectEntries';import inspect from'../jsutils/inspect';import keyMap from'../jsutils/keyMap';import mapValue from'../jsutils/mapValue';import toObjMap from'../jsutils/toObjMap';import devAssert from'../jsutils/devAssert';import keyValMap from'../jsutils/keyValMap';import instanceOf from'../jsutils/instanceOf';import isObjectLike from'../jsutils/isObjectLike';import identityFunc from'../jsutils/identityFunc';import defineToJSON from'../jsutils/defineToJSON';import defineToStringTag from'../jsutils/defineToStringTag';import{Kind}from'../language/kinds';import{valueFromASTUntyped}from'../utilities/valueFromASTUntyped';export function isType(type){return isScalarType(type)||isObjectType(type)||isInterfaceType(type)||isUnionType(type)||isEnumType(type)||isInputObjectType(type)||isListType(type)||isNonNullType(type);}export function assertType(type){if(!isType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL type.\"));}return type;}/**\n * There are predicates for each kind of GraphQL type.\n */ // eslint-disable-next-line no-redeclare\nexport function isScalarType(type){return instanceOf(type,GraphQLScalarType);}export function assertScalarType(type){if(!isScalarType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL Scalar type.\"));}return type;}// eslint-disable-next-line no-redeclare\nexport function isObjectType(type){return instanceOf(type,GraphQLObjectType);}export function assertObjectType(type){if(!isObjectType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL Object type.\"));}return type;}// eslint-disable-next-line no-redeclare\nexport function isInterfaceType(type){return instanceOf(type,GraphQLInterfaceType);}export function assertInterfaceType(type){if(!isInterfaceType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL Interface type.\"));}return type;}// eslint-disable-next-line no-redeclare\nexport function isUnionType(type){return instanceOf(type,GraphQLUnionType);}export function assertUnionType(type){if(!isUnionType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL Union type.\"));}return type;}// eslint-disable-next-line no-redeclare\nexport function isEnumType(type){return instanceOf(type,GraphQLEnumType);}export function assertEnumType(type){if(!isEnumType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL Enum type.\"));}return type;}// eslint-disable-next-line no-redeclare\nexport function isInputObjectType(type){return instanceOf(type,GraphQLInputObjectType);}export function assertInputObjectType(type){if(!isInputObjectType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL Input Object type.\"));}return type;}// eslint-disable-next-line no-redeclare\nexport function isListType(type){return instanceOf(type,GraphQLList);}export function assertListType(type){if(!isListType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL List type.\"));}return type;}// eslint-disable-next-line no-redeclare\nexport function isNonNullType(type){return instanceOf(type,GraphQLNonNull);}export function assertNonNullType(type){if(!isNonNullType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL Non-Null type.\"));}return type;}/**\n * These types may be used as input types for arguments and directives.\n */export function isInputType(type){return isScalarType(type)||isEnumType(type)||isInputObjectType(type)||isWrappingType(type)&&isInputType(type.ofType);}export function assertInputType(type){if(!isInputType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL input type.\"));}return type;}/**\n * These types may be used as output types as the result of fields.\n */export function isOutputType(type){return isScalarType(type)||isObjectType(type)||isInterfaceType(type)||isUnionType(type)||isEnumType(type)||isWrappingType(type)&&isOutputType(type.ofType);}export function assertOutputType(type){if(!isOutputType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL output type.\"));}return type;}/**\n * These types may describe types which may be leaf values.\n */export function isLeafType(type){return isScalarType(type)||isEnumType(type);}export function assertLeafType(type){if(!isLeafType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL leaf type.\"));}return type;}/**\n * These types may describe the parent context of a selection set.\n */export function isCompositeType(type){return isObjectType(type)||isInterfaceType(type)||isUnionType(type);}export function assertCompositeType(type){if(!isCompositeType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL composite type.\"));}return type;}/**\n * These types may describe the parent context of a selection set.\n */export function isAbstractType(type){return isInterfaceType(type)||isUnionType(type);}export function assertAbstractType(type){if(!isAbstractType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL abstract type.\"));}return type;}/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         parents: { type: GraphQLList(PersonType) },\n *         children: { type: GraphQLList(PersonType) },\n *       })\n *     })\n *\n */ // eslint-disable-next-line no-redeclare\nexport function GraphQLList(ofType){if(this instanceof GraphQLList){this.ofType=assertType(ofType);}else{return new GraphQLList(ofType);}}// Need to cast through any to alter the prototype.\nGraphQLList.prototype.toString=function toString(){return'['+String(this.ofType)+']';};// Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\ndefineToStringTag(GraphQLList);defineToJSON(GraphQLList);/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n *     const RowType = new GraphQLObjectType({\n *       name: 'Row',\n *       fields: () => ({\n *         id: { type: GraphQLNonNull(GraphQLString) },\n *       })\n *     })\n *\n * Note: the enforcement of non-nullability occurs within the executor.\n */ // eslint-disable-next-line no-redeclare\nexport function GraphQLNonNull(ofType){if(this instanceof GraphQLNonNull){this.ofType=assertNullableType(ofType);}else{return new GraphQLNonNull(ofType);}}// Need to cast through any to alter the prototype.\nGraphQLNonNull.prototype.toString=function toString(){return String(this.ofType)+'!';};// Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\ndefineToStringTag(GraphQLNonNull);defineToJSON(GraphQLNonNull);/**\n * These types wrap and modify other types\n */export function isWrappingType(type){return isListType(type)||isNonNullType(type);}export function assertWrappingType(type){if(!isWrappingType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL wrapping type.\"));}return type;}/**\n * These types can all accept null as a value.\n */export function isNullableType(type){return isType(type)&&!isNonNullType(type);}export function assertNullableType(type){if(!isNullableType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL nullable type.\"));}return type;}/* eslint-disable no-redeclare */export function getNullableType(type){/* eslint-enable no-redeclare */if(type){return isNonNullType(type)?type.ofType:type;}}/**\n * These named types do not include modifiers like List or NonNull.\n */export function isNamedType(type){return isScalarType(type)||isObjectType(type)||isInterfaceType(type)||isUnionType(type)||isEnumType(type)||isInputObjectType(type);}export function assertNamedType(type){if(!isNamedType(type)){throw new Error(\"Expected \".concat(inspect(type),\" to be a GraphQL named type.\"));}return type;}/* eslint-disable no-redeclare */export function getNamedType(type){/* eslint-enable no-redeclare */if(type){var unwrappedType=type;while(isWrappingType(unwrappedType)){unwrappedType=unwrappedType.ofType;}return unwrappedType;}}/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */function resolveThunk(thunk){// $FlowFixMe(>=0.90.0)\nreturn typeof thunk==='function'?thunk():thunk;}function undefineIfEmpty(arr){return arr&&arr.length>0?arr:undefined;}/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's serialize function does not return a value (i.e. it returns\n * `undefined`) then an error will be raised and a `null` value will be returned\n * in the response. If the serialize function returns `null`, then no error will\n * be included in the response.\n *\n * Example:\n *\n *     const OddType = new GraphQLScalarType({\n *       name: 'Odd',\n *       serialize(value) {\n *         if (value % 2 === 1) {\n *           return value;\n *         }\n *       }\n *     });\n *\n */export var GraphQLScalarType=/*#__PURE__*/function(){function GraphQLScalarType(config){var parseValue=config.parseValue||identityFunc;this.name=config.name;this.description=config.description;this.serialize=config.serialize||identityFunc;this.parseValue=parseValue;this.parseLiteral=config.parseLiteral||function(node){return parseValue(valueFromASTUntyped(node));};this.extensions=config.extensions&&toObjMap(config.extensions);this.astNode=config.astNode;this.extensionASTNodes=undefineIfEmpty(config.extensionASTNodes);typeof config.name==='string'||devAssert(0,'Must provide name.');config.serialize==null||typeof config.serialize==='function'||devAssert(0,\"\".concat(this.name,\" must provide \\\"serialize\\\" function. If this custom Scalar is also used as an input type, ensure \\\"parseValue\\\" and \\\"parseLiteral\\\" functions are also provided.\"));if(config.parseLiteral){typeof config.parseValue==='function'&&typeof config.parseLiteral==='function'||devAssert(0,\"\".concat(this.name,\" must provide both \\\"parseValue\\\" and \\\"parseLiteral\\\" functions.\"));}}var _proto=GraphQLScalarType.prototype;_proto.toConfig=function toConfig(){return{name:this.name,description:this.description,serialize:this.serialize,parseValue:this.parseValue,parseLiteral:this.parseLiteral,extensions:this.extensions,astNode:this.astNode,extensionASTNodes:this.extensionASTNodes||[]};};_proto.toString=function toString(){return this.name;};return GraphQLScalarType;}();// Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\ndefineToStringTag(GraphQLScalarType);defineToJSON(GraphQLScalarType);/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n *     const AddressType = new GraphQLObjectType({\n *       name: 'Address',\n *       fields: {\n *         street: { type: GraphQLString },\n *         number: { type: GraphQLInt },\n *         formatted: {\n *           type: GraphQLString,\n *           resolve(obj) {\n *             return obj.number + ' ' + obj.street\n *           }\n *         }\n *       }\n *     });\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         name: { type: GraphQLString },\n *         bestFriend: { type: PersonType },\n *       })\n *     });\n *\n */export var GraphQLObjectType=/*#__PURE__*/function(){function GraphQLObjectType(config){this.name=config.name;this.description=config.description;this.isTypeOf=config.isTypeOf;this.extensions=config.extensions&&toObjMap(config.extensions);this.astNode=config.astNode;this.extensionASTNodes=undefineIfEmpty(config.extensionASTNodes);this._fields=defineFieldMap.bind(undefined,config);this._interfaces=defineInterfaces.bind(undefined,config);typeof config.name==='string'||devAssert(0,'Must provide name.');config.isTypeOf==null||typeof config.isTypeOf==='function'||devAssert(0,\"\".concat(this.name,\" must provide \\\"isTypeOf\\\" as a function, \")+\"but got: \".concat(inspect(config.isTypeOf),\".\"));}var _proto2=GraphQLObjectType.prototype;_proto2.getFields=function getFields(){if(typeof this._fields==='function'){this._fields=this._fields();}return this._fields;};_proto2.getInterfaces=function getInterfaces(){if(typeof this._interfaces==='function'){this._interfaces=this._interfaces();}return this._interfaces;};_proto2.toConfig=function toConfig(){return{name:this.name,description:this.description,interfaces:this.getInterfaces(),fields:fieldsToFieldsConfig(this.getFields()),isTypeOf:this.isTypeOf,extensions:this.extensions,astNode:this.astNode,extensionASTNodes:this.extensionASTNodes||[]};};_proto2.toString=function toString(){return this.name;};return GraphQLObjectType;}();// Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\ndefineToStringTag(GraphQLObjectType);defineToJSON(GraphQLObjectType);function defineInterfaces(config){var interfaces=resolveThunk(config.interfaces)||[];Array.isArray(interfaces)||devAssert(0,\"\".concat(config.name,\" interfaces must be an Array or a function which returns an Array.\"));return interfaces;}function defineFieldMap(config){var fieldMap=resolveThunk(config.fields)||{};isPlainObj(fieldMap)||devAssert(0,\"\".concat(config.name,\" fields must be an object with field names as keys or a function which returns such an object.\"));return mapValue(fieldMap,function(fieldConfig,fieldName){isPlainObj(fieldConfig)||devAssert(0,\"\".concat(config.name,\".\").concat(fieldName,\" field config must be an object\"));!('isDeprecated'in fieldConfig)||devAssert(0,\"\".concat(config.name,\".\").concat(fieldName,\" should provide \\\"deprecationReason\\\" instead of \\\"isDeprecated\\\".\"));fieldConfig.resolve==null||typeof fieldConfig.resolve==='function'||devAssert(0,\"\".concat(config.name,\".\").concat(fieldName,\" field resolver must be a function if \")+\"provided, but got: \".concat(inspect(fieldConfig.resolve),\".\"));var argsConfig=fieldConfig.args||{};isPlainObj(argsConfig)||devAssert(0,\"\".concat(config.name,\".\").concat(fieldName,\" args must be an object with argument names as keys.\"));var args=objectEntries(argsConfig).map(function(_ref){var argName=_ref[0],arg=_ref[1];return{name:argName,description:arg.description===undefined?null:arg.description,type:arg.type,defaultValue:arg.defaultValue,extensions:arg.extensions&&toObjMap(arg.extensions),astNode:arg.astNode};});return _objectSpread({},fieldConfig,{name:fieldName,description:fieldConfig.description,type:fieldConfig.type,args:args,resolve:fieldConfig.resolve,subscribe:fieldConfig.subscribe,isDeprecated:Boolean(fieldConfig.deprecationReason),deprecationReason:fieldConfig.deprecationReason,extensions:fieldConfig.extensions&&toObjMap(fieldConfig.extensions),astNode:fieldConfig.astNode});});}function isPlainObj(obj){return isObjectLike(obj)&&!Array.isArray(obj);}function fieldsToFieldsConfig(fields){return mapValue(fields,function(field){return{description:field.description,type:field.type,args:argsToArgsConfig(field.args),resolve:field.resolve,subscribe:field.subscribe,deprecationReason:field.deprecationReason,extensions:field.extensions,astNode:field.astNode};});}export function argsToArgsConfig(args){return keyValMap(args,function(arg){return arg.name;},function(arg){return{description:arg.description,type:arg.type,defaultValue:arg.defaultValue,extensions:arg.extensions,astNode:arg.astNode};});}export function isRequiredArgument(arg){return isNonNullType(arg.type)&&arg.defaultValue===undefined;}/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n *     const EntityType = new GraphQLInterfaceType({\n *       name: 'Entity',\n *       fields: {\n *         name: { type: GraphQLString }\n *       }\n *     });\n *\n */export var GraphQLInterfaceType=/*#__PURE__*/function(){function GraphQLInterfaceType(config){this.name=config.name;this.description=config.description;this.resolveType=config.resolveType;this.extensions=config.extensions&&toObjMap(config.extensions);this.astNode=config.astNode;this.extensionASTNodes=undefineIfEmpty(config.extensionASTNodes);this._fields=defineFieldMap.bind(undefined,config);typeof config.name==='string'||devAssert(0,'Must provide name.');config.resolveType==null||typeof config.resolveType==='function'||devAssert(0,\"\".concat(this.name,\" must provide \\\"resolveType\\\" as a function, \")+\"but got: \".concat(inspect(config.resolveType),\".\"));}var _proto3=GraphQLInterfaceType.prototype;_proto3.getFields=function getFields(){if(typeof this._fields==='function'){this._fields=this._fields();}return this._fields;};_proto3.toConfig=function toConfig(){return{name:this.name,description:this.description,fields:fieldsToFieldsConfig(this.getFields()),resolveType:this.resolveType,extensions:this.extensions,astNode:this.astNode,extensionASTNodes:this.extensionASTNodes||[]};};_proto3.toString=function toString(){return this.name;};return GraphQLInterfaceType;}();// Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\ndefineToStringTag(GraphQLInterfaceType);defineToJSON(GraphQLInterfaceType);/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n *     const PetType = new GraphQLUnionType({\n *       name: 'Pet',\n *       types: [ DogType, CatType ],\n *       resolveType(value) {\n *         if (value instanceof Dog) {\n *           return DogType;\n *         }\n *         if (value instanceof Cat) {\n *           return CatType;\n *         }\n *       }\n *     });\n *\n */export var GraphQLUnionType=/*#__PURE__*/function(){function GraphQLUnionType(config){this.name=config.name;this.description=config.description;this.resolveType=config.resolveType;this.extensions=config.extensions&&toObjMap(config.extensions);this.astNode=config.astNode;this.extensionASTNodes=undefineIfEmpty(config.extensionASTNodes);this._types=defineTypes.bind(undefined,config);typeof config.name==='string'||devAssert(0,'Must provide name.');config.resolveType==null||typeof config.resolveType==='function'||devAssert(0,\"\".concat(this.name,\" must provide \\\"resolveType\\\" as a function, \")+\"but got: \".concat(inspect(config.resolveType),\".\"));}var _proto4=GraphQLUnionType.prototype;_proto4.getTypes=function getTypes(){if(typeof this._types==='function'){this._types=this._types();}return this._types;};_proto4.toConfig=function toConfig(){return{name:this.name,description:this.description,types:this.getTypes(),resolveType:this.resolveType,extensions:this.extensions,astNode:this.astNode,extensionASTNodes:this.extensionASTNodes||[]};};_proto4.toString=function toString(){return this.name;};return GraphQLUnionType;}();// Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\ndefineToStringTag(GraphQLUnionType);defineToJSON(GraphQLUnionType);function defineTypes(config){var types=resolveThunk(config.types)||[];Array.isArray(types)||devAssert(0,\"Must provide Array of types or a function which returns such an array for Union \".concat(config.name,\".\"));return types;}/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n *     const RGBType = new GraphQLEnumType({\n *       name: 'RGB',\n *       values: {\n *         RED: { value: 0 },\n *         GREEN: { value: 1 },\n *         BLUE: { value: 2 }\n *       }\n *     });\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */export var GraphQLEnumType/* <T> */=/*#__PURE__*/function(){function GraphQLEnumType(config){this.name=config.name;this.description=config.description;this.extensions=config.extensions&&toObjMap(config.extensions);this.astNode=config.astNode;this.extensionASTNodes=undefineIfEmpty(config.extensionASTNodes);this._values=defineEnumValues(this.name,config.values);this._valueLookup=new Map(this._values.map(function(enumValue){return[enumValue.value,enumValue];}));this._nameLookup=keyMap(this._values,function(value){return value.name;});typeof config.name==='string'||devAssert(0,'Must provide name.');}var _proto5=GraphQLEnumType.prototype;_proto5.getValues=function getValues(){return this._values;};_proto5.getValue=function getValue(name){return this._nameLookup[name];};_proto5.serialize=function serialize(value){var enumValue=this._valueLookup.get(value);if(enumValue){return enumValue.name;}};_proto5.parseValue=function parseValue(value)/* T */{if(typeof value==='string'){var enumValue=this.getValue(value);if(enumValue){return enumValue.value;}}};_proto5.parseLiteral=function parseLiteral(valueNode,_variables)/* T */{// Note: variables will be resolved to a value before calling this function.\nif(valueNode.kind===Kind.ENUM){var enumValue=this.getValue(valueNode.value);if(enumValue){return enumValue.value;}}};_proto5.toConfig=function toConfig(){var values=keyValMap(this.getValues(),function(value){return value.name;},function(value){return{description:value.description,value:value.value,deprecationReason:value.deprecationReason,extensions:value.extensions,astNode:value.astNode};});return{name:this.name,description:this.description,values:values,extensions:this.extensions,astNode:this.astNode,extensionASTNodes:this.extensionASTNodes||[]};};_proto5.toString=function toString(){return this.name;};return GraphQLEnumType;}();// Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\ndefineToStringTag(GraphQLEnumType);defineToJSON(GraphQLEnumType);function defineEnumValues(typeName,valueMap){isPlainObj(valueMap)||devAssert(0,\"\".concat(typeName,\" values must be an object with value names as keys.\"));return objectEntries(valueMap).map(function(_ref2){var valueName=_ref2[0],value=_ref2[1];isPlainObj(value)||devAssert(0,\"\".concat(typeName,\".\").concat(valueName,\" must refer to an object with a \\\"value\\\" key \")+\"representing an internal value but got: \".concat(inspect(value),\".\"));!('isDeprecated'in value)||devAssert(0,\"\".concat(typeName,\".\").concat(valueName,\" should provide \\\"deprecationReason\\\" instead of \\\"isDeprecated\\\".\"));return{name:valueName,description:value.description,value:'value'in value?value.value:valueName,isDeprecated:Boolean(value.deprecationReason),deprecationReason:value.deprecationReason,extensions:value.extensions&&toObjMap(value.extensions),astNode:value.astNode};});}/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n *     const GeoPoint = new GraphQLInputObjectType({\n *       name: 'GeoPoint',\n *       fields: {\n *         lat: { type: GraphQLNonNull(GraphQLFloat) },\n *         lon: { type: GraphQLNonNull(GraphQLFloat) },\n *         alt: { type: GraphQLFloat, defaultValue: 0 },\n *       }\n *     });\n *\n */export var GraphQLInputObjectType=/*#__PURE__*/function(){function GraphQLInputObjectType(config){this.name=config.name;this.description=config.description;this.extensions=config.extensions&&toObjMap(config.extensions);this.astNode=config.astNode;this.extensionASTNodes=undefineIfEmpty(config.extensionASTNodes);this._fields=defineInputFieldMap.bind(undefined,config);typeof config.name==='string'||devAssert(0,'Must provide name.');}var _proto6=GraphQLInputObjectType.prototype;_proto6.getFields=function getFields(){if(typeof this._fields==='function'){this._fields=this._fields();}return this._fields;};_proto6.toConfig=function toConfig(){var fields=mapValue(this.getFields(),function(field){return{description:field.description,type:field.type,defaultValue:field.defaultValue,extensions:field.extensions,astNode:field.astNode};});return{name:this.name,description:this.description,fields:fields,extensions:this.extensions,astNode:this.astNode,extensionASTNodes:this.extensionASTNodes||[]};};_proto6.toString=function toString(){return this.name;};return GraphQLInputObjectType;}();// Conditionally apply `[Symbol.toStringTag]` if `Symbol`s are supported\ndefineToStringTag(GraphQLInputObjectType);defineToJSON(GraphQLInputObjectType);function defineInputFieldMap(config){var fieldMap=resolveThunk(config.fields)||{};isPlainObj(fieldMap)||devAssert(0,\"\".concat(config.name,\" fields must be an object with field names as keys or a function which returns such an object.\"));return mapValue(fieldMap,function(fieldConfig,fieldName){!('resolve'in fieldConfig)||devAssert(0,\"\".concat(config.name,\".\").concat(fieldName,\" field has a resolve property, but Input Types cannot define resolvers.\"));return _objectSpread({},fieldConfig,{name:fieldName,description:fieldConfig.description,type:fieldConfig.type,defaultValue:fieldConfig.defaultValue,extensions:fieldConfig.extensions&&toObjMap(fieldConfig.extensions),astNode:fieldConfig.astNode});});}export function isRequiredInputField(field){return isNonNullType(field.type)&&field.defaultValue===undefined;}","map":null,"metadata":{},"sourceType":"module"}