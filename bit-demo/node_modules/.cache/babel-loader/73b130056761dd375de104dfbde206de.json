{"ast":null,"code":"import defineToJSON from'../jsutils/defineToJSON';import{syntaxError}from'../error/syntaxError';import{dedentBlockStringValue}from'./blockString';import{TokenKind}from'./tokenKind';/**\n * Given a Source object, this returns a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */export function createLexer(source,options){var startOfFileToken=new Tok(TokenKind.SOF,0,0,0,0,null);var lexer={source:source,options:options,lastToken:startOfFileToken,token:startOfFileToken,line:1,lineStart:0,advance:advanceLexer,lookahead:lookahead};return lexer;}function advanceLexer(){this.lastToken=this.token;var token=this.token=this.lookahead();return token;}function lookahead(){var token=this.token;if(token.kind!==TokenKind.EOF){do{// Note: next is only mutable during parsing, so we cast to allow this.\ntoken=token.next||(token.next=readToken(this,token));}while(token.kind===TokenKind.COMMENT);}return token;}/**\n * The return type of createLexer.\n */ // @internal\nexport function isPunctuatorToken(token){var kind=token.kind;return kind===TokenKind.BANG||kind===TokenKind.DOLLAR||kind===TokenKind.AMP||kind===TokenKind.PAREN_L||kind===TokenKind.PAREN_R||kind===TokenKind.SPREAD||kind===TokenKind.COLON||kind===TokenKind.EQUALS||kind===TokenKind.AT||kind===TokenKind.BRACKET_L||kind===TokenKind.BRACKET_R||kind===TokenKind.BRACE_L||kind===TokenKind.PIPE||kind===TokenKind.BRACE_R;}/**\n * Helper function for constructing the Token object.\n */function Tok(kind,start,end,line,column,prev,value){this.kind=kind;this.start=start;this.end=end;this.line=line;this.column=column;this.value=value;this.prev=prev;this.next=null;}// Print a simplified form when appearing in JSON/util.inspect.\ndefineToJSON(Tok,function(){return{kind:this.kind,value:this.value,line:this.line,column:this.column};});function printCharCode(code){return(// NaN/undefined represents access beyond the end of the file.\nisNaN(code)?TokenKind.EOF:// Trust JSON for ASCII.\ncode<0x007f?JSON.stringify(String.fromCharCode(code)):// Otherwise print the escaped form.\n\"\\\"\\\\u\".concat(('00'+code.toString(16).toUpperCase()).slice(-4),\"\\\"\"));}/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */function readToken(lexer,prev){var source=lexer.source;var body=source.body;var bodyLength=body.length;var pos=positionAfterWhitespace(body,prev.end,lexer);var line=lexer.line;var col=1+pos-lexer.lineStart;if(pos>=bodyLength){return new Tok(TokenKind.EOF,bodyLength,bodyLength,line,col,prev);}var code=body.charCodeAt(pos);// SourceCharacter\nswitch(code){// !\ncase 33:return new Tok(TokenKind.BANG,pos,pos+1,line,col,prev);// #\ncase 35:return readComment(source,pos,line,col,prev);// $\ncase 36:return new Tok(TokenKind.DOLLAR,pos,pos+1,line,col,prev);// &\ncase 38:return new Tok(TokenKind.AMP,pos,pos+1,line,col,prev);// (\ncase 40:return new Tok(TokenKind.PAREN_L,pos,pos+1,line,col,prev);// )\ncase 41:return new Tok(TokenKind.PAREN_R,pos,pos+1,line,col,prev);// .\ncase 46:if(body.charCodeAt(pos+1)===46&&body.charCodeAt(pos+2)===46){return new Tok(TokenKind.SPREAD,pos,pos+3,line,col,prev);}break;// :\ncase 58:return new Tok(TokenKind.COLON,pos,pos+1,line,col,prev);// =\ncase 61:return new Tok(TokenKind.EQUALS,pos,pos+1,line,col,prev);// @\ncase 64:return new Tok(TokenKind.AT,pos,pos+1,line,col,prev);// [\ncase 91:return new Tok(TokenKind.BRACKET_L,pos,pos+1,line,col,prev);// ]\ncase 93:return new Tok(TokenKind.BRACKET_R,pos,pos+1,line,col,prev);// {\ncase 123:return new Tok(TokenKind.BRACE_L,pos,pos+1,line,col,prev);// |\ncase 124:return new Tok(TokenKind.PIPE,pos,pos+1,line,col,prev);// }\ncase 125:return new Tok(TokenKind.BRACE_R,pos,pos+1,line,col,prev);// A-Z _ a-z\ncase 65:case 66:case 67:case 68:case 69:case 70:case 71:case 72:case 73:case 74:case 75:case 76:case 77:case 78:case 79:case 80:case 81:case 82:case 83:case 84:case 85:case 86:case 87:case 88:case 89:case 90:case 95:case 97:case 98:case 99:case 100:case 101:case 102:case 103:case 104:case 105:case 106:case 107:case 108:case 109:case 110:case 111:case 112:case 113:case 114:case 115:case 116:case 117:case 118:case 119:case 120:case 121:case 122:return readName(source,pos,line,col,prev);// - 0-9\ncase 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return readNumber(source,pos,code,line,col,prev);// \"\ncase 34:if(body.charCodeAt(pos+1)===34&&body.charCodeAt(pos+2)===34){return readBlockString(source,pos,line,col,prev,lexer);}return readString(source,pos,line,col,prev);}throw syntaxError(source,pos,unexpectedCharacterMessage(code));}/**\n * Report a message that an unexpected character was encountered.\n */function unexpectedCharacterMessage(code){if(code<0x0020&&code!==0x0009&&code!==0x000a&&code!==0x000d){return\"Cannot contain the invalid character \".concat(printCharCode(code),\".\");}if(code===39){// '\nreturn'Unexpected single quote character (\\'), did you mean to use a double quote (\")?';}return\"Cannot parse the unexpected character \".concat(printCharCode(code),\".\");}/**\n * Reads from body starting at startPosition until it finds a non-whitespace\n * character, then returns the position of that character for lexing.\n */function positionAfterWhitespace(body,startPosition,lexer){var bodyLength=body.length;var position=startPosition;while(position<bodyLength){var code=body.charCodeAt(position);// tab | space | comma | BOM\nif(code===9||code===32||code===44||code===0xfeff){++position;}else if(code===10){// new line\n++position;++lexer.line;lexer.lineStart=position;}else if(code===13){// carriage return\nif(body.charCodeAt(position+1)===10){position+=2;}else{++position;}++lexer.line;lexer.lineStart=position;}else{break;}}return position;}/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */function readComment(source,start,line,col,prev){var body=source.body;var code;var position=start;do{code=body.charCodeAt(++position);}while(!isNaN(code)&&(// SourceCharacter but not LineTerminator\ncode>0x001f||code===0x0009));return new Tok(TokenKind.COMMENT,start,position,line,col,prev,body.slice(start+1,position));}/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */function readNumber(source,start,firstCode,line,col,prev){var body=source.body;var code=firstCode;var position=start;var isFloat=false;if(code===45){// -\ncode=body.charCodeAt(++position);}if(code===48){// 0\ncode=body.charCodeAt(++position);if(code>=48&&code<=57){throw syntaxError(source,position,\"Invalid number, unexpected digit after 0: \".concat(printCharCode(code),\".\"));}}else{position=readDigits(source,position,code);code=body.charCodeAt(position);}if(code===46){// .\nisFloat=true;code=body.charCodeAt(++position);position=readDigits(source,position,code);code=body.charCodeAt(position);}if(code===69||code===101){// E e\nisFloat=true;code=body.charCodeAt(++position);if(code===43||code===45){// + -\ncode=body.charCodeAt(++position);}position=readDigits(source,position,code);code=body.charCodeAt(position);}// Numbers cannot be followed by . or e\nif(code===46||code===69||code===101){throw syntaxError(source,position,\"Invalid number, expected digit but got: \".concat(printCharCode(code),\".\"));}return new Tok(isFloat?TokenKind.FLOAT:TokenKind.INT,start,position,line,col,prev,body.slice(start,position));}/**\n * Returns the new position in the source after reading digits.\n */function readDigits(source,start,firstCode){var body=source.body;var position=start;var code=firstCode;if(code>=48&&code<=57){// 0 - 9\ndo{code=body.charCodeAt(++position);}while(code>=48&&code<=57);// 0 - 9\nreturn position;}throw syntaxError(source,position,\"Invalid number, expected digit but got: \".concat(printCharCode(code),\".\"));}/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */function readString(source,start,line,col,prev){var body=source.body;var position=start+1;var chunkStart=position;var code=0;var value='';while(position<body.length&&!isNaN(code=body.charCodeAt(position))&&// not LineTerminator\ncode!==0x000a&&code!==0x000d){// Closing Quote (\")\nif(code===34){value+=body.slice(chunkStart,position);return new Tok(TokenKind.STRING,start,position+1,line,col,prev,value);}// SourceCharacter\nif(code<0x0020&&code!==0x0009){throw syntaxError(source,position,\"Invalid character within String: \".concat(printCharCode(code),\".\"));}++position;if(code===92){// \\\nvalue+=body.slice(chunkStart,position-1);code=body.charCodeAt(position);switch(code){case 34:value+='\"';break;case 47:value+='/';break;case 92:value+='\\\\';break;case 98:value+='\\b';break;case 102:value+='\\f';break;case 110:value+='\\n';break;case 114:value+='\\r';break;case 116:value+='\\t';break;case 117:{// uXXXX\nvar charCode=uniCharCode(body.charCodeAt(position+1),body.charCodeAt(position+2),body.charCodeAt(position+3),body.charCodeAt(position+4));if(charCode<0){var invalidSequence=body.slice(position+1,position+5);throw syntaxError(source,position,\"Invalid character escape sequence: \\\\u\".concat(invalidSequence,\".\"));}value+=String.fromCharCode(charCode);position+=4;break;}default:throw syntaxError(source,position,\"Invalid character escape sequence: \\\\\".concat(String.fromCharCode(code),\".\"));}++position;chunkStart=position;}}throw syntaxError(source,position,'Unterminated string.');}/**\n * Reads a block string token from the source file.\n *\n * \"\"\"(\"?\"?(\\\\\"\"\"|\\\\(?!=\"\"\")|[^\"\\\\]))*\"\"\"\n */function readBlockString(source,start,line,col,prev,lexer){var body=source.body;var position=start+3;var chunkStart=position;var code=0;var rawValue='';while(position<body.length&&!isNaN(code=body.charCodeAt(position))){// Closing Triple-Quote (\"\"\")\nif(code===34&&body.charCodeAt(position+1)===34&&body.charCodeAt(position+2)===34){rawValue+=body.slice(chunkStart,position);return new Tok(TokenKind.BLOCK_STRING,start,position+3,line,col,prev,dedentBlockStringValue(rawValue));}// SourceCharacter\nif(code<0x0020&&code!==0x0009&&code!==0x000a&&code!==0x000d){throw syntaxError(source,position,\"Invalid character within String: \".concat(printCharCode(code),\".\"));}if(code===10){// new line\n++position;++lexer.line;lexer.lineStart=position;}else if(code===13){// carriage return\nif(body.charCodeAt(position+1)===10){position+=2;}else{++position;}++lexer.line;lexer.lineStart=position;}else if(// Escape Triple-Quote (\\\"\"\")\ncode===92&&body.charCodeAt(position+1)===34&&body.charCodeAt(position+2)===34&&body.charCodeAt(position+3)===34){rawValue+=body.slice(chunkStart,position)+'\"\"\"';position+=4;chunkStart=position;}else{++position;}}throw syntaxError(source,position,'Unterminated string.');}/**\n * Converts four hexadecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */function uniCharCode(a,b,c,d){return char2hex(a)<<12|char2hex(b)<<8|char2hex(c)<<4|char2hex(d);}/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */function char2hex(a){return a>=48&&a<=57?a-48// 0-9\n:a>=65&&a<=70?a-55// A-F\n:a>=97&&a<=102?a-87// a-f\n:-1;}/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */function readName(source,start,line,col,prev){var body=source.body;var bodyLength=body.length;var position=start+1;var code=0;while(position!==bodyLength&&!isNaN(code=body.charCodeAt(position))&&(code===95||// _\ncode>=48&&code<=57||// 0-9\ncode>=65&&code<=90||// A-Z\ncode>=97&&code<=122)// a-z\n){++position;}return new Tok(TokenKind.NAME,start,position,line,col,prev,body.slice(start,position));}","map":null,"metadata":{},"sourceType":"module"}