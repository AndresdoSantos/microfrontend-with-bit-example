{"ast":null,"code":"import inspect from'../jsutils/inspect';import devAssert from'../jsutils/devAssert';import defineToJSON from'../jsutils/defineToJSON';import{syntaxError}from'../error/syntaxError';import{Kind}from'./kinds';import{Source}from'./source';import{createLexer}from'./lexer';import{DirectiveLocation}from'./directiveLocation';import{TokenKind}from'./tokenKind';/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */export function parse(source,options){var parser=new Parser(source,options);return parser.parseDocument();}/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */export function parseValue(source,options){var parser=new Parser(source,options);parser.expectToken(TokenKind.SOF);var value=parser.parseValueLiteral(false);parser.expectToken(TokenKind.EOF);return value;}/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */export function parseType(source,options){var parser=new Parser(source,options);parser.expectToken(TokenKind.SOF);var type=parser.parseTypeReference();parser.expectToken(TokenKind.EOF);return type;}var Parser=/*#__PURE__*/function(){function Parser(source,options){var sourceObj=typeof source==='string'?new Source(source):source;sourceObj instanceof Source||devAssert(0,\"Must provide Source. Received: \".concat(inspect(sourceObj)));this._lexer=createLexer(sourceObj);this._options=options||{};}/**\n   * Converts a name lex token into a name parse node.\n   */var _proto=Parser.prototype;_proto.parseName=function parseName(){var token=this.expectToken(TokenKind.NAME);return{kind:Kind.NAME,value:token.value,loc:this.loc(token)};}// Implements the parsing rules in the Document section.\n/**\n   * Document : Definition+\n   */;_proto.parseDocument=function parseDocument(){var start=this._lexer.token;return{kind:Kind.DOCUMENT,definitions:this.many(TokenKind.SOF,this.parseDefinition,TokenKind.EOF),loc:this.loc(start)};}/**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */;_proto.parseDefinition=function parseDefinition(){if(this.peek(TokenKind.NAME)){switch(this._lexer.token.value){case'query':case'mutation':case'subscription':return this.parseOperationDefinition();case'fragment':return this.parseFragmentDefinition();case'schema':case'scalar':case'type':case'interface':case'union':case'enum':case'input':case'directive':return this.parseTypeSystemDefinition();case'extend':return this.parseTypeSystemExtension();}}else if(this.peek(TokenKind.BRACE_L)){return this.parseOperationDefinition();}else if(this.peekDescription()){return this.parseTypeSystemDefinition();}throw this.unexpected();}// Implements the parsing rules in the Operations section.\n/**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */;_proto.parseOperationDefinition=function parseOperationDefinition(){var start=this._lexer.token;if(this.peek(TokenKind.BRACE_L)){return{kind:Kind.OPERATION_DEFINITION,operation:'query',name:undefined,variableDefinitions:[],directives:[],selectionSet:this.parseSelectionSet(),loc:this.loc(start)};}var operation=this.parseOperationType();var name;if(this.peek(TokenKind.NAME)){name=this.parseName();}return{kind:Kind.OPERATION_DEFINITION,operation:operation,name:name,variableDefinitions:this.parseVariableDefinitions(),directives:this.parseDirectives(false),selectionSet:this.parseSelectionSet(),loc:this.loc(start)};}/**\n   * OperationType : one of query mutation subscription\n   */;_proto.parseOperationType=function parseOperationType(){var operationToken=this.expectToken(TokenKind.NAME);switch(operationToken.value){case'query':return'query';case'mutation':return'mutation';case'subscription':return'subscription';}throw this.unexpected(operationToken);}/**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */;_proto.parseVariableDefinitions=function parseVariableDefinitions(){return this.optionalMany(TokenKind.PAREN_L,this.parseVariableDefinition,TokenKind.PAREN_R);}/**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */;_proto.parseVariableDefinition=function parseVariableDefinition(){var start=this._lexer.token;return{kind:Kind.VARIABLE_DEFINITION,variable:this.parseVariable(),type:(this.expectToken(TokenKind.COLON),this.parseTypeReference()),defaultValue:this.expectOptionalToken(TokenKind.EQUALS)?this.parseValueLiteral(true):undefined,directives:this.parseDirectives(true),loc:this.loc(start)};}/**\n   * Variable : $ Name\n   */;_proto.parseVariable=function parseVariable(){var start=this._lexer.token;this.expectToken(TokenKind.DOLLAR);return{kind:Kind.VARIABLE,name:this.parseName(),loc:this.loc(start)};}/**\n   * SelectionSet : { Selection+ }\n   */;_proto.parseSelectionSet=function parseSelectionSet(){var start=this._lexer.token;return{kind:Kind.SELECTION_SET,selections:this.many(TokenKind.BRACE_L,this.parseSelection,TokenKind.BRACE_R),loc:this.loc(start)};}/**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */;_proto.parseSelection=function parseSelection(){return this.peek(TokenKind.SPREAD)?this.parseFragment():this.parseField();}/**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */;_proto.parseField=function parseField(){var start=this._lexer.token;var nameOrAlias=this.parseName();var alias;var name;if(this.expectOptionalToken(TokenKind.COLON)){alias=nameOrAlias;name=this.parseName();}else{name=nameOrAlias;}return{kind:Kind.FIELD,alias:alias,name:name,arguments:this.parseArguments(false),directives:this.parseDirectives(false),selectionSet:this.peek(TokenKind.BRACE_L)?this.parseSelectionSet():undefined,loc:this.loc(start)};}/**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */;_proto.parseArguments=function parseArguments(isConst){var item=isConst?this.parseConstArgument:this.parseArgument;return this.optionalMany(TokenKind.PAREN_L,item,TokenKind.PAREN_R);}/**\n   * Argument[Const] : Name : Value[?Const]\n   */;_proto.parseArgument=function parseArgument(){var start=this._lexer.token;var name=this.parseName();this.expectToken(TokenKind.COLON);return{kind:Kind.ARGUMENT,name:name,value:this.parseValueLiteral(false),loc:this.loc(start)};};_proto.parseConstArgument=function parseConstArgument(){var start=this._lexer.token;return{kind:Kind.ARGUMENT,name:this.parseName(),value:(this.expectToken(TokenKind.COLON),this.parseValueLiteral(true)),loc:this.loc(start)};}// Implements the parsing rules in the Fragments section.\n/**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */;_proto.parseFragment=function parseFragment(){var start=this._lexer.token;this.expectToken(TokenKind.SPREAD);var hasTypeCondition=this.expectOptionalKeyword('on');if(!hasTypeCondition&&this.peek(TokenKind.NAME)){return{kind:Kind.FRAGMENT_SPREAD,name:this.parseFragmentName(),directives:this.parseDirectives(false),loc:this.loc(start)};}return{kind:Kind.INLINE_FRAGMENT,typeCondition:hasTypeCondition?this.parseNamedType():undefined,directives:this.parseDirectives(false),selectionSet:this.parseSelectionSet(),loc:this.loc(start)};}/**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */;_proto.parseFragmentDefinition=function parseFragmentDefinition(){var start=this._lexer.token;this.expectKeyword('fragment');// Experimental support for defining variables within fragments changes\n// the grammar of FragmentDefinition:\n//   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\nif(this._options.experimentalFragmentVariables){return{kind:Kind.FRAGMENT_DEFINITION,name:this.parseFragmentName(),variableDefinitions:this.parseVariableDefinitions(),typeCondition:(this.expectKeyword('on'),this.parseNamedType()),directives:this.parseDirectives(false),selectionSet:this.parseSelectionSet(),loc:this.loc(start)};}return{kind:Kind.FRAGMENT_DEFINITION,name:this.parseFragmentName(),typeCondition:(this.expectKeyword('on'),this.parseNamedType()),directives:this.parseDirectives(false),selectionSet:this.parseSelectionSet(),loc:this.loc(start)};}/**\n   * FragmentName : Name but not `on`\n   */;_proto.parseFragmentName=function parseFragmentName(){if(this._lexer.token.value==='on'){throw this.unexpected();}return this.parseName();}// Implements the parsing rules in the Values section.\n/**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */;_proto.parseValueLiteral=function parseValueLiteral(isConst){var token=this._lexer.token;switch(token.kind){case TokenKind.BRACKET_L:return this.parseList(isConst);case TokenKind.BRACE_L:return this.parseObject(isConst);case TokenKind.INT:this._lexer.advance();return{kind:Kind.INT,value:token.value,loc:this.loc(token)};case TokenKind.FLOAT:this._lexer.advance();return{kind:Kind.FLOAT,value:token.value,loc:this.loc(token)};case TokenKind.STRING:case TokenKind.BLOCK_STRING:return this.parseStringLiteral();case TokenKind.NAME:if(token.value==='true'||token.value==='false'){this._lexer.advance();return{kind:Kind.BOOLEAN,value:token.value==='true',loc:this.loc(token)};}else if(token.value==='null'){this._lexer.advance();return{kind:Kind.NULL,loc:this.loc(token)};}this._lexer.advance();return{kind:Kind.ENUM,value:token.value,loc:this.loc(token)};case TokenKind.DOLLAR:if(!isConst){return this.parseVariable();}break;}throw this.unexpected();};_proto.parseStringLiteral=function parseStringLiteral(){var token=this._lexer.token;this._lexer.advance();return{kind:Kind.STRING,value:token.value,block:token.kind===TokenKind.BLOCK_STRING,loc:this.loc(token)};}/**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */;_proto.parseList=function parseList(isConst){var _this=this;var start=this._lexer.token;var item=function item(){return _this.parseValueLiteral(isConst);};return{kind:Kind.LIST,values:this.any(TokenKind.BRACKET_L,item,TokenKind.BRACKET_R),loc:this.loc(start)};}/**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */;_proto.parseObject=function parseObject(isConst){var _this2=this;var start=this._lexer.token;var item=function item(){return _this2.parseObjectField(isConst);};return{kind:Kind.OBJECT,fields:this.any(TokenKind.BRACE_L,item,TokenKind.BRACE_R),loc:this.loc(start)};}/**\n   * ObjectField[Const] : Name : Value[?Const]\n   */;_proto.parseObjectField=function parseObjectField(isConst){var start=this._lexer.token;var name=this.parseName();this.expectToken(TokenKind.COLON);return{kind:Kind.OBJECT_FIELD,name:name,value:this.parseValueLiteral(isConst),loc:this.loc(start)};}// Implements the parsing rules in the Directives section.\n/**\n   * Directives[Const] : Directive[?Const]+\n   */;_proto.parseDirectives=function parseDirectives(isConst){var directives=[];while(this.peek(TokenKind.AT)){directives.push(this.parseDirective(isConst));}return directives;}/**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */;_proto.parseDirective=function parseDirective(isConst){var start=this._lexer.token;this.expectToken(TokenKind.AT);return{kind:Kind.DIRECTIVE,name:this.parseName(),arguments:this.parseArguments(isConst),loc:this.loc(start)};}// Implements the parsing rules in the Types section.\n/**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */;_proto.parseTypeReference=function parseTypeReference(){var start=this._lexer.token;var type;if(this.expectOptionalToken(TokenKind.BRACKET_L)){type=this.parseTypeReference();this.expectToken(TokenKind.BRACKET_R);type={kind:Kind.LIST_TYPE,type:type,loc:this.loc(start)};}else{type=this.parseNamedType();}if(this.expectOptionalToken(TokenKind.BANG)){return{kind:Kind.NON_NULL_TYPE,type:type,loc:this.loc(start)};}return type;}/**\n   * NamedType : Name\n   */;_proto.parseNamedType=function parseNamedType(){var start=this._lexer.token;return{kind:Kind.NAMED_TYPE,name:this.parseName(),loc:this.loc(start)};}// Implements the parsing rules in the Type Definition section.\n/**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */;_proto.parseTypeSystemDefinition=function parseTypeSystemDefinition(){// Many definitions begin with a description and require a lookahead.\nvar keywordToken=this.peekDescription()?this._lexer.lookahead():this._lexer.token;if(keywordToken.kind===TokenKind.NAME){switch(keywordToken.value){case'schema':return this.parseSchemaDefinition();case'scalar':return this.parseScalarTypeDefinition();case'type':return this.parseObjectTypeDefinition();case'interface':return this.parseInterfaceTypeDefinition();case'union':return this.parseUnionTypeDefinition();case'enum':return this.parseEnumTypeDefinition();case'input':return this.parseInputObjectTypeDefinition();case'directive':return this.parseDirectiveDefinition();}}throw this.unexpected(keywordToken);};_proto.peekDescription=function peekDescription(){return this.peek(TokenKind.STRING)||this.peek(TokenKind.BLOCK_STRING);}/**\n   * Description : StringValue\n   */;_proto.parseDescription=function parseDescription(){if(this.peekDescription()){return this.parseStringLiteral();}}/**\n   * SchemaDefinition : schema Directives[Const]? { OperationTypeDefinition+ }\n   */;_proto.parseSchemaDefinition=function parseSchemaDefinition(){var start=this._lexer.token;this.expectKeyword('schema');var directives=this.parseDirectives(true);var operationTypes=this.many(TokenKind.BRACE_L,this.parseOperationTypeDefinition,TokenKind.BRACE_R);return{kind:Kind.SCHEMA_DEFINITION,directives:directives,operationTypes:operationTypes,loc:this.loc(start)};}/**\n   * OperationTypeDefinition : OperationType : NamedType\n   */;_proto.parseOperationTypeDefinition=function parseOperationTypeDefinition(){var start=this._lexer.token;var operation=this.parseOperationType();this.expectToken(TokenKind.COLON);var type=this.parseNamedType();return{kind:Kind.OPERATION_TYPE_DEFINITION,operation:operation,type:type,loc:this.loc(start)};}/**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */;_proto.parseScalarTypeDefinition=function parseScalarTypeDefinition(){var start=this._lexer.token;var description=this.parseDescription();this.expectKeyword('scalar');var name=this.parseName();var directives=this.parseDirectives(true);return{kind:Kind.SCALAR_TYPE_DEFINITION,description:description,name:name,directives:directives,loc:this.loc(start)};}/**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */;_proto.parseObjectTypeDefinition=function parseObjectTypeDefinition(){var start=this._lexer.token;var description=this.parseDescription();this.expectKeyword('type');var name=this.parseName();var interfaces=this.parseImplementsInterfaces();var directives=this.parseDirectives(true);var fields=this.parseFieldsDefinition();return{kind:Kind.OBJECT_TYPE_DEFINITION,description:description,name:name,interfaces:interfaces,directives:directives,fields:fields,loc:this.loc(start)};}/**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */;_proto.parseImplementsInterfaces=function parseImplementsInterfaces(){var types=[];if(this.expectOptionalKeyword('implements')){// Optional leading ampersand\nthis.expectOptionalToken(TokenKind.AMP);do{types.push(this.parseNamedType());}while(this.expectOptionalToken(TokenKind.AMP)||// Legacy support for the SDL?\nthis._options.allowLegacySDLImplementsInterfaces&&this.peek(TokenKind.NAME));}return types;}/**\n   * FieldsDefinition : { FieldDefinition+ }\n   */;_proto.parseFieldsDefinition=function parseFieldsDefinition(){// Legacy support for the SDL?\nif(this._options.allowLegacySDLEmptyFields&&this.peek(TokenKind.BRACE_L)&&this._lexer.lookahead().kind===TokenKind.BRACE_R){this._lexer.advance();this._lexer.advance();return[];}return this.optionalMany(TokenKind.BRACE_L,this.parseFieldDefinition,TokenKind.BRACE_R);}/**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */;_proto.parseFieldDefinition=function parseFieldDefinition(){var start=this._lexer.token;var description=this.parseDescription();var name=this.parseName();var args=this.parseArgumentDefs();this.expectToken(TokenKind.COLON);var type=this.parseTypeReference();var directives=this.parseDirectives(true);return{kind:Kind.FIELD_DEFINITION,description:description,name:name,arguments:args,type:type,directives:directives,loc:this.loc(start)};}/**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */;_proto.parseArgumentDefs=function parseArgumentDefs(){return this.optionalMany(TokenKind.PAREN_L,this.parseInputValueDef,TokenKind.PAREN_R);}/**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */;_proto.parseInputValueDef=function parseInputValueDef(){var start=this._lexer.token;var description=this.parseDescription();var name=this.parseName();this.expectToken(TokenKind.COLON);var type=this.parseTypeReference();var defaultValue;if(this.expectOptionalToken(TokenKind.EQUALS)){defaultValue=this.parseValueLiteral(true);}var directives=this.parseDirectives(true);return{kind:Kind.INPUT_VALUE_DEFINITION,description:description,name:name,type:type,defaultValue:defaultValue,directives:directives,loc:this.loc(start)};}/**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */;_proto.parseInterfaceTypeDefinition=function parseInterfaceTypeDefinition(){var start=this._lexer.token;var description=this.parseDescription();this.expectKeyword('interface');var name=this.parseName();var directives=this.parseDirectives(true);var fields=this.parseFieldsDefinition();return{kind:Kind.INTERFACE_TYPE_DEFINITION,description:description,name:name,directives:directives,fields:fields,loc:this.loc(start)};}/**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */;_proto.parseUnionTypeDefinition=function parseUnionTypeDefinition(){var start=this._lexer.token;var description=this.parseDescription();this.expectKeyword('union');var name=this.parseName();var directives=this.parseDirectives(true);var types=this.parseUnionMemberTypes();return{kind:Kind.UNION_TYPE_DEFINITION,description:description,name:name,directives:directives,types:types,loc:this.loc(start)};}/**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */;_proto.parseUnionMemberTypes=function parseUnionMemberTypes(){var types=[];if(this.expectOptionalToken(TokenKind.EQUALS)){// Optional leading pipe\nthis.expectOptionalToken(TokenKind.PIPE);do{types.push(this.parseNamedType());}while(this.expectOptionalToken(TokenKind.PIPE));}return types;}/**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */;_proto.parseEnumTypeDefinition=function parseEnumTypeDefinition(){var start=this._lexer.token;var description=this.parseDescription();this.expectKeyword('enum');var name=this.parseName();var directives=this.parseDirectives(true);var values=this.parseEnumValuesDefinition();return{kind:Kind.ENUM_TYPE_DEFINITION,description:description,name:name,directives:directives,values:values,loc:this.loc(start)};}/**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */;_proto.parseEnumValuesDefinition=function parseEnumValuesDefinition(){return this.optionalMany(TokenKind.BRACE_L,this.parseEnumValueDefinition,TokenKind.BRACE_R);}/**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */;_proto.parseEnumValueDefinition=function parseEnumValueDefinition(){var start=this._lexer.token;var description=this.parseDescription();var name=this.parseName();var directives=this.parseDirectives(true);return{kind:Kind.ENUM_VALUE_DEFINITION,description:description,name:name,directives:directives,loc:this.loc(start)};}/**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */;_proto.parseInputObjectTypeDefinition=function parseInputObjectTypeDefinition(){var start=this._lexer.token;var description=this.parseDescription();this.expectKeyword('input');var name=this.parseName();var directives=this.parseDirectives(true);var fields=this.parseInputFieldsDefinition();return{kind:Kind.INPUT_OBJECT_TYPE_DEFINITION,description:description,name:name,directives:directives,fields:fields,loc:this.loc(start)};}/**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */;_proto.parseInputFieldsDefinition=function parseInputFieldsDefinition(){return this.optionalMany(TokenKind.BRACE_L,this.parseInputValueDef,TokenKind.BRACE_R);}/**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */;_proto.parseTypeSystemExtension=function parseTypeSystemExtension(){var keywordToken=this._lexer.lookahead();if(keywordToken.kind===TokenKind.NAME){switch(keywordToken.value){case'schema':return this.parseSchemaExtension();case'scalar':return this.parseScalarTypeExtension();case'type':return this.parseObjectTypeExtension();case'interface':return this.parseInterfaceTypeExtension();case'union':return this.parseUnionTypeExtension();case'enum':return this.parseEnumTypeExtension();case'input':return this.parseInputObjectTypeExtension();}}throw this.unexpected(keywordToken);}/**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */;_proto.parseSchemaExtension=function parseSchemaExtension(){var start=this._lexer.token;this.expectKeyword('extend');this.expectKeyword('schema');var directives=this.parseDirectives(true);var operationTypes=this.optionalMany(TokenKind.BRACE_L,this.parseOperationTypeDefinition,TokenKind.BRACE_R);if(directives.length===0&&operationTypes.length===0){throw this.unexpected();}return{kind:Kind.SCHEMA_EXTENSION,directives:directives,operationTypes:operationTypes,loc:this.loc(start)};}/**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */;_proto.parseScalarTypeExtension=function parseScalarTypeExtension(){var start=this._lexer.token;this.expectKeyword('extend');this.expectKeyword('scalar');var name=this.parseName();var directives=this.parseDirectives(true);if(directives.length===0){throw this.unexpected();}return{kind:Kind.SCALAR_TYPE_EXTENSION,name:name,directives:directives,loc:this.loc(start)};}/**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */;_proto.parseObjectTypeExtension=function parseObjectTypeExtension(){var start=this._lexer.token;this.expectKeyword('extend');this.expectKeyword('type');var name=this.parseName();var interfaces=this.parseImplementsInterfaces();var directives=this.parseDirectives(true);var fields=this.parseFieldsDefinition();if(interfaces.length===0&&directives.length===0&&fields.length===0){throw this.unexpected();}return{kind:Kind.OBJECT_TYPE_EXTENSION,name:name,interfaces:interfaces,directives:directives,fields:fields,loc:this.loc(start)};}/**\n   * InterfaceTypeExtension :\n   *   - extend interface Name Directives[Const]? FieldsDefinition\n   *   - extend interface Name Directives[Const]\n   */;_proto.parseInterfaceTypeExtension=function parseInterfaceTypeExtension(){var start=this._lexer.token;this.expectKeyword('extend');this.expectKeyword('interface');var name=this.parseName();var directives=this.parseDirectives(true);var fields=this.parseFieldsDefinition();if(directives.length===0&&fields.length===0){throw this.unexpected();}return{kind:Kind.INTERFACE_TYPE_EXTENSION,name:name,directives:directives,fields:fields,loc:this.loc(start)};}/**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */;_proto.parseUnionTypeExtension=function parseUnionTypeExtension(){var start=this._lexer.token;this.expectKeyword('extend');this.expectKeyword('union');var name=this.parseName();var directives=this.parseDirectives(true);var types=this.parseUnionMemberTypes();if(directives.length===0&&types.length===0){throw this.unexpected();}return{kind:Kind.UNION_TYPE_EXTENSION,name:name,directives:directives,types:types,loc:this.loc(start)};}/**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */;_proto.parseEnumTypeExtension=function parseEnumTypeExtension(){var start=this._lexer.token;this.expectKeyword('extend');this.expectKeyword('enum');var name=this.parseName();var directives=this.parseDirectives(true);var values=this.parseEnumValuesDefinition();if(directives.length===0&&values.length===0){throw this.unexpected();}return{kind:Kind.ENUM_TYPE_EXTENSION,name:name,directives:directives,values:values,loc:this.loc(start)};}/**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */;_proto.parseInputObjectTypeExtension=function parseInputObjectTypeExtension(){var start=this._lexer.token;this.expectKeyword('extend');this.expectKeyword('input');var name=this.parseName();var directives=this.parseDirectives(true);var fields=this.parseInputFieldsDefinition();if(directives.length===0&&fields.length===0){throw this.unexpected();}return{kind:Kind.INPUT_OBJECT_TYPE_EXTENSION,name:name,directives:directives,fields:fields,loc:this.loc(start)};}/**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */;_proto.parseDirectiveDefinition=function parseDirectiveDefinition(){var start=this._lexer.token;var description=this.parseDescription();this.expectKeyword('directive');this.expectToken(TokenKind.AT);var name=this.parseName();var args=this.parseArgumentDefs();var repeatable=this.expectOptionalKeyword('repeatable');this.expectKeyword('on');var locations=this.parseDirectiveLocations();return{kind:Kind.DIRECTIVE_DEFINITION,description:description,name:name,arguments:args,repeatable:repeatable,locations:locations,loc:this.loc(start)};}/**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */;_proto.parseDirectiveLocations=function parseDirectiveLocations(){// Optional leading pipe\nthis.expectOptionalToken(TokenKind.PIPE);var locations=[];do{locations.push(this.parseDirectiveLocation());}while(this.expectOptionalToken(TokenKind.PIPE));return locations;}/*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */;_proto.parseDirectiveLocation=function parseDirectiveLocation(){var start=this._lexer.token;var name=this.parseName();if(DirectiveLocation[name.value]!==undefined){return name;}throw this.unexpected(start);}// Core parsing utility functions\n/**\n   * Returns a location object, used to identify the place in\n   * the source that created a given parsed object.\n   */;_proto.loc=function loc(startToken){if(!this._options.noLocation){return new Loc(startToken,this._lexer.lastToken,this._lexer.source);}}/**\n   * Determines if the next token is of a given kind\n   */;_proto.peek=function peek(kind){return this._lexer.token.kind===kind;}/**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and throw an error.\n   */;_proto.expectToken=function expectToken(kind){var token=this._lexer.token;if(token.kind===kind){this._lexer.advance();return token;}throw syntaxError(this._lexer.source,token.start,\"Expected \".concat(kind,\", found \").concat(getTokenDesc(token)));}/**\n   * If the next token is of the given kind, return that token after advancing\n   * the lexer. Otherwise, do not change the parser state and return undefined.\n   */;_proto.expectOptionalToken=function expectOptionalToken(kind){var token=this._lexer.token;if(token.kind===kind){this._lexer.advance();return token;}return undefined;}/**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */;_proto.expectKeyword=function expectKeyword(value){var token=this._lexer.token;if(token.kind===TokenKind.NAME&&token.value===value){this._lexer.advance();}else{throw syntaxError(this._lexer.source,token.start,\"Expected \\\"\".concat(value,\"\\\", found \").concat(getTokenDesc(token)));}}/**\n   * If the next token is a given keyword, return \"true\" after advancing\n   * the lexer. Otherwise, do not change the parser state and return \"false\".\n   */;_proto.expectOptionalKeyword=function expectOptionalKeyword(value){var token=this._lexer.token;if(token.kind===TokenKind.NAME&&token.value===value){this._lexer.advance();return true;}return false;}/**\n   * Helper function for creating an error when an unexpected lexed token\n   * is encountered.\n   */;_proto.unexpected=function unexpected(atToken){var token=atToken||this._lexer.token;return syntaxError(this._lexer.source,token.start,\"Unexpected \".concat(getTokenDesc(token)));}/**\n   * Returns a possibly empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */;_proto.any=function any(openKind,parseFn,closeKind){this.expectToken(openKind);var nodes=[];while(!this.expectOptionalToken(closeKind)){nodes.push(parseFn.call(this));}return nodes;}/**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always\n   * return non-empty list that begins with a lex token of openKind and ends\n   * with a lex token of closeKind. Advances the parser to the next lex token\n   * after the closing token.\n   */;_proto.optionalMany=function optionalMany(openKind,parseFn,closeKind){if(this.expectOptionalToken(openKind)){var nodes=[];do{nodes.push(parseFn.call(this));}while(!this.expectOptionalToken(closeKind));return nodes;}return[];}/**\n   * Returns a non-empty list of parse nodes, determined by\n   * the parseFn. This list begins with a lex token of openKind\n   * and ends with a lex token of closeKind. Advances the parser\n   * to the next lex token after the closing token.\n   */;_proto.many=function many(openKind,parseFn,closeKind){this.expectToken(openKind);var nodes=[];do{nodes.push(parseFn.call(this));}while(!this.expectOptionalToken(closeKind));return nodes;};return Parser;}();function Loc(startToken,endToken,source){this.start=startToken.start;this.end=endToken.end;this.startToken=startToken;this.endToken=endToken;this.source=source;}// Print a simplified form when appearing in JSON/util.inspect.\ndefineToJSON(Loc,function(){return{start:this.start,end:this.end};});/**\n * A helper function to describe a token as a string for debugging\n */function getTokenDesc(token){var value=token.value;return value?\"\".concat(token.kind,\" \\\"\").concat(value,\"\\\"\"):token.kind;}","map":null,"metadata":{},"sourceType":"module"}