{"ast":null,"code":"/**\n * React Router v6.3.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */import{parsePath,createMemoryHistory,Action}from'history';export{Action as NavigationType,createPath,parsePath}from'history';import{createContext,useContext,useMemo,useRef,useEffect,useCallback,createElement,useState,useLayoutEffect,Children,isValidElement,Fragment}from'react';const NavigationContext=/*#__PURE__*/createContext(null);if(process.env.NODE_ENV!==\"production\"){NavigationContext.displayName=\"Navigation\";}const LocationContext=/*#__PURE__*/createContext(null);if(process.env.NODE_ENV!==\"production\"){LocationContext.displayName=\"Location\";}const RouteContext=/*#__PURE__*/createContext({outlet:null,matches:[]});if(process.env.NODE_ENV!==\"production\"){RouteContext.displayName=\"Route\";}function invariant(cond,message){if(!cond)throw new Error(message);}function warning(cond,message){if(!cond){// eslint-disable-next-line no-console\nif(typeof console!==\"undefined\")console.warn(message);try{// Welcome to debugging React Router!\n//\n// This error is thrown as a convenience so you can more easily\n// find the source for a warning that appears in the console by\n// enabling \"pause on exceptions\" in your JavaScript debugger.\nthrow new Error(message);// eslint-disable-next-line no-empty\n}catch(e){}}}const alreadyWarned={};function warningOnce(key,cond,message){if(!cond&&!alreadyWarned[key]){alreadyWarned[key]=true;process.env.NODE_ENV!==\"production\"?warning(false,message):void 0;}}/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/docs/en/v6/api#generatepath\n */function generatePath(path,params){if(params===void 0){params={};}return path.replace(/:(\\w+)/g,(_,key)=>{!(params[key]!=null)?process.env.NODE_ENV!==\"production\"?invariant(false,\"Missing \\\":\"+key+\"\\\" param\"):invariant(false):void 0;return params[key];}).replace(/\\/*\\*$/,_=>params[\"*\"]==null?\"\":params[\"*\"].replace(/^\\/*/,\"/\"));}/**\n * A RouteMatch contains info about how a route matched a URL.\n */ /**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchroutes\n */function matchRoutes(routes,locationArg,basename){if(basename===void 0){basename=\"/\";}let location=typeof locationArg===\"string\"?parsePath(locationArg):locationArg;let pathname=stripBasename(location.pathname||\"/\",basename);if(pathname==null){return null;}let branches=flattenRoutes(routes);rankRouteBranches(branches);let matches=null;for(let i=0;matches==null&&i<branches.length;++i){matches=matchRouteBranch(branches[i],pathname);}return matches;}function flattenRoutes(routes,branches,parentsMeta,parentPath){if(branches===void 0){branches=[];}if(parentsMeta===void 0){parentsMeta=[];}if(parentPath===void 0){parentPath=\"\";}routes.forEach((route,index)=>{let meta={relativePath:route.path||\"\",caseSensitive:route.caseSensitive===true,childrenIndex:index,route};if(meta.relativePath.startsWith(\"/\")){!meta.relativePath.startsWith(parentPath)?process.env.NODE_ENV!==\"production\"?invariant(false,\"Absolute route path \\\"\"+meta.relativePath+\"\\\" nested under path \"+(\"\\\"\"+parentPath+\"\\\" is not valid. An absolute child route path \")+\"must start with the combined path of all its parent routes.\"):invariant(false):void 0;meta.relativePath=meta.relativePath.slice(parentPath.length);}let path=joinPaths([parentPath,meta.relativePath]);let routesMeta=parentsMeta.concat(meta);// Add the children before adding this route to the array so we traverse the\n// route tree depth-first and child routes appear before their parents in\n// the \"flattened\" version.\nif(route.children&&route.children.length>0){!(route.index!==true)?process.env.NODE_ENV!==\"production\"?invariant(false,\"Index routes must not have child routes. Please remove \"+(\"all child routes from route path \\\"\"+path+\"\\\".\")):invariant(false):void 0;flattenRoutes(route.children,branches,routesMeta,path);}// Routes without a path shouldn't ever match by themselves unless they are\n// index routes, so don't add them to the list of possible branches.\nif(route.path==null&&!route.index){return;}branches.push({path,score:computeScore(path,route.index),routesMeta});});return branches;}function rankRouteBranches(branches){branches.sort((a,b)=>a.score!==b.score?b.score-a.score// Higher score first\n:compareIndexes(a.routesMeta.map(meta=>meta.childrenIndex),b.routesMeta.map(meta=>meta.childrenIndex)));}const paramRe=/^:\\w+$/;const dynamicSegmentValue=3;const indexRouteValue=2;const emptySegmentValue=1;const staticSegmentValue=10;const splatPenalty=-2;const isSplat=s=>s===\"*\";function computeScore(path,index){let segments=path.split(\"/\");let initialScore=segments.length;if(segments.some(isSplat)){initialScore+=splatPenalty;}if(index){initialScore+=indexRouteValue;}return segments.filter(s=>!isSplat(s)).reduce((score,segment)=>score+(paramRe.test(segment)?dynamicSegmentValue:segment===\"\"?emptySegmentValue:staticSegmentValue),initialScore);}function compareIndexes(a,b){let siblings=a.length===b.length&&a.slice(0,-1).every((n,i)=>n===b[i]);return siblings?// If two routes are siblings, we should try to match the earlier sibling\n// first. This allows people to have fine-grained control over the matching\n// behavior by simply putting routes with identical paths in the order they\n// want them tried.\na[a.length-1]-b[b.length-1]:// Otherwise, it doesn't really make sense to rank non-siblings by index,\n// so they sort equally.\n0;}function matchRouteBranch(branch,pathname){let{routesMeta}=branch;let matchedParams={};let matchedPathname=\"/\";let matches=[];for(let i=0;i<routesMeta.length;++i){let meta=routesMeta[i];let end=i===routesMeta.length-1;let remainingPathname=matchedPathname===\"/\"?pathname:pathname.slice(matchedPathname.length)||\"/\";let match=matchPath({path:meta.relativePath,caseSensitive:meta.caseSensitive,end},remainingPathname);if(!match)return null;Object.assign(matchedParams,match.params);let route=meta.route;matches.push({params:matchedParams,pathname:joinPaths([matchedPathname,match.pathname]),pathnameBase:normalizePathname(joinPaths([matchedPathname,match.pathnameBase])),route});if(match.pathnameBase!==\"/\"){matchedPathname=joinPaths([matchedPathname,match.pathnameBase]);}}return matches;}/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */ /**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchpath\n */function matchPath(pattern,pathname){if(typeof pattern===\"string\"){pattern={path:pattern,caseSensitive:false,end:true};}let[matcher,paramNames]=compilePath(pattern.path,pattern.caseSensitive,pattern.end);let match=pathname.match(matcher);if(!match)return null;let matchedPathname=match[0];let pathnameBase=matchedPathname.replace(/(.)\\/+$/,\"$1\");let captureGroups=match.slice(1);let params=paramNames.reduce((memo,paramName,index)=>{// We need to compute the pathnameBase here using the raw splat value\n// instead of using params[\"*\"] later because it will be decoded then\nif(paramName===\"*\"){let splatValue=captureGroups[index]||\"\";pathnameBase=matchedPathname.slice(0,matchedPathname.length-splatValue.length).replace(/(.)\\/+$/,\"$1\");}memo[paramName]=safelyDecodeURIComponent(captureGroups[index]||\"\",paramName);return memo;},{});return{params,pathname:matchedPathname,pathnameBase,pattern};}function compilePath(path,caseSensitive,end){if(caseSensitive===void 0){caseSensitive=false;}if(end===void 0){end=true;}process.env.NODE_ENV!==\"production\"?warning(path===\"*\"||!path.endsWith(\"*\")||path.endsWith(\"/*\"),\"Route path \\\"\"+path+\"\\\" will be treated as if it were \"+(\"\\\"\"+path.replace(/\\*$/,\"/*\")+\"\\\" because the `*` character must \")+\"always follow a `/` in the pattern. To get rid of this warning, \"+(\"please change the route path to \\\"\"+path.replace(/\\*$/,\"/*\")+\"\\\".\")):void 0;let paramNames=[];let regexpSource=\"^\"+path.replace(/\\/*\\*?$/,\"\")// Ignore trailing / and /*, we'll handle it below\n.replace(/^\\/*/,\"/\")// Make sure it has a leading /\n.replace(/[\\\\.*+^$?{}|()[\\]]/g,\"\\\\$&\")// Escape special regex chars\n.replace(/:(\\w+)/g,(_,paramName)=>{paramNames.push(paramName);return\"([^\\\\/]+)\";});if(path.endsWith(\"*\")){paramNames.push(\"*\");regexpSource+=path===\"*\"||path===\"/*\"?\"(.*)$\"// Already matched the initial /, just match the rest\n:\"(?:\\\\/(.+)|\\\\/*)$\";// Don't include the / in params[\"*\"]\n}else{regexpSource+=end?\"\\\\/*$\"// When matching to the end, ignore trailing slashes\n:// Otherwise, match a word boundary or a proceeding /. The word boundary restricts\n// parent routes to matching only their own words and nothing more, e.g. parent\n// route \"/home\" should not match \"/home2\".\n// Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,\n// but do not consume the character in the matched path so they can match against\n// nested paths.\n\"(?:(?=[.~-]|%[0-9A-F]{2})|\\\\b|\\\\/|$)\";}let matcher=new RegExp(regexpSource,caseSensitive?undefined:\"i\");return[matcher,paramNames];}function safelyDecodeURIComponent(value,paramName){try{return decodeURIComponent(value);}catch(error){process.env.NODE_ENV!==\"production\"?warning(false,\"The value for the URL param \\\"\"+paramName+\"\\\" will not be decoded because\"+(\" the string \\\"\"+value+\"\\\" is a malformed URL segment. This is probably\")+(\" due to a bad percent encoding (\"+error+\").\")):void 0;return value;}}/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/docs/en/v6/api#resolvepath\n */function resolvePath(to,fromPathname){if(fromPathname===void 0){fromPathname=\"/\";}let{pathname:toPathname,search=\"\",hash=\"\"}=typeof to===\"string\"?parsePath(to):to;let pathname=toPathname?toPathname.startsWith(\"/\")?toPathname:resolvePathname(toPathname,fromPathname):fromPathname;return{pathname,search:normalizeSearch(search),hash:normalizeHash(hash)};}function resolvePathname(relativePath,fromPathname){let segments=fromPathname.replace(/\\/+$/,\"\").split(\"/\");let relativeSegments=relativePath.split(\"/\");relativeSegments.forEach(segment=>{if(segment===\"..\"){// Keep the root \"\" segment so the pathname starts at /\nif(segments.length>1)segments.pop();}else if(segment!==\".\"){segments.push(segment);}});return segments.length>1?segments.join(\"/\"):\"/\";}function resolveTo(toArg,routePathnames,locationPathname){let to=typeof toArg===\"string\"?parsePath(toArg):toArg;let toPathname=toArg===\"\"||to.pathname===\"\"?\"/\":to.pathname;// If a pathname is explicitly provided in `to`, it should be relative to the\n// route context. This is explained in `Note on `<Link to>` values` in our\n// migration guide from v5 as a means of disambiguation between `to` values\n// that begin with `/` and those that do not. However, this is problematic for\n// `to` values that do not provide a pathname. `to` can simply be a search or\n// hash string, in which case we should assume that the navigation is relative\n// to the current location's pathname and *not* the route pathname.\nlet from;if(toPathname==null){from=locationPathname;}else{let routePathnameIndex=routePathnames.length-1;if(toPathname.startsWith(\"..\")){let toSegments=toPathname.split(\"/\");// Each leading .. segment means \"go up one route\" instead of \"go up one\n// URL segment\".  This is a key difference from how <a href> works and a\n// major reason we call this a \"to\" value instead of a \"href\".\nwhile(toSegments[0]===\"..\"){toSegments.shift();routePathnameIndex-=1;}to.pathname=toSegments.join(\"/\");}// If there are more \"..\" segments than parent routes, resolve relative to\n// the root / URL.\nfrom=routePathnameIndex>=0?routePathnames[routePathnameIndex]:\"/\";}let path=resolvePath(to,from);// Ensure the pathname has a trailing slash if the original to value had one.\nif(toPathname&&toPathname!==\"/\"&&toPathname.endsWith(\"/\")&&!path.pathname.endsWith(\"/\")){path.pathname+=\"/\";}return path;}function getToPathname(to){// Empty strings should be treated the same as / paths\nreturn to===\"\"||to.pathname===\"\"?\"/\":typeof to===\"string\"?parsePath(to).pathname:to.pathname;}function stripBasename(pathname,basename){if(basename===\"/\")return pathname;if(!pathname.toLowerCase().startsWith(basename.toLowerCase())){return null;}let nextChar=pathname.charAt(basename.length);if(nextChar&&nextChar!==\"/\"){// pathname does not start with basename/\nreturn null;}return pathname.slice(basename.length)||\"/\";}const joinPaths=paths=>paths.join(\"/\").replace(/\\/\\/+/g,\"/\");const normalizePathname=pathname=>pathname.replace(/\\/+$/,\"\").replace(/^\\/*/,\"/\");const normalizeSearch=search=>!search||search===\"?\"?\"\":search.startsWith(\"?\")?search:\"?\"+search;const normalizeHash=hash=>!hash||hash===\"#\"?\"\":hash.startsWith(\"#\")?hash:\"#\"+hash;/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usehref\n */function useHref(to){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useHref() may be used only in the context of a <Router> component.\"):invariant(false):void 0;let{basename,navigator}=useContext(NavigationContext);let{hash,pathname,search}=useResolvedPath(to);let joinedPathname=pathname;if(basename!==\"/\"){let toPathname=getToPathname(to);let endsWithSlash=toPathname!=null&&toPathname.endsWith(\"/\");joinedPathname=pathname===\"/\"?basename+(endsWithSlash?\"/\":\"\"):joinPaths([basename,pathname]);}return navigator.createHref({pathname:joinedPathname,search,hash});}/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext\n */function useInRouterContext(){return useContext(LocationContext)!=null;}/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/docs/en/v6/api#uselocation\n */function useLocation(){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useLocation() may be used only in the context of a <Router> component.\"):invariant(false):void 0;return useContext(LocationContext).location;}/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype\n */function useNavigationType(){return useContext(LocationContext).navigationType;}/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usematch\n */function useMatch(pattern){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useMatch() may be used only in the context of a <Router> component.\"):invariant(false):void 0;let{pathname}=useLocation();return useMemo(()=>matchPath(pattern,pathname),[pathname,pattern]);}/**\n * The interface for the navigate() function returned from useNavigate().\n */ /**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigate\n */function useNavigate(){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useNavigate() may be used only in the context of a <Router> component.\"):invariant(false):void 0;let{basename,navigator}=useContext(NavigationContext);let{matches}=useContext(RouteContext);let{pathname:locationPathname}=useLocation();let routePathnamesJson=JSON.stringify(matches.map(match=>match.pathnameBase));let activeRef=useRef(false);useEffect(()=>{activeRef.current=true;});let navigate=useCallback(function(to,options){if(options===void 0){options={};}process.env.NODE_ENV!==\"production\"?warning(activeRef.current,\"You should call navigate() in a React.useEffect(), not when \"+\"your component is first rendered.\"):void 0;if(!activeRef.current)return;if(typeof to===\"number\"){navigator.go(to);return;}let path=resolveTo(to,JSON.parse(routePathnamesJson),locationPathname);if(basename!==\"/\"){path.pathname=joinPaths([basename,path.pathname]);}(!!options.replace?navigator.replace:navigator.push)(path,options.state);},[basename,navigator,routePathnamesJson,locationPathname]);return navigate;}const OutletContext=/*#__PURE__*/createContext(null);/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext\n */function useOutletContext(){return useContext(OutletContext);}/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useoutlet\n */function useOutlet(context){let outlet=useContext(RouteContext).outlet;if(outlet){return/*#__PURE__*/createElement(OutletContext.Provider,{value:context},outlet);}return outlet;}/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useparams\n */function useParams(){let{matches}=useContext(RouteContext);let routeMatch=matches[matches.length-1];return routeMatch?routeMatch.params:{};}/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath\n */function useResolvedPath(to){let{matches}=useContext(RouteContext);let{pathname:locationPathname}=useLocation();let routePathnamesJson=JSON.stringify(matches.map(match=>match.pathnameBase));return useMemo(()=>resolveTo(to,JSON.parse(routePathnamesJson),locationPathname),[to,routePathnamesJson,locationPathname]);}/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useroutes\n */function useRoutes(routes,locationArg){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useRoutes() may be used only in the context of a <Router> component.\"):invariant(false):void 0;let{matches:parentMatches}=useContext(RouteContext);let routeMatch=parentMatches[parentMatches.length-1];let parentParams=routeMatch?routeMatch.params:{};let parentPathname=routeMatch?routeMatch.pathname:\"/\";let parentPathnameBase=routeMatch?routeMatch.pathnameBase:\"/\";let parentRoute=routeMatch&&routeMatch.route;if(process.env.NODE_ENV!==\"production\"){// You won't get a warning about 2 different <Routes> under a <Route>\n// without a trailing *, but this is a best-effort warning anyway since we\n// cannot even give the warning unless they land at the parent route.\n//\n// Example:\n//\n// <Routes>\n//   {/* This route path MUST end with /* because otherwise\n//       it will never match /blog/post/123 */}\n//   <Route path=\"blog\" element={<Blog />} />\n//   <Route path=\"blog/feed\" element={<BlogFeed />} />\n// </Routes>\n//\n// function Blog() {\n//   return (\n//     <Routes>\n//       <Route path=\"post/:id\" element={<Post />} />\n//     </Routes>\n//   );\n// }\nlet parentPath=parentRoute&&parentRoute.path||\"\";warningOnce(parentPathname,!parentRoute||parentPath.endsWith(\"*\"),\"You rendered descendant <Routes> (or called `useRoutes()`) at \"+(\"\\\"\"+parentPathname+\"\\\" (under <Route path=\\\"\"+parentPath+\"\\\">) but the \")+\"parent route path has no trailing \\\"*\\\". This means if you navigate \"+\"deeper, the parent won't match anymore and therefore the child \"+\"routes will never render.\\n\\n\"+(\"Please change the parent <Route path=\\\"\"+parentPath+\"\\\"> to <Route \")+(\"path=\\\"\"+(parentPath===\"/\"?\"*\":parentPath+\"/*\")+\"\\\">.\"));}let locationFromContext=useLocation();let location;if(locationArg){var _parsedLocationArg$pa;let parsedLocationArg=typeof locationArg===\"string\"?parsePath(locationArg):locationArg;!(parentPathnameBase===\"/\"||((_parsedLocationArg$pa=parsedLocationArg.pathname)==null?void 0:_parsedLocationArg$pa.startsWith(parentPathnameBase)))?process.env.NODE_ENV!==\"production\"?invariant(false,\"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \"+\"the location pathname must begin with the portion of the URL pathname that was \"+(\"matched by all parent routes. The current pathname base is \\\"\"+parentPathnameBase+\"\\\" \")+(\"but pathname \\\"\"+parsedLocationArg.pathname+\"\\\" was given in the `location` prop.\")):invariant(false):void 0;location=parsedLocationArg;}else{location=locationFromContext;}let pathname=location.pathname||\"/\";let remainingPathname=parentPathnameBase===\"/\"?pathname:pathname.slice(parentPathnameBase.length)||\"/\";let matches=matchRoutes(routes,{pathname:remainingPathname});if(process.env.NODE_ENV!==\"production\"){process.env.NODE_ENV!==\"production\"?warning(parentRoute||matches!=null,\"No routes matched location \\\"\"+location.pathname+location.search+location.hash+\"\\\" \"):void 0;process.env.NODE_ENV!==\"production\"?warning(matches==null||matches[matches.length-1].route.element!==undefined,\"Matched leaf route at location \\\"\"+location.pathname+location.search+location.hash+\"\\\" does not have an element. \"+\"This means it will render an <Outlet /> with a null value by default resulting in an \\\"empty\\\" page.\"):void 0;}return _renderMatches(matches&&matches.map(match=>Object.assign({},match,{params:Object.assign({},parentParams,match.params),pathname:joinPaths([parentPathnameBase,match.pathname]),pathnameBase:match.pathnameBase===\"/\"?parentPathnameBase:joinPaths([parentPathnameBase,match.pathnameBase])})),parentMatches);}function _renderMatches(matches,parentMatches){if(parentMatches===void 0){parentMatches=[];}if(matches==null)return null;return matches.reduceRight((outlet,match,index)=>{return/*#__PURE__*/createElement(RouteContext.Provider,{children:match.route.element!==undefined?match.route.element:outlet,value:{outlet,matches:parentMatches.concat(matches.slice(0,index+1))}});},null);}/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/docs/en/v6/api#memoryrouter\n */function MemoryRouter(_ref){let{basename,children,initialEntries,initialIndex}=_ref;let historyRef=useRef();if(historyRef.current==null){historyRef.current=createMemoryHistory({initialEntries,initialIndex});}let history=historyRef.current;let[state,setState]=useState({action:history.action,location:history.location});useLayoutEffect(()=>history.listen(setState),[history]);return/*#__PURE__*/createElement(Router,{basename:basename,children:children,location:state.location,navigationType:state.action,navigator:history});}/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/docs/en/v6/api#navigate\n */function Navigate(_ref2){let{to,replace,state}=_ref2;!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,// TODO: This error is probably because they somehow have 2 versions of\n// the router loaded. We can help them understand how to avoid that.\n\"<Navigate> may be used only in the context of a <Router> component.\"):invariant(false):void 0;process.env.NODE_ENV!==\"production\"?warning(!useContext(NavigationContext).static,\"<Navigate> must not be used on the initial render in a <StaticRouter>. \"+\"This is a no-op, but you should modify your code so the <Navigate> is \"+\"only ever rendered in response to some user interaction or state change.\"):void 0;let navigate=useNavigate();useEffect(()=>{navigate(to,{replace,state});});return null;}/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/docs/en/v6/api#outlet\n */function Outlet(props){return useOutlet(props.context);}/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#route\n */function Route(_props){process.env.NODE_ENV!==\"production\"?invariant(false,\"A <Route> is only ever to be used as the child of <Routes> element, \"+\"never rendered directly. Please wrap your <Route> in a <Routes>.\"):invariant(false);}/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/docs/en/v6/api#router\n */function Router(_ref3){let{basename:basenameProp=\"/\",children=null,location:locationProp,navigationType=Action.Pop,navigator,static:staticProp=false}=_ref3;!!useInRouterContext()?process.env.NODE_ENV!==\"production\"?invariant(false,\"You cannot render a <Router> inside another <Router>.\"+\" You should never have more than one in your app.\"):invariant(false):void 0;let basename=normalizePathname(basenameProp);let navigationContext=useMemo(()=>({basename,navigator,static:staticProp}),[basename,navigator,staticProp]);if(typeof locationProp===\"string\"){locationProp=parsePath(locationProp);}let{pathname=\"/\",search=\"\",hash=\"\",state=null,key=\"default\"}=locationProp;let location=useMemo(()=>{let trailingPathname=stripBasename(pathname,basename);if(trailingPathname==null){return null;}return{pathname:trailingPathname,search,hash,state,key};},[basename,pathname,search,hash,state,key]);process.env.NODE_ENV!==\"production\"?warning(location!=null,\"<Router basename=\\\"\"+basename+\"\\\"> is not able to match the URL \"+(\"\\\"\"+pathname+search+hash+\"\\\" because it does not start with the \")+\"basename, so the <Router> won't render anything.\"):void 0;if(location==null){return null;}return/*#__PURE__*/createElement(NavigationContext.Provider,{value:navigationContext},/*#__PURE__*/createElement(LocationContext.Provider,{children:children,value:{location,navigationType}}));}/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#routes\n */function Routes(_ref4){let{children,location}=_ref4;return useRoutes(createRoutesFromChildren(children),location);}///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren\n */function createRoutesFromChildren(children){let routes=[];Children.forEach(children,element=>{if(!/*#__PURE__*/isValidElement(element)){// Ignore non-elements. This allows people to more easily inline\n// conditionals in their route config.\nreturn;}if(element.type===Fragment){// Transparently support React.Fragment and its children.\nroutes.push.apply(routes,createRoutesFromChildren(element.props.children));return;}!(element.type===Route)?process.env.NODE_ENV!==\"production\"?invariant(false,\"[\"+(typeof element.type===\"string\"?element.type:element.type.name)+\"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\"):invariant(false):void 0;let route={caseSensitive:element.props.caseSensitive,element:element.props.element,index:element.props.index,path:element.props.path};if(element.props.children){route.children=createRoutesFromChildren(element.props.children);}routes.push(route);});return routes;}/**\n * Renders the result of `matchRoutes()` into a React element.\n */function renderMatches(matches){return _renderMatches(matches);}export{MemoryRouter,Navigate,Outlet,Route,Router,Routes,LocationContext as UNSAFE_LocationContext,NavigationContext as UNSAFE_NavigationContext,RouteContext as UNSAFE_RouteContext,createRoutesFromChildren,generatePath,matchPath,matchRoutes,renderMatches,resolvePath,useHref,useInRouterContext,useLocation,useMatch,useNavigate,useNavigationType,useOutlet,useOutletContext,useParams,useResolvedPath,useRoutes};","map":null,"metadata":{},"sourceType":"module"}