{"ast":null,"code":"import{GraphQLError}from'../../error/GraphQLError';import{print}from'../../language/printer';import{isCompositeType}from'../../type/definition';import{typeFromAST}from'../../utilities/typeFromAST';export function inlineFragmentOnNonCompositeErrorMessage(type){return\"Fragment cannot condition on non composite type \\\"\".concat(type,\"\\\".\");}export function fragmentOnNonCompositeErrorMessage(fragName,type){return\"Fragment \\\"\".concat(fragName,\"\\\" cannot condition on non composite type \\\"\").concat(type,\"\\\".\");}/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n */export function FragmentsOnCompositeTypes(context){return{InlineFragment:function InlineFragment(node){var typeCondition=node.typeCondition;if(typeCondition){var type=typeFromAST(context.getSchema(),typeCondition);if(type&&!isCompositeType(type)){context.reportError(new GraphQLError(inlineFragmentOnNonCompositeErrorMessage(print(typeCondition)),typeCondition));}}},FragmentDefinition:function FragmentDefinition(node){var type=typeFromAST(context.getSchema(),node.typeCondition);if(type&&!isCompositeType(type)){context.reportError(new GraphQLError(fragmentOnNonCompositeErrorMessage(node.name.value,print(node.typeCondition)),node.typeCondition));}}};}","map":null,"metadata":{},"sourceType":"module"}