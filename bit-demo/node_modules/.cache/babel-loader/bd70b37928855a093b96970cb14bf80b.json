{"ast":null,"code":"'use strict';Object.defineProperty(exports,\"__esModule\",{value:true});/*!\n * XRegExp.matchRecursive 4.0.0\n * <xregexp.com>\n * Steven Levithan (c) 2009-2017 MIT License\n */exports.default=function(XRegExp){/**\n     * Returns a match detail object composed of the provided values.\n     *\n     * @private\n     */function row(name,value,start,end){return{name:name,value:value,start:start,end:end};}/**\n     * Returns an array of match strings between outermost left and right delimiters, or an array of\n     * objects with detailed match parts and position data. An error is thrown if delimiters are\n     * unbalanced within the data.\n     *\n     * @memberOf XRegExp\n     * @param {String} str String to search.\n     * @param {String} left Left delimiter as an XRegExp pattern.\n     * @param {String} right Right delimiter as an XRegExp pattern.\n     * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.\n     * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.\n     * @returns {Array} Array of matches, or an empty array.\n     * @example\n     *\n     * // Basic usage\n     * let str = '(t((e))s)t()(ing)';\n     * XRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\n     * // -> ['t((e))s', '', 'ing']\n     *\n     * // Extended information mode with valueNames\n     * str = 'Here is <div> <div>an</div></div> example';\n     * XRegExp.matchRecursive(str, '<div\\\\s*>', '</div>', 'gi', {\n     *   valueNames: ['between', 'left', 'match', 'right']\n     * });\n     * // -> [\n     * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},\n     * // {name: 'left',    value: '<div>',          start: 8,  end: 13},\n     * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},\n     * // {name: 'right',   value: '</div>',         start: 27, end: 33},\n     * // {name: 'between', value: ' example',       start: 33, end: 41}\n     * // ]\n     *\n     * // Omitting unneeded parts with null valueNames, and using escapeChar\n     * str = '...{1}.\\\\{{function(x,y){return {y:x}}}';\n     * XRegExp.matchRecursive(str, '{', '}', 'g', {\n     *   valueNames: ['literal', null, 'value', null],\n     *   escapeChar: '\\\\'\n     * });\n     * // -> [\n     * // {name: 'literal', value: '...',  start: 0, end: 3},\n     * // {name: 'value',   value: '1',    start: 4, end: 5},\n     * // {name: 'literal', value: '.\\\\{', start: 6, end: 9},\n     * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}\n     * // ]\n     *\n     * // Sticky mode via flag y\n     * str = '<1><<<2>>><3>4<5>';\n     * XRegExp.matchRecursive(str, '<', '>', 'gy');\n     * // -> ['1', '<<2>>', '3']\n     */XRegExp.matchRecursive=function(str,left,right,flags,options){flags=flags||'';options=options||{};var global=flags.indexOf('g')!==-1;var sticky=flags.indexOf('y')!==-1;// Flag `y` is controlled internally\nvar basicFlags=flags.replace(/y/g,'');var escapeChar=options.escapeChar;var vN=options.valueNames;var output=[];var openTokens=0;var delimStart=0;var delimEnd=0;var lastOuterEnd=0;var outerStart=void 0;var innerStart=void 0;var leftMatch=void 0;var rightMatch=void 0;var esc=void 0;left=XRegExp(left,basicFlags);right=XRegExp(right,basicFlags);if(escapeChar){if(escapeChar.length>1){throw new Error('Cannot use more than one escape character');}escapeChar=XRegExp.escape(escapeChar);// Example of concatenated `esc` regex:\n// `escapeChar`: '%'\n// `left`: '<'\n// `right`: '>'\n// Regex is: /(?:%[\\S\\s]|(?:(?!<|>)[^%])+)+/\nesc=new RegExp('(?:'+escapeChar+'[\\\\S\\\\s]|(?:(?!'+// Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.\n// Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax\n// transformation resulting from those flags was already applied to `left` and\n// `right` when they were passed through the XRegExp constructor above.\nXRegExp.union([left,right],'',{conjunction:'or'}).source+')[^'+escapeChar+'])+)+',// Flags `gy` not needed here\nflags.replace(/[^imu]+/g,''));}while(true){// If using an escape character, advance to the delimiter's next starting position,\n// skipping any escaped characters in between\nif(escapeChar){delimEnd+=(XRegExp.exec(str,esc,delimEnd,'sticky')||[''])[0].length;}leftMatch=XRegExp.exec(str,left,delimEnd);rightMatch=XRegExp.exec(str,right,delimEnd);// Keep the leftmost match only\nif(leftMatch&&rightMatch){if(leftMatch.index<=rightMatch.index){rightMatch=null;}else{leftMatch=null;}}// Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):\n// LM | RM | OT | Result\n// 1  | 0  | 1  | loop\n// 1  | 0  | 0  | loop\n// 0  | 1  | 1  | loop\n// 0  | 1  | 0  | throw\n// 0  | 0  | 1  | throw\n// 0  | 0  | 0  | break\n// The paths above don't include the sticky mode special case. The loop ends after the\n// first completed match if not `global`.\nif(leftMatch||rightMatch){delimStart=(leftMatch||rightMatch).index;delimEnd=delimStart+(leftMatch||rightMatch)[0].length;}else if(!openTokens){break;}if(sticky&&!openTokens&&delimStart>lastOuterEnd){break;}if(leftMatch){if(!openTokens){outerStart=delimStart;innerStart=delimEnd;}++openTokens;}else if(rightMatch&&openTokens){if(! --openTokens){if(vN){if(vN[0]&&outerStart>lastOuterEnd){output.push(row(vN[0],str.slice(lastOuterEnd,outerStart),lastOuterEnd,outerStart));}if(vN[1]){output.push(row(vN[1],str.slice(outerStart,innerStart),outerStart,innerStart));}if(vN[2]){output.push(row(vN[2],str.slice(innerStart,delimStart),innerStart,delimStart));}if(vN[3]){output.push(row(vN[3],str.slice(delimStart,delimEnd),delimStart,delimEnd));}}else{output.push(str.slice(innerStart,delimStart));}lastOuterEnd=delimEnd;if(!global){break;}}}else{throw new Error('Unbalanced delimiter found in string');}// If the delimiter matched an empty string, avoid an infinite loop\nif(delimStart===delimEnd){++delimEnd;}}if(global&&!sticky&&vN&&vN[0]&&str.length>lastOuterEnd){output.push(row(vN[0],str.slice(lastOuterEnd),lastOuterEnd,str.length));}return output;};};module.exports=exports['default'];","map":null,"metadata":{},"sourceType":"module"}