{"ast":null,"code":"\"use strict\";require(\"core-js/modules/es.symbol.description.js\");require(\"core-js/modules/es.symbol.async-iterator.js\");require(\"core-js/modules/es.array.iterator.js\");require(\"core-js/modules/es.array.sort.js\");require(\"core-js/modules/es.promise.js\");require(\"core-js/modules/es.regexp.exec.js\");Object.defineProperty(exports,\"__esModule\",{value:true});exports.Component=void 0;function _toolboxString(){const data=require(\"@teambit/toolbox.string.capitalize\");_toolboxString=function(){return data;};return data;}function _bitError(){const data=require(\"@teambit/bit-error\");_bitError=function(){return data;};return data;}function _lodash(){const data=require(\"lodash\");_lodash=function(){return data;};return data;}function _tagMap(){const data=require(\"./tag-map\");_tagMap=function(){return data;};return data;}function _exceptions(){const data=require(\"./exceptions\");_exceptions=function(){return data;};return data;}function _asyncIterator(iterable){var method,async,sync,retry=2;for(\"undefined\"!=typeof Symbol&&(async=Symbol.asyncIterator,sync=Symbol.iterator);retry--;){if(async&&null!=(method=iterable[async]))return method.call(iterable);if(sync&&null!=(method=iterable[sync]))return new AsyncFromSyncIterator(method.call(iterable));async=\"@@asyncIterator\",sync=\"@@iterator\";}throw new TypeError(\"Object is not async iterable\");}function AsyncFromSyncIterator(s){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+\" is not an object.\"));var done=r.done;return Promise.resolve(r.value).then(function(value){return{value:value,done:done};});}return AsyncFromSyncIterator=function(s){this.s=s,this.n=s.next;},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments));},return:function(value){var ret=this.s.return;return void 0===ret?Promise.resolve({value:value,done:!0}):AsyncFromSyncIteratorContinuation(ret.apply(this.s,arguments));},throw:function(value){var thr=this.s.return;return void 0===thr?Promise.reject(value):AsyncFromSyncIteratorContinuation(thr.apply(this.s,arguments));}},new AsyncFromSyncIterator(s);}/**\n * in-memory representation of a component.\n */class Component{constructor(/**\n   * component ID represented by the `ComponentId` type.\n   */id,/**\n   * head version of the component. can be `null` for new components.\n   */head=null,/**\n   * state of the component.\n   */_state,/**\n   * tags of the component.\n   */tags=new(_tagMap().TagMap)(),/**\n   * the component factory\n   */factory){this.id=id;this.head=head;this._state=_state;this.tags=tags;this.factory=factory;}get mainFile(){return this.state.mainFile;}get state(){return this._state;}set state(state){this._state=state;}/**\n   * component configuration which is later generated to a component `package.json` and `bit.json`.\n   */get config(){return this.state.config;}/**\n   * in-memory representation of the component current filesystem.\n   */get filesystem(){return this.state.filesystem;}/**\n   * build status of the component\n   */get buildStatus(){return this._state._consumer.buildStatus;}get headTag(){if(!this.head)return undefined;return this.tags.byHash(this.head.hash);}get latest(){if(!this.head)return undefined;try{return this.tags.getLatest();}catch(err){if(err instanceof _exceptions().CouldNotFindLatest){return this.head.hash;}throw err;}}/**\n   * get aspect data from current state.\n   */get(id){var _this$state$aspects$g;return(_this$state$aspects$g=this.state.aspects.get(id))===null||_this$state$aspects$g===void 0?void 0:_this$state$aspects$g.serialize();}async getLogs(filter){const allLogs=await this.factory.getLogs(this.id,false,filter===null||filter===void 0?void 0:filter.head);if(!filter)return allLogs;const{type,limit,offset,sort}=filter;const typeFilter=snap=>{if(type==='tag')return snap.tag;if(type==='snap')return!snap.tag;return true;};let filteredLogs=type&&allLogs.filter(typeFilter)||allLogs;if(sort!=='asc')filteredLogs=filteredLogs.reverse();if(limit){filteredLogs=(0,_lodash().slice)(filteredLogs,offset,limit+(offset||0));}return filteredLogs;}stringify(){return JSON.stringify({id:this.id,head:this.head});}/**\n   * record component changes in the `Scope`.\n   */ // snap(author: Author, message = '') {\n// if (!this.isModified()) throw new NothingToSnap();\n// const snap = new Snap(this, author, message);\n// return new Component(this.id, snap, snap.state);\n// }\n/**\n   * display name of the component.\n   */get displayName(){const tokens=this.id.name.split('-').map(token=>(0,_toolboxString().capitalize)(token));return tokens.join(' ');}/**\n   * tag a component `Snap` with a semantic version. we follow SemVer specs as defined [here](https://semver.org/)).\n   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars\ntag(version){// const snap = this.snap();\n// const tag = new Tag(version, snap);\n// this.tags.set(tag);\n}/**\n   * determines whether this component is modified in the workspace.\n   */isModified(){return this.factory.isModified(this);}/**\n   * is component isOutdated\n   */isOutdated(){var _this$head;if(!this.latest)return false;const latestTag=this.tags.byVersion(this.latest);if(!latestTag)return false;if(((_this$head=this.head)===null||_this$head===void 0?void 0:_this$head.hash)!==(latestTag===null||latestTag===void 0?void 0:latestTag.hash))return true;return false;}/**\n   * determines whether this component is new.\n   */isNew(){return Promise.resolve(this.head===null);}// TODO: @david after snap we need to make sure to refactor here.\nloadState(snapId){return this.factory.getState(this.id,snapId);}loadSnap(snapId){var _this$head2;const snapToGet=snapId||((_this$head2=this.head)===null||_this$head2===void 0?void 0:_this$head2.hash);if(!snapToGet){throw new(_bitError().BitError)('could not load snap for new components');}return this.factory.getSnap(this.id,snapToGet);}/**\n   * Get iterable which iterate over snap parents lazily\n   * @param snapId\n   * @param options\n   */snapsIterable(snapId,options={}){var _this$head3;const snapToStart=snapId||((_this$head3=this.head)===null||_this$head3===void 0?void 0:_this$head3.hash);let nextSnaps=[snapToStart];let done;if(!snapToStart){done=true;}const iterator={next:async()=>{if(done){return{value:undefined,done};}const currSnapId=nextSnaps.shift();const snap=await this.loadSnap(currSnapId);if(snap.parents&&snap.parents.length){if(options.firstParentOnly){nextSnaps.push(snap.parents[0]);}else{nextSnaps=nextSnaps.concat(snap.parents);}}if(!nextSnaps.length){done=true;}else if(options.stopFn){done=await options.stopFn(snap);}return{value:snap,done:undefined};}};return{[Symbol.asyncIterator]:()=>iterator};}/**\n   * traverse recursively from the provided snap (or head) upwards until it finds a tag\n   * @param snapToStartFrom\n   */async getClosestTag(snapToStartFrom){const tagsHashMap=this.tags.getHashMap();const stopFn=async snap=>{if(tagsHashMap.has(snap.hash)){return true;}return false;};const iterable=this.snapsIterable(snapToStartFrom,{firstParentOnly:true,stopFn});const snaps=[];var _iteratorAbruptCompletion=false;var _didIteratorError=false;var _iteratorError;try{for(var _iterator=_asyncIterator(iterable),_step;_iteratorAbruptCompletion=!(_step=await _iterator.next()).done;_iteratorAbruptCompletion=false){const snap=_step.value;snaps.push(snap);}}catch(err){_didIteratorError=true;_iteratorError=err;}finally{try{if(_iteratorAbruptCompletion&&_iterator.return!=null){await _iterator.return();}}finally{if(_didIteratorError){throw _iteratorError;}}}if(snaps.length){const hashOfLastSnap=snaps[snaps.length-1].hash;return tagsHashMap.get(hashOfLastSnap);}return undefined;}/**\n   * checkout the component to a different version in its working tree.\n   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars\ncheckout(version){}/**\n   * examine difference between two components.\n   */ // diff(other: Component): Difference {}\n/**\n   * merge two different components\n   */ // merge(other: Component): Component {}\n/**\n   * write a component to a given file system.\n   * @param path root path to write the component\n   * @param fs instance of any fs to use.\n   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars\nwrite(path,fs){}/**\n   *\n   * Check if 2 components are equal\n   * @param {Component} component\n   * @returns {boolean}\n   * @memberof Component\n   */ // eslint-disable-next-line @typescript-eslint/no-unused-vars\nequals(component){return component.id.toString()===this.id.toString();}}exports.Component=Component;","map":null,"metadata":{},"sourceType":"module"}