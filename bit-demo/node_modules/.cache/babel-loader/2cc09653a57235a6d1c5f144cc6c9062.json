{"ast":null,"code":"/**\n * @param {string} value\n * @returns {RegExp}\n * */ /**\n * @param {RegExp | string } re\n * @returns {string}\n */function source(re){if(!re)return null;if(typeof re===\"string\")return re;return re.source;}/**\n * @param {RegExp | string } re\n * @returns {string}\n */function anyNumberOfTimes(re){return concat('(',re,')*');}/**\n * @param {RegExp | string } re\n * @returns {string}\n */function optional(re){return concat('(',re,')?');}/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */function concat(...args){const joined=args.map(x=>source(x)).join(\"\");return joined;}/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */function either(...args){const joined='('+args.map(x=>source(x)).join(\"|\")+\")\";return joined;}/*\nLanguage: Handlebars\nRequires: xml.js\nAuthor: Robin Ward <robin.ward@gmail.com>\nDescription: Matcher for Handlebars as well as EmberJS additions.\nWebsite: https://handlebarsjs.com\nCategory: template\n*/function handlebars(hljs){const BUILT_INS={'builtin-name':['action','bindattr','collection','component','concat','debugger','each','each-in','get','hash','if','in','input','link-to','loc','log','lookup','mut','outlet','partial','query-params','render','template','textarea','unbound','unless','view','with','yield']};const LITERALS={literal:['true','false','undefined','null']};// as defined in https://handlebarsjs.com/guide/expressions.html#literal-segments\n// this regex matches literal segments like ' abc ' or [ abc ] as well as helpers and paths\n// like a/b, ./abc/cde, and abc.bcd\nconst DOUBLE_QUOTED_ID_REGEX=/\"\"|\"[^\"]+\"/;const SINGLE_QUOTED_ID_REGEX=/''|'[^']+'/;const BRACKET_QUOTED_ID_REGEX=/\\[\\]|\\[[^\\]]+\\]/;const PLAIN_ID_REGEX=/[^\\s!\"#%&'()*+,.\\/;<=>@\\[\\\\\\]^`{|}~]+/;const PATH_DELIMITER_REGEX=/(\\.|\\/)/;const ANY_ID=either(DOUBLE_QUOTED_ID_REGEX,SINGLE_QUOTED_ID_REGEX,BRACKET_QUOTED_ID_REGEX,PLAIN_ID_REGEX);const IDENTIFIER_REGEX=concat(optional(/\\.|\\.\\/|\\//),// relative or absolute path\nANY_ID,anyNumberOfTimes(concat(PATH_DELIMITER_REGEX,ANY_ID)));// identifier followed by a equal-sign (without the equal sign)\nconst HASH_PARAM_REGEX=concat('(',BRACKET_QUOTED_ID_REGEX,'|',PLAIN_ID_REGEX,')(?==)');const HELPER_NAME_OR_PATH_EXPRESSION={begin:IDENTIFIER_REGEX,lexemes:/[\\w.\\/]+/};const HELPER_PARAMETER=hljs.inherit(HELPER_NAME_OR_PATH_EXPRESSION,{keywords:LITERALS});const SUB_EXPRESSION={begin:/\\(/,end:/\\)/ // the \"contains\" is added below when all necessary sub-modes are defined\n};const HASH={// fka \"attribute-assignment\", parameters of the form 'key=value'\nclassName:'attr',begin:HASH_PARAM_REGEX,relevance:0,starts:{begin:/=/,end:/=/,starts:{contains:[hljs.NUMBER_MODE,hljs.QUOTE_STRING_MODE,hljs.APOS_STRING_MODE,HELPER_PARAMETER,SUB_EXPRESSION]}}};const BLOCK_PARAMS={// parameters of the form '{{#with x as | y |}}...{{/with}}'\nbegin:/as\\s+\\|/,keywords:{keyword:'as'},end:/\\|/,contains:[{// define sub-mode in order to prevent highlighting of block-parameter named \"as\"\nbegin:/\\w+/}]};const HELPER_PARAMETERS={contains:[hljs.NUMBER_MODE,hljs.QUOTE_STRING_MODE,hljs.APOS_STRING_MODE,BLOCK_PARAMS,HASH,HELPER_PARAMETER,SUB_EXPRESSION],returnEnd:true// the property \"end\" is defined through inheritance when the mode is used. If depends\n// on the surrounding mode, but \"endsWithParent\" does not work here (i.e. it includes the\n// end-token of the surrounding mode)\n};const SUB_EXPRESSION_CONTENTS=hljs.inherit(HELPER_NAME_OR_PATH_EXPRESSION,{className:'name',keywords:BUILT_INS,starts:hljs.inherit(HELPER_PARAMETERS,{end:/\\)/})});SUB_EXPRESSION.contains=[SUB_EXPRESSION_CONTENTS];const OPENING_BLOCK_MUSTACHE_CONTENTS=hljs.inherit(HELPER_NAME_OR_PATH_EXPRESSION,{keywords:BUILT_INS,className:'name',starts:hljs.inherit(HELPER_PARAMETERS,{end:/\\}\\}/})});const CLOSING_BLOCK_MUSTACHE_CONTENTS=hljs.inherit(HELPER_NAME_OR_PATH_EXPRESSION,{keywords:BUILT_INS,className:'name'});const BASIC_MUSTACHE_CONTENTS=hljs.inherit(HELPER_NAME_OR_PATH_EXPRESSION,{className:'name',keywords:BUILT_INS,starts:hljs.inherit(HELPER_PARAMETERS,{end:/\\}\\}/})});const ESCAPE_MUSTACHE_WITH_PRECEEDING_BACKSLASH={begin:/\\\\\\{\\{/,skip:true};const PREVENT_ESCAPE_WITH_ANOTHER_PRECEEDING_BACKSLASH={begin:/\\\\\\\\(?=\\{\\{)/,skip:true};return{name:'Handlebars',aliases:['hbs','html.hbs','html.handlebars','htmlbars'],case_insensitive:true,subLanguage:'xml',contains:[ESCAPE_MUSTACHE_WITH_PRECEEDING_BACKSLASH,PREVENT_ESCAPE_WITH_ANOTHER_PRECEEDING_BACKSLASH,hljs.COMMENT(/\\{\\{!--/,/--\\}\\}/),hljs.COMMENT(/\\{\\{!/,/\\}\\}/),{// open raw block \"{{{{raw}}}} content not evaluated {{{{/raw}}}}\"\nclassName:'template-tag',begin:/\\{\\{\\{\\{(?!\\/)/,end:/\\}\\}\\}\\}/,contains:[OPENING_BLOCK_MUSTACHE_CONTENTS],starts:{end:/\\{\\{\\{\\{\\//,returnEnd:true,subLanguage:'xml'}},{// close raw block\nclassName:'template-tag',begin:/\\{\\{\\{\\{\\//,end:/\\}\\}\\}\\}/,contains:[CLOSING_BLOCK_MUSTACHE_CONTENTS]},{// open block statement\nclassName:'template-tag',begin:/\\{\\{#/,end:/\\}\\}/,contains:[OPENING_BLOCK_MUSTACHE_CONTENTS]},{className:'template-tag',begin:/\\{\\{(?=else\\}\\})/,end:/\\}\\}/,keywords:'else'},{className:'template-tag',begin:/\\{\\{(?=else if)/,end:/\\}\\}/,keywords:'else if'},{// closing block statement\nclassName:'template-tag',begin:/\\{\\{\\//,end:/\\}\\}/,contains:[CLOSING_BLOCK_MUSTACHE_CONTENTS]},{// template variable or helper-call that is NOT html-escaped\nclassName:'template-variable',begin:/\\{\\{\\{/,end:/\\}\\}\\}/,contains:[BASIC_MUSTACHE_CONTENTS]},{// template variable or helper-call that is html-escaped\nclassName:'template-variable',begin:/\\{\\{/,end:/\\}\\}/,contains:[BASIC_MUSTACHE_CONTENTS]}]};}/*\n Language: HTMLBars (legacy)\n Requires: xml.js\n Description: Matcher for Handlebars as well as EmberJS additions.\n Website: https://github.com/tildeio/htmlbars\n Category: template\n */function htmlbars(hljs){const definition=handlebars(hljs);definition.name=\"HTMLbars\";// HACK: This lets handlebars do the auto-detection if it's been loaded (by\n// default the build script will load in alphabetical order) and if not (perhaps\n// an install is only using `htmlbars`, not `handlebars`) then this will still\n// allow HTMLBars to participate in the auto-detection\n// worse case someone will have HTMLbars and handlebars competing for the same\n// content and will need to change their setup to only require handlebars, but\n// I don't consider this a breaking change\nif(hljs.getLanguage(\"handlebars\")){definition.disableAutodetect=true;}return definition;}module.exports=htmlbars;","map":null,"metadata":{},"sourceType":"module"}