{"ast":null,"code":"'use strict';Object.defineProperty(exports,\"__esModule\",{value:true});/*!\n * XRegExp Unicode Base 4.0.0\n * <xregexp.com>\n * Steven Levithan (c) 2008-2017 MIT License\n */exports.default=function(XRegExp){/**\n     * Adds base support for Unicode matching:\n     * - Adds syntax `\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\P{..}` or\n     *   `\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\n     *   braces for token names that are a single letter (e.g. `\\pL` or `PL`).\n     * - Adds flag A (astral), which enables 21-bit Unicode support.\n     * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\n     *\n     * Unicode Base relies on externally provided Unicode character data. Official addons are\n     * available to provide data for Unicode categories, scripts, blocks, and properties.\n     *\n     * @requires XRegExp\n     */ // ==--------------------------==\n// Private stuff\n// ==--------------------------==\n// Storage for Unicode data\nvar unicode={};// Reuse utils\nvar dec=XRegExp._dec;var hex=XRegExp._hex;var pad4=XRegExp._pad4;// Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\nfunction normalize(name){return name.replace(/[- _]+/g,'').toLowerCase();}// Gets the decimal code of a literal code unit, \\xHH, \\uHHHH, or a backslash-escaped literal\nfunction charCode(chr){var esc=/^\\\\[xu](.+)/.exec(chr);return esc?dec(esc[1]):chr.charCodeAt(chr[0]==='\\\\'?1:0);}// Inverts a list of ordered BMP characters and ranges\nfunction invertBmp(range){var output='';var lastEnd=-1;XRegExp.forEach(range,/(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/,function(m){var start=charCode(m[1]);if(start>lastEnd+1){output+='\\\\u'+pad4(hex(lastEnd+1));if(start>lastEnd+2){output+='-\\\\u'+pad4(hex(start-1));}}lastEnd=charCode(m[2]||m[1]);});if(lastEnd<0xFFFF){output+='\\\\u'+pad4(hex(lastEnd+1));if(lastEnd<0xFFFE){output+='-\\\\uFFFF';}}return output;}// Generates an inverted BMP range on first use\nfunction cacheInvertedBmp(slug){var prop='b!';return unicode[slug][prop]||(unicode[slug][prop]=invertBmp(unicode[slug].bmp));}// Combines and optionally negates BMP and astral data\nfunction buildAstral(slug,isNegated){var item=unicode[slug];var combined='';if(item.bmp&&!item.isBmpLast){combined='['+item.bmp+']'+(item.astral?'|':'');}if(item.astral){combined+=item.astral;}if(item.isBmpLast&&item.bmp){combined+=(item.astral?'|':'')+'['+item.bmp+']';}// Astral Unicode tokens always match a code point, never a code unit\nreturn isNegated?'(?:(?!'+combined+')(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\0-\\uFFFF]))':'(?:'+combined+')';}// Builds a complete astral pattern on first use\nfunction cacheAstral(slug,isNegated){var prop=isNegated?'a!':'a=';return unicode[slug][prop]||(unicode[slug][prop]=buildAstral(slug,isNegated));}// ==--------------------------==\n// Core functionality\n// ==--------------------------==\n/*\n     * Add astral mode (flag A) and Unicode token syntax: `\\p{..}`, `\\P{..}`, `\\p{^..}`, `\\pC`.\n     */XRegExp.addToken(// Use `*` instead of `+` to avoid capturing `^` as the token name in `\\p{^}`\n/\\\\([pP])(?:{(\\^?)([^}]*)}|([A-Za-z]))/,function(match,scope,flags){var ERR_DOUBLE_NEG='Invalid double negation ';var ERR_UNKNOWN_NAME='Unknown Unicode token ';var ERR_UNKNOWN_REF='Unicode token missing data ';var ERR_ASTRAL_ONLY='Astral mode required for Unicode token ';var ERR_ASTRAL_IN_CLASS='Astral mode does not support Unicode tokens within character classes';// Negated via \\P{..} or \\p{^..}\nvar isNegated=match[1]==='P'||!!match[2];// Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\nvar isAstralMode=flags.indexOf('A')!==-1;// Token lookup name. Check `[4]` first to avoid passing `undefined` via `\\p{}`\nvar slug=normalize(match[4]||match[3]);// Token data object\nvar item=unicode[slug];if(match[1]==='P'&&match[2]){throw new SyntaxError(ERR_DOUBLE_NEG+match[0]);}if(!unicode.hasOwnProperty(slug)){throw new SyntaxError(ERR_UNKNOWN_NAME+match[0]);}// Switch to the negated form of the referenced Unicode token\nif(item.inverseOf){slug=normalize(item.inverseOf);if(!unicode.hasOwnProperty(slug)){throw new ReferenceError(ERR_UNKNOWN_REF+match[0]+' -> '+item.inverseOf);}item=unicode[slug];isNegated=!isNegated;}if(!(item.bmp||isAstralMode)){throw new SyntaxError(ERR_ASTRAL_ONLY+match[0]);}if(isAstralMode){if(scope==='class'){throw new SyntaxError(ERR_ASTRAL_IN_CLASS);}return cacheAstral(slug,isNegated);}return scope==='class'?isNegated?cacheInvertedBmp(slug):item.bmp:(isNegated?'[^':'[')+item.bmp+']';},{scope:'all',optionalFlags:'A',leadChar:'\\\\'});/**\n     * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\p` or `\\P`.\n     *\n     * @memberOf XRegExp\n     * @param {Array} data Objects with named character ranges. Each object may have properties\n     *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\n     *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\n     *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\n     *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\n     *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\n     *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\n     *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\n     *   `astral` data should be a combination of literal characters and `\\xHH` or `\\uHHHH` escape\n     *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\n     *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\n     *   character classes and alternation, and should use surrogate pairs to represent astral code\n     *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\n     *   defined as the exact inverse of another token.\n     * @example\n     *\n     * // Basic use\n     * XRegExp.addUnicodeData([{\n     *   name: 'XDigit',\n     *   alias: 'Hexadecimal',\n     *   bmp: '0-9A-Fa-f'\n     * }]);\n     * XRegExp('\\\\p{XDigit}:\\\\p{Hexadecimal}+').test('0:3D'); // -> true\n     */XRegExp.addUnicodeData=function(data){var ERR_NO_NAME='Unicode token requires name';var ERR_NO_DATA='Unicode token has no character data ';var item=void 0;for(var i=0;i<data.length;++i){item=data[i];if(!item.name){throw new Error(ERR_NO_NAME);}if(!(item.inverseOf||item.bmp||item.astral)){throw new Error(ERR_NO_DATA+item.name);}unicode[normalize(item.name)]=item;if(item.alias){unicode[normalize(item.alias)]=item;}}// Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\n// flags might now produce different results\nXRegExp.cache.flush('patterns');};/**\n     * @ignore\n     *\n     * Return a reference to the internal Unicode definition structure for the given Unicode\n     * Property if the given name is a legal Unicode Property for use in XRegExp `\\p` or `\\P` regex\n     * constructs.\n     *\n     * @memberOf XRegExp\n     * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),\n     *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode\n     *   Properties and Property Aliases.\n     * @returns {Object} Reference to definition structure when the name matches a Unicode Property.\n     *\n     * @note\n     * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\n     *\n     * @note\n     * This method is *not* part of the officially documented API and may change or be removed in\n     * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode\n     * structures set up by XRegExp.\n     */XRegExp._getUnicodeProperty=function(name){var slug=normalize(name);return unicode[slug];};};module.exports=exports['default'];","map":null,"metadata":{},"sourceType":"module"}